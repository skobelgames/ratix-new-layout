<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <title>RATIX - Strategic Chess Variant</title>
    <style>
        :root {
            --fixed-app-width: 1320px;
            --app-zoom: 0.95;
        }
        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Prevent horizontal scrolling and lock viewport */
        html {
            overflow-x: hidden;
            width: 100%;
            height: 100%;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #202020;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
            width: var(--fixed-app-width);
            min-width: var(--fixed-app-width);
            max-width: var(--fixed-app-width);
        }
        body.game-loaded {
            justify-content: center;
        }
        #game-container {
            display: none;
            flex-direction: column;
            align-items: stretch;
            width: var(--fixed-app-width);
            min-width: var(--fixed-app-width);
            max-width: var(--fixed-app-width);
            margin: 0 auto;
            overflow-x: hidden;
        }
        #start-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fff;
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
            width: 640px;
            min-width: 640px;
            max-width: 640px;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        #start-menu h2 {
            margin-bottom: 20px;
        }
        #start-menu button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
        }
        #player-setup {
            width: 100%;
            margin: 20px 0 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            text-align: left;
        }
        #player-setup label {
            font-size: 14px;
            margin-bottom: 6px;
        }
        #player-setup input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }
        #high-score-panel {
            width: 100%;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid #ccc;
            text-align: left;
        }
        #high-score-panel h3 {
            margin: 0 0 10px;
            font-size: 18px;
        }
        #high-score-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 220px;
            overflow-y: auto;
        }
        #high-score-list li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #ececec;
            font-size: 14px;
        }
        #high-score-list li.empty {
            justify-content: center;
            color: #666;
            border-bottom: none;
        }
        #high-score-list .rank {
            width: 28px;
            text-align: left;
            font-weight: bold;
            color: #2c2c2c;
        }
        #high-score-list .entry-name {
            flex: 1;
            margin: 0 8px;
            font-weight: 600;
            color: #2c2c2c;
        }
        #high-score-list .entry-score {
            width: 90px;
            text-align: right;
            color: #444;
        }
        #clear-high-scores {
            margin-top: 12px;
            align-self: flex-end;
            background-color: #f44336;
            color: #fff;
            border: 2px solid #b71c1c;
        }
        #clear-high-scores:hover {
            background-color: #d32f2f;
        }
        /* Style for the selected difficulty button */
        #start-menu button.selected-diff {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-option {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-opponent {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        #start-menu button.selected-hint {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #4CAF50;
        }
        .variant-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
            max-width: 300px;
            text-align: center;
        }
        .variant-option button.selected-variant {
            background-color: #4CAF50;
            color: #fff;
            border: 2px solid #4CAF50;
        }
        .variant-description {
            margin-top: 6px;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
        }
        .variant-info {
            display: none;
            width: 100%;
            margin-top: 6px;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #f7f7f7;
            text-align: left;
        }
        .variant-info.visible {
            display: block;
            background-color: #f0f0f0;
        }
        .variant-difficulty {
            margin-top: 6px;
            font-size: 13px;
            color: #555;
        }
        #landing-header {
            text-align: center;
            color: #fff;
            margin-bottom: 20px;
        }
        #landing-header h1 {
            margin: 0;
            font-size: 48px;
            letter-spacing: 1px;
        }
        #landing-header p {
            margin: 6px 0 18px;
            font-size: 16px;
            color: #cccccc;
        }
        #landing-header .how-to-button {
            margin-bottom: 10px;
        }
        #landing-footer {
            margin-top: 20px;
            color: #cccccc;
            font-size: 14px;
            text-align: center;
        }
        #difficulty-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #opponent-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #opponent-selector button {
            width: calc(33.33% - 10px);
            margin: 5px;
            display: inline-block;
        }
        #hint-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #game-timer-selector, #turn-timer-selector {
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 15px;
            text-align: center;
        }
        #board {
            display: grid;
            border: 2px solid #000000;
            background-color: #fff;
            margin: 0 auto;
            /* Lock board dimensions - will be set by JavaScript based on variant */
            flex-shrink: 0;
            flex-grow: 0;
        }
        .square {
            width: 50px;
            height: 50px;
            min-width: 50px;
            min-height: 50px;
            max-width: 50px;
            max-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.5s ease-in-out; /* Smooth transition for background color */
            flex-shrink: 0;
        }
        .dark-void {
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.15), rgba(92, 0, 138, 0.95));
            animation: darkVoidPulse 2.5s ease-in-out infinite;
            box-shadow: inset 0 0 20px rgba(150, 75, 255, 0.9);
        }
        .dark-void::before {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 8px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.25), rgba(164, 91, 255, 0.15), transparent 70%);
            mix-blend-mode: screen;
            animation: darkVoidSwirl 6s linear infinite;
            pointer-events: none;
        }
        .dark-void::after {
            content: '';
            position: absolute;
            inset: 2px;
            border-radius: 8px;
            border: 1px solid rgba(215, 132, 255, 0.7);
            box-shadow: 0 0 18px rgba(215, 132, 255, 0.9), inset 0 0 8px rgba(171, 65, 255, 0.8);
            animation: darkVoidGlow 3s ease-in-out infinite;
            pointer-events: none;
        }
        #board.barrage-glow {
            border-color: #ffeb3b;
            box-shadow: 0 0 24px rgba(255, 235, 59, 0.9), inset 0 0 30px rgba(255, 193, 7, 0.6);
        }
        body.barrage-game-glow::after {
            content: '';
            position: fixed;
            inset: 0;
            background: rgba(255, 235, 59, 0.15);
            pointer-events: none;
            z-index: 500;
            animation: barrageGlowPulse 0.6s ease-out;
        }
        @keyframes barrageGlowPulse {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        .square.barrage-hit {
            box-shadow: inset 0 0 16px rgba(255, 120, 0, 0.9), 0 0 12px rgba(255, 80, 0, 0.9);
        }
        .square.barrage-hit::after {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 8px;
            border: 2px solid rgba(255, 204, 153, 0.6);
            box-shadow: 0 0 20px rgba(255, 160, 0, 0.75);
            animation: barrageSpark 1.2s ease-out;
        }
        @keyframes barrageSpark {
            0% { transform: scale(0.6); opacity: 0.8; }
            100% { transform: scale(1.3); opacity: 0; }
        }
        @keyframes darkVoidSwirl {
            from { transform: rotate(0deg) scale(1); }
            to { transform: rotate(360deg) scale(1); }
        }
        @keyframes darkVoidGlow {
            0% {
                box-shadow: 0 0 12px rgba(215, 132, 255, 0.4), inset 0 0 8px rgba(164, 91, 255, 0.5);
            }
            50% {
                box-shadow: 0 0 26px rgba(171, 65, 255, 0.85), inset 0 0 14px rgba(215, 132, 255, 0.8);
            }
            100% {
                box-shadow: 0 0 14px rgba(215, 132, 255, 0.5), inset 0 0 8px rgba(164, 91, 255, 0.5);
            }
        }
        @keyframes darkVoidPulse {
            0% {
                background-size: 110%;
            }
            50% {
                background-size: 130%;
            }
            100% {
                background-size: 110%;
            }
        }
        .piece {
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            min-width: 40px;
            min-height: 40px;
            max-width: 40px;
            max-height: 40px;
            background-color: rgb(0, 0, 0);
            border-radius: 50%;
            line-height: 1;
            flex-shrink: 0;
        }
        .piece.white {
            background-color: rgb(255, 255, 255);
        }
        .piece.black {
            background-color: rgb(0, 0, 0);
        }
        .light { background-color: #999999; }
        .dark { background-color: #363535; }
        .ai-move-highlight { background-color: #ffcc00 !important; }
        .selected { background-color: #ffcc00 !important; }
        .valid-move { background-color: #ffff99 !important; }
        .valid-capture { background-color: #ff2020 !important; }
        .valid-shoot { background-color: #ff2020 !important; }
        .valid-swap { background-color: #99ff99 !important; }
        .valid-dark-void-target {
            border: 2px solid rgba(230, 150, 255, 0.9);
            box-shadow: inset 0 0 10px rgba(230, 150, 255, 0.6), 0 0 18px rgba(175, 85, 255, 0.7);
        }
        .hint-highlight {
            background-color: transparent !important;
            box-shadow: 0 0 16px rgba(0, 255, 255, 0.9) !important;
            animation: pulse-hint 1.2s ease-in-out infinite;
            position: relative;
            z-index: 5;
            opacity: 1 !important;
        }
        .hint-highlight::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid rgba(0, 255, 255, 0.9);
            border-radius: 0;
            box-shadow: 0 0 14px rgba(0, 255, 255, 0.8), 0 0 8px rgba(0, 255, 255, 0.45) inset;
            pointer-events: none;
            z-index: 6;
        }
        #coin-toss-progress {
            display: none;
            color: #000000 !important;
            font-weight: bold;
            margin-left: 12px;
            text-shadow: none;
        }
        @keyframes pulse-hint {
            0%, 100% {
                box-shadow: 0 0 16px rgba(0, 255, 255, 0.95);
            }
            50% {
                box-shadow: 0 0 28px rgba(0, 255, 255, 0.25);
            }
        }
        .energy-blast-path,
        .energy-blast-residual {
            position: relative;
            z-index: 4;
        }
        .energy-blast-path::after,
        .energy-blast-residual::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid rgba(109, 204, 255, 0.95);
            border-radius: 0;
            box-shadow: 0 0 12px rgba(143, 212, 255, 0.9), 0 0 20px rgba(109, 204, 255, 0.45);
            pointer-events: none;
            z-index: 5;
            animation: energyBlastRingPulse 1.4s ease-in-out infinite;
        }
        @keyframes energyBlastRingPulse {
            0%, 100% {
                opacity: 1;
                box-shadow: 0 0 12px rgba(143, 212, 255, 0.9), 0 0 20px rgba(109, 204, 255, 0.45);
            }
            50% {
                opacity: 0.65;
                box-shadow: 0 0 18px rgba(143, 212, 255, 0.8), 0 0 28px rgba(109, 204, 255, 0.35);
            }
        }
        .soul-blast-preview {
            position: relative;
            z-index: 4;
        }
        .soul-blast-preview::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid rgba(228, 149, 255, 0.9);
            border-radius: 0;
            box-shadow: 0 0 18px rgba(228, 149, 255, 0.95), 0 0 24px rgba(132, 58, 255, 0.55);
            pointer-events: none;
            z-index: 6;
            animation: soulBlastPreviewPulse 1.2s ease-in-out infinite;
        }
        @keyframes soulBlastPreviewPulse {
            0%, 100% {
                opacity: 0.9;
            }
            50% {
                opacity: 0.55;
                box-shadow: 0 0 26px rgba(239, 189, 255, 0.95), 0 0 34px rgba(150, 72, 255, 0.7);
            }
        }
        .piece-arrow {
            font-size: 12px;
            position: absolute;
            bottom: 0px;
            right: 0px;
        }
        #status {
            width: 100%;
            padding: 10px;
            background-color: #000;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            color: #999;
            box-sizing: border-box;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        #round-timer-box {
            width: 100%;
            padding: 10px;
            background-color: #000;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            color: #999;
            box-sizing: border-box;
            min-height: 0;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 15px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        #round-timer-box #round-number-display,
        #round-timer-box #game-timer-row {
            margin: 0;
            text-align: center;
        }
        #top-bar {
            width: 100%;
            max-width: 1264px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            color: #fff;
            margin: 10px auto 0;
            box-sizing: border-box;
        }
        #top-buttons-left,
        #top-buttons-right {
            display: flex;
            gap: 5px;
            flex: 0 0 auto;
        }
        #top-buttons-left button,
        #top-buttons-right button {
            padding: 10px 12px;
            font-size: 14px;
            width: 120px;
            background-color: #000;
            color: #999;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            white-space: nowrap;
        }
        #top-buttons-left button:hover,
        #top-buttons-right button:hover {
            background-color: #1a1a1a;
            color: #fff;
        }
        #top-buttons-left .toggle-button.active,
        #top-buttons-right .toggle-button.active {
            background-color: #1a1a1a;
            color: #fff;
            border-color: #555;
        }
        .player-panel,
        .round-panel {
            background-color: #2a2a2a;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
            color: #fff;
            box-sizing: border-box;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
        }
        .player-panel {
            width: 100%;
            text-align: left;
            position: relative;
            justify-content: flex-end;
            min-height: 90px;
        }
        .panel-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ai-content {
            text-align: right;
        }
        .ai-content .player-name,
        .ai-content .player-score,
        .ai-content .timer-row {
            text-align: right;
        }
        .round-panel {
            flex: 0 0 auto;
            align-items: center;
            text-align: center;
            justify-content: center;
            min-width: 200px;
            padding: 6px 16px;
            min-height: 0;
        }
        .player-name {
            font-size: 14px;
            font-weight: 700;
        }
        .player-score,
        #round-number-display {
            font-size: 14px;
            font-weight: 600;
        }
        #round-number-display {
            font-weight: 700;
        }
        .timer-row {
            font-size: 14px;
            margin: 0;
        }
        .timer-row.player {
            text-align: left;
        }
        .timer-row.game {
            text-align: center;
        }
        .timer-row.ai {
            text-align: right;
        }
        .timer-row.low-time {
            color: #FFD700;
            font-weight: bold;
        }
        .reaction-emoji {
            position: absolute;
            top: 50%;
            transform: translateY(-50%) scale(0);
            font-size: 32px;
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            pointer-events: none;
            z-index: 10;
        }
        #player-reaction-emoji {
            right: 10px;
        }
        #ai-reaction-emoji {
            left: 10px;
        }
        .reaction-emoji.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
            animation: emojiPop 0.5s ease-out;
        }
        @keyframes emojiPop {
            0% {
                transform: translateY(-50%) scale(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                transform: translateY(-50%) scale(1.3) rotate(10deg);
            }
            75% {
                transform: translateY(-50%) scale(0.9) rotate(-5deg);
            }
            100% {
                transform: translateY(-50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        #info-box {
            width: 100%;
            padding: 15px;
            background-color: #000;
            color: #999;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
            display: none;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: var(--board-panel-max-height, 400px);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        #info-box .piece-lives {
            margin-top: 6px;
            color: #e53935;
            font-size: 16px;
            letter-spacing: 2px;
        }
        #game-log {
            width: 100%;
            height: 0;
            min-height: 0;
            max-height: 0;
            padding: 0 15px;
            background-color: #000;
            color: #999;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            overflow-y: hidden;
            overflow-x: hidden;
            text-align: left;
            box-sizing: border-box;
            word-wrap: break-word;
            overflow-wrap: break-word;
            transition: max-height 0.3s ease, padding 0.3s ease, min-height 0.3s ease;
        }
        #game-log.expanded {
            height: 180px;
            min-height: 180px;
            max-height: 180px;
            padding: 15px;
            overflow-y: auto;
        }
        #captured-pieces {
            position: relative;
            width: 100%;
            padding: 0;
            background: #000;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            text-align: left;
            box-sizing: border-box;
            overflow-y: hidden;
            overflow-x: hidden;
            max-height: 0;
            display: none;
            flex-direction: column;
            gap: 0;
            color: #999;
            box-shadow: none;
            isolation: isolate;
            word-wrap: break-word;
            overflow-wrap: break-word;
            transition: max-height 0.3s ease, padding 0.3s ease, gap 0.3s ease, border 0.3s ease, box-shadow 0.3s ease;
        }
        #captured-pieces.expanded {
            display: flex;
            padding: 20px;
            overflow-y: auto;
            max-height: var(--board-panel-max-height, 420px);
            gap: 18px;
            border: 1px solid #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        #captured-pieces::before {
            content: "";
            position: absolute;
            inset: 0;
            background: transparent;
            pointer-events: none;
            border-radius: 12px;
            z-index: -1;
        }
        .graveyard-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .graveyard-title {
            font-size: 18px;
            letter-spacing: 1.2px;
            text-transform: uppercase;
        }
        .graveyard-subtitle {
            font-size: 13px;
            color: #c9b7dd;
        }
        .graveyard-columns {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 14px;
        }
        #captured-pieces h3 {
            font-size: 13px;
            font-weight: 600;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #d3c3ef;
        }
        .captured-column {
            flex: 1 1 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 14px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .captured-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        .captured-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            background: #000;
            border: 1px solid #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s ease, border-color 0.2s ease, background-color 0.2s ease;
        }
        .captured-entry:hover {
            transform: translateY(-2px);
            background-color: #1a1a1a;
            border-color: #555;
        }
        .captured-entry.empty {
            font-weight: 500;
            color: #8c7aa5;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .captured-entry .piece {
            width: 38px;
            height: 38px;
            font-size: 22px;
            flex: 0 0 38px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .grave-piece {
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.35);
        }
        .grave-meta {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
            text-transform: uppercase;
        }
        .grave-name {
            font-size: 12px;
            letter-spacing: 1px;
        }
        .grave-count {
            font-size: 11px;
            color: #bca4d3;
            letter-spacing: 0.5px;
        }
        #game-layout {
            display: grid;
            grid-template-columns: 260px 704px 260px;
            gap: 20px;
            width: 1264px;
            min-width: 1264px;
            max-width: 1264px;
            justify-content: center;
            align-items: flex-start;
            margin: 10px auto 0;
        }
        #board-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 704px;
            min-width: 704px;
            max-width: 704px;
        }
        #left-panel,
        #right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 260px;
            min-width: 260px;
            max-width: 260px;
        }
        #left-panel {
            align-items: stretch;
        }
        #right-panel {
            align-items: stretch;
        }
        .toggle-button {
            width: 100%;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            background-color: #000;
            color: #999;
            border: 1px solid #333;
            padding: 8px 4px;
            border-radius: 5px;
            font-size: 12px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .toggle-button:hover {
            background-color: #1a1a1a;
            color: #bbb;
        }
        .toggle-button.active {
            background-color: #4CAF50;
            color: white;
        }
        #reinforce-modal, #turn-modal, #turn-move-modal, #turn-shoot-modal, #truce-modal, #coin-toss-modal, #dice-roll-modal, #spell-direction-modal, #protection-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 20px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 1000;
            max-width: 90%;
            max-height: 90vh;
            overflow: auto;
            box-sizing: border-box;
        }
        #truce-modal {
            z-index: 2001;
            max-width: 500px;
            text-align: center;
        }
        #truce-modal .modal-content p {
            margin: 15px 0;
            font-size: 16px;
        }
        #truce-modal .modal-footer button {
            margin: 10px;
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: white;
        }
        #truce-modal .modal-footer button:hover {
            opacity: 0.9;
        }
        #coin-toss-modal {
            z-index: 2002;
            max-width: 400px;
            text-align: center;
        }
        #coin-toss-modal .coin {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            border: 5px solid #333;
            background-color: #666;
            color: white;
            transition: all 0.3s ease;
        }
        #coin-toss-modal .coin.spinning {
            animation: flipCoin 2s ease-in-out;
        }
        #coin-toss-modal .coin.white {
            background-color: white;
            color: black;
        }
        #coin-toss-modal .coin.black {
            background-color: black;
            color: white;
        }
        @keyframes flipCoin {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(3600deg); }
        }
        #coin-toss-modal .modal-content p {
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
        }
        #dice-roll-modal {
            z-index: 2003;
            max-width: 520px;
            text-align: center;
        }
        #dice-roll-modal .modal-content {
            padding: 10px 0;
        }
        #dice-roll-modal .dice-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin: 15px auto;
            flex-wrap: wrap;
        }
        #dice-roll-modal .dice-face {
            flex: 1 1 140px;
            min-width: 140px;
            height: 170px;
            border-radius: 22px;
            border: 3px solid #111;
            background: radial-gradient(circle at 30% 30%, #2b2b2b, #090909 65%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.7), inset 0 0 30px rgba(255, 255, 255, 0.05);
            position: relative;
            color: #fff;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
            transition: transform 0.4s ease, box-shadow 0.4s ease;
        }
        #dice-roll-modal .dice-face::after {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.18), transparent 60%);
            pointer-events: none;
        }
        #dice-roll-modal .dice-face.rolling {
            animation: diceRoll3d 1.4s ease-in-out;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            transform: rotateX(25deg) rotateY(20deg);
        }
        #dice-roll-modal .dice-label {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 8px;
            color: #444;
        }
        #dice-roll-modal .dice-value {
            font-size: 54px;
            font-weight: 700;
            color: #fff;
            transition: color 0.3s ease, transform 0.3s ease;
            letter-spacing: 0.05em;
        }
        #dice-roll-modal .dice-value.bonus {
            color: #2e7d32;
        }
        #dice-roll-modal .dice-value.penalty {
            color: #c62828;
        }
        #dice-roll-modal .dice-outcome {
            font-size: 18px;
            font-weight: 600;
            margin-top: 10px;
        }
        @keyframes diceRoll3d {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
            50% { transform: rotateX(180deg) rotateY(180deg) scale(1.05); }
            100% { transform: rotateX(360deg) rotateY(360deg) scale(1); }
        }
        #reinforce-modal select, #reinforce-modal button, #turn-modal select, #turn-modal button, #turn-move-modal select, #turn-move-modal button, #turn-shoot-modal select, #turn-shoot-modal button {
            margin: 10px;
            padding: 5px;
            font-size: 14px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
        }
        .modal-close:hover {
            color: #c00;
        }
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(50, 50, 50, 0.8);
            z-index: 2001;
        }
        #endgame-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #202020;
            z-index: 2003;
        }
        #how-to-play-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 0;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 2005;
            width: 90vw;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            box-sizing: border-box;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }
        #how-to-play-modal .modal-header {
            background-color: #333;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-radius: 8px 8px 0 0;
        }
        #how-to-play-modal .modal-header .modal-close {
            color: #fff;
            font-size: 24px;
        }
        #how-to-play-modal .modal-content {
            padding: 20px;
            max-height: calc(80vh - 120px);
            overflow-y: auto;
        }
        #how-to-play-modal .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #ddd;
            text-align: center;
        }
        #how-to-play-modal .modal-footer button {
            padding: 10px 30px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #how-to-play-modal .modal-footer button:hover {
            background-color: #45a049;
        }
        #rules-content h2 {
            color: #333;
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-top: 20px;
        }
        #rules-content h3 {
            color: #555;
            margin-top: 15px;
        }
        #rules-content .piece-info {
            background-color: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #333;
            border-radius: 3px;
        }
        #rules-content .piece-name {
            font-weight: bold;
            color: #333;
            font-size: 16px;
        }
        #rules-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        #rules-content li {
            margin: 5px 0;
        }
        #controls {
            margin-top: 0;
            display: inline-flex;
            gap: 10px;
            flex-wrap: nowrap;
            justify-content: center;
            width: auto;
            min-width: max-content;
            overflow: visible;
        }
        #controls button {
            flex: 0 0 auto;
        }
        #board.low-time {
            border-color: #FFD700 !important;
            box-shadow: 0 0 10px #FFD700;
        }
        /* Alternating glow when both timer warning and warcry are active */
        #board.low-time.warcry-active-border {
            animation: alternatingTimerWarcryGlow 2s ease-in-out infinite !important;
        }
        @keyframes alternatingTimerWarcryGlow {
            0%, 100% {
                border-color: #FFD700;
                box-shadow: 0 0 30px #FFD700;
            }
            50% {
                border-color: #d4af37;
                box-shadow: 0 0 40px #d4af37;
            }
        }
        #board.coin-flip-success {
            border-color: #FFFFFF !important;
            box-shadow: 0 0 20px #FFFFFF;
            animation: coinFlipGlow 1.5s ease-in-out;
        }
        @keyframes coinFlipGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
            50% {
                border-color: #FFFFFF;
                box-shadow: 0 0 30px #FFFFFF;
            }
            100% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
        }
        #board.coin-flip-success-energy {
            border-color: #6a80ff !important;
            box-shadow: 0 0 24px #8fd4ff;
            animation: coinFlipEnergyBlastGlow 3.4s ease-in-out forwards;
        }
        @keyframes coinFlipEnergyBlastGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
            50% {
                border-color: #6a80ff;
                box-shadow: 0 0 32px #9fd6ff;
            }
            75% {
                border-color: #7f94ff;
                box-shadow: 0 0 40px #b8e5ff;
            }
            100% {
                border-color: #6a80ff;
                box-shadow: 0 0 20px #6a80ff;
            }
        }
        #board.coin-flip-failure {
            animation: coinFlipFailure 1.5s ease-in-out;
        }
        @keyframes coinFlipFailure {
            0% {
                background-color: #fff !important;
            }
            50% {
                background-color: #000000 !important;
            }
            100% {
                background-color: #fff !important;
            }
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            box-sizing: border-box;
            min-height: 40px;
        }
        button.control-button-active {
            background-color: #FFD966 !important;
            border-color: #D6A000 !important;
            color: #1a1a1a !important;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* New styles for capture effects */
        .capture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            animation: fadeOut 2s ease-in-out;
            z-index: 10;
        }
        .square.mercenary-highlight {
            z-index: 5;
        }
        .square.mercenary-highlight::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #FFD700;
            border-radius: 0;
            box-shadow: 0 0 14px rgba(255, 215, 0, 0.85), 0 0 8px rgba(255, 215, 0, 0.5) inset;
            pointer-events: none;
            z-index: 6;
        }
        .capture-background {
            background-color: rgb(223, 0, 0) !important;
            animation: fadeOutBackground 2s ease-in-out;
        }
        .capture-game-background {
            background-color: rgb(223, 0, 0) !important;
            animation: fadeOutGameBackground 2s ease-in-out;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        @keyframes fadeOutBackground {
            from { background-color: rgb(223, 0, 0); }
            to { background-color: inherit; }
        }
        @keyframes fadeOutGameBackground {
            from { background-color: rgb(223, 0, 0); }
            to { background-color: #202020; }
        }
        .coinflip-failure-game-background {
            background-color: #000000 !important;
            animation: fadeOutCoinFlipFailureBackground 2s ease-in-out;
        }
        @keyframes fadeOutCoinFlipFailureBackground {
            from { background-color: #000000; }
            to { background-color: #202020; }
        }
        /* Coin flip result popup styles */
        #coin-flip-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.98);
            padding: 25px 35px;
            border: 3px solid #333;
            border-radius: 12px;
            z-index: 2005;
            text-align: center;
            min-width: 280px;
            max-width: 90%;
            box-sizing: border-box;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            animation: popupFadeIn 0.2s ease-out;
        }
        #coin-flip-popup.success {
            border-color: #4CAF50;
            background-color: rgba(232, 255, 232, 0.98);
        }
        #coin-flip-popup.failure {
            border-color: #f44336;
            background-color: rgba(255, 232, 232, 0.98);
        }
        #coin-flip-popup h2 {
            margin: 0 0 10px 0;
            font-size: 28px;
            font-weight: bold;
        }
        #coin-flip-popup.success h2 {
            color: #2e7d32;
        }
        #coin-flip-popup.failure h2 {
            color: #c62828;
        }
        #coin-flip-popup p {
            margin: 5px 0 0 0;
            font-size: 16px;
            color: #333;
            line-height: 1.4;
        }
        @keyframes popupFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        @keyframes popupFadeOut {
            from {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            to {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
        }
        /* Warcry achievement popup styles */
        #warcry-achievement-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px 40px;
            border: 2px solid #333;
            border-radius: 10px;
            z-index: 2003;
            text-align: center;
            min-width: min(400px, 90%);
            max-width: 90%;
            box-sizing: border-box;
        }
        #warcry-achievement-modal h1 {
            margin: 0;
            font-size: 48px;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 4px;
        }
        #warcry-achievement-modal p {
            margin: 15px 0 0 0;
            font-size: 20px;
            color: #666;
        }
        #board.warcry-achievement {
            border-color: #d4af37 !important;
            box-shadow: 0 0 30px #d4af37;
            animation: warcryGlow 2.6s ease-in-out;
        }
        @keyframes warcryGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
            50% {
                border-color: #d4af37;
                box-shadow: 0 0 40px #d4af37;
            }
            100% {
                border-color: #000000;
                box-shadow: 0 0 0px #000000;
            }
        }
        .warcry-achievement-background {
            background-color: #000000 !important;
            animation: fadeOutWarcryAchievementBackground 2.6s ease-in-out;
        }
        #board.dark-void-active {
            border-color: #b66cff !important;
            box-shadow: 0 0 32px rgba(182, 108, 255, 0.9);
            animation: darkVoidBoardGlow 2.6s ease-in-out;
        }
        @keyframes darkVoidBoardGlow {
            0% {
                border-color: #000000;
                box-shadow: 0 0 0px rgba(0, 0, 0, 0);
            }
            50% {
                border-color: #b66cff;
                box-shadow: 0 0 34px rgba(182, 108, 255, 0.95);
            }
            100% {
                border-color: #000000;
                box-shadow: 0 0 0px rgba(0, 0, 0, 0);
            }
        }
        .dark-void-background {
            background-color: #000000 !important;
            animation: fadeOutDarkVoidBackground 2.6s ease-in-out;
        }
        @keyframes fadeOutDarkVoidBackground {
            from { background-color: #000000; }
            to { background-color: #202020; }
        }
        #dark-void-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #0c0018;
            padding: 30px 40px;
            border: 2px solid #7b2cff;
            border-radius: 10px;
            z-index: 2004;
            text-align: center;
            min-width: min(400px, 90%);
            max-width: 90%;
            box-sizing: border-box;
        }
        #dark-void-modal h1 {
            margin: 0;
            font-size: 48px;
            color: #c48fff;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.6);
            letter-spacing: 4px;
        }
        #dark-void-modal p {
            margin: 15px 0 0 0;
            font-size: 20px;
            color: #b0b0c1;
        }
        @keyframes fadeOutWarcryAchievementBackground {
            from { background-color: #000000; }
            to { background-color: #202020; }
        }
        .energy-blast-overlay {
            background: linear-gradient(135deg, #150c2b 0%, #24104f 50%, #150c2b 100%) !important;
            background-size: 400% 400%;
            animation: energyBlastOverlay 6s ease-in-out infinite;
            position: relative;
        }
        .energy-blast-overlay.soul-blast-overlay {
            background: linear-gradient(135deg, #1b021f 0%, #380042 45%, #120019 100%) !important;
            animation: soulBlastOverlay 7s ease-in-out infinite;
        }
@keyframes energyBlastOverlay {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        @keyframes soulBlastOverlay {
            0% {
                background-position: 0% 0%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 100%;
            }
        }
        .energy-blast-overlay::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at 20% 20%, rgba(143, 212, 255, 0.25), transparent 70%),
                        radial-gradient(circle at 80% 0%, rgba(106, 128, 255, 0.2), transparent 65%),
                        radial-gradient(circle at 60% 80%, rgba(80, 58, 255, 0.15), transparent 70%);
            animation: energyBlastRipple 12s linear infinite;
            z-index: 0;
            opacity: 0.4;
        }
        .energy-blast-overlay.soul-blast-overlay::after {
            background: radial-gradient(circle at 25% 30%, rgba(214, 101, 255, 0.25), transparent 65%),
                        radial-gradient(circle at 80% 10%, rgba(168, 92, 255, 0.25), transparent 55%),
                        radial-gradient(circle at 60% 85%, rgba(116, 46, 255, 0.2), transparent 70%);
            opacity: 0.5;
            animation: soulBlastOverlayParticles 10s linear infinite;
        }
@keyframes energyBlastRipple {
            0% {
                transform: translate3d(0, 0, 0);
                opacity: 0.5;
            }
            50% {
                transform: translate3d(-2%, -1%, 0);
                opacity: 0.35;
            }
            100% {
                transform: translate3d(2%, 1%, 0);
                opacity: 0.5;
            }
        }
        @keyframes soulBlastOverlayParticles {
            0% {
                transform: scale(1) translate3d(0, 0, 0);
                opacity: 0.45;
            }
            50% {
                transform: scale(1.05) translate3d(-1%, 1%, 0);
                opacity: 0.6;
            }
            100% {
                transform: scale(1) translate3d(1%, -1%, 0);
                opacity: 0.45;
            }
        }
        #energy-blast-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #0e1330;
            padding: 30px 40px;
            border: 2px solid #6a80ff;
            border-radius: 10px;
            z-index: 2003;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(122, 146, 255, 0.8);
        }
        #energy-blast-popup h1 {
            margin: 0;
            font-size: 48px;
            color: #8fd4ff;
            text-shadow: 0 0 15px rgba(143, 212, 255, 0.8);
            letter-spacing: 4px;
        }
        #energy-blast-popup p {
            margin: 15px 0 0 0;
            font-size: 20px;
            color: #c5e4ff;
        }
        #board.energy-blast-glow {
            border-color: #6a80ff !important;
            box-shadow: 0 0 20px #6a80ff;
            animation: energyBlastGlow 1.6s ease-in-out infinite !important;
        }
        #board.energy-blast-glow.soul-blast-glow {
            border-color: #c166ff !important;
            box-shadow: 0 0 24px rgba(193, 102, 255, 0.9), 0 0 36px rgba(115, 63, 255, 0.65);
            animation: soulBlastGlow 2s ease-in-out infinite !important;
        }
        @keyframes energyBlastGlow {
            0% {
                box-shadow: 0 0 10px #4b5dff;
            }
            50% {
                box-shadow: 0 0 32px #9fd6ff;
            }
            100% {
                box-shadow: 0 0 10px #4b5dff;
            }
        }
        body.soul-blast-slowmo #board.energy-blast-glow {
            animation-duration: 3.2s !important;
        }
        body.energy-blast-overlay.soul-blast-overlay.soul-blast-slowmo::after {
            animation-duration: 18s !important;
            opacity: 0.65;
        }
        body.soul-blast-slowmo .energy-blast-path::after,
        body.soul-blast-slowmo .energy-blast-residual::after {
            animation-duration: 2.1s !important;
        }
        body.soul-blast-overlay .energy-blast-path::after,
        body.soul-blast-overlay .energy-blast-residual::after {
            border-color: rgba(228, 149, 255, 0.95);
            box-shadow: 0 0 16px rgba(228, 149, 255, 0.95), 0 0 28px rgba(149, 92, 255, 0.5);
        }
        @keyframes soulBlastGlow {
            0% {
                box-shadow: 0 0 16px rgba(193, 102, 255, 0.8), 0 0 26px rgba(115, 63, 255, 0.55);
            }
            50% {
                box-shadow: 0 0 32px rgba(209, 148, 255, 0.95), 0 0 44px rgba(139, 71, 255, 0.8);
            }
            100% {
                box-shadow: 0 0 16px rgba(193, 102, 255, 0.8), 0 0 26px rgba(115, 63, 255, 0.55);
            }
        }
        /* Active warcry bonus background */
        .warcry-active-background {
            background: linear-gradient(135deg, #202020 0%, #3a2f1a 50%, #202020 100%) !important;
            animation: warcryActivePulse 3s ease-in-out infinite;
        }
        @keyframes warcryActivePulse {
            0%, 100% {
                background: linear-gradient(135deg, #202020 0%, #3a2f1a 50%, #202020 100%);
            }
            50% {
                background: linear-gradient(135deg, #202020 0%, #4a3f1a 50%, #202020 100%);
            }
        }
        /* Active warcry bonus border */
        #board.warcry-active-border {
            border-color: #d4af37 !important;
            box-shadow: 0 0 30px #d4af37;
            animation: warcryActiveBorderPulse 2s ease-in-out infinite;
        }
        @keyframes warcryActiveBorderPulse {
            0%, 100% {
                border-color: #d4af37;
                box-shadow: 0 0 20px #d4af37;
            }
            50% {
                border-color: #d4af37;
                box-shadow: 0 0 40px #d4af37;
            }
        }
        /* Game stats modal styles */
        #game-stats-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2004;
            max-width: 800px;
            min-width: 700px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
        }
        #game-stats-modal .modal-header {
            background-color: #333;
            color: #fff;
            padding: 15px 20px;
            margin: -20px -20px 20px -20px;
            border-radius: 8px 8px 0 0;
            text-align: center;
        }
        #game-stats-modal .modal-header span {
            font-size: 24px;
            font-weight: bold;
            display: block;
            text-align: center;
        }
        #game-stats-modal .modal-content {
            padding: 0;
            background-color: #fff;
            max-height: 70vh;
            overflow-y: auto;
        }
        #stats-victory-message {
            text-align: center;
            margin-bottom: 30px;
        }
        #stats-reason {
            font-size: 22px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        #stats-head-to-head {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 30px;
        }
        .stats-column {
            flex: 1;
            max-width: 300px;
        }
        .stats-column h3 {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin: 0 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #4CAF50;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin-bottom: 5px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        #stats-game-info {
            text-align: center;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }
        #stats-game-info p {
            margin: 8px 0;
            font-size: 15px;
            color: #666;
        }
        #game-stats-modal .modal-footer {
            display: inline-flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            width: 100%;
        }
        #game-stats-modal .modal-footer button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="landing-header">
        <h1>RATIX</h1>
        <p>Created by Craig Skobel</p>
        <button class="how-to-button" onclick="openHowToPlay()">How to Play</button>
    </div>
    <div id="start-menu">
        <h2>Select Game Variant</h2>
        <div class="variant-option">
            <button id="variant-btn-24s" data-ready="false" onclick="handleVariantClick('24s')">24's (Standard)</button>
            <div id="variant-info-24s" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: single Infantry front rank backing a classic Cavalry, Troll, Dragon, Wizard, Guard, Champion, and King battle line.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Beginner-friendly for learning RATIX fundamentals, yet still offers solid tactical depth for any player.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s" data-ready="false" onclick="handleVariantClick('36s')">36's (Advanced)</button>
            <div id="variant-info-36s" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: Infantry shield, Archer/Troll support row, and heavy back line with Ogres, Ballista units, royal pieces, and additional cavalry.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Ideal for intermediate players ready for layered formations and expanded special abilities.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-expert" data-ready="false" onclick="handleVariantClick('36s-expert')">36's (Expert)</button>
            <div id="variant-info-36s-expert" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: adds Mercenaries and Elephantry to the forward ranks on top of the Archer support line and elite back row for maximal piece variety.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Suited to veteran players comfortable juggling many unit types and long-term tactical planning.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-elite" data-ready="false" onclick="handleVariantClick('36s-elite')">36's (Elite)</button>
            <div id="variant-info-36s-elite" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout: mirrors the Expert ranks but unlocks Necromancers and relentless Zombie hordes for high-impact summoning play.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Designed for expert players ready to manage advanced summoning chains and relentless board pressure.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-36s-supreme" data-ready="false" onclick="handleVariantClick('36s-supreme')">36's (Supreme)</button>
            <div id="variant-info-36s-supreme" class="variant-info">
                <p class="variant-description">Board: 10x14. Layout mirrors the Elite formation but unlocks experimental spellcraft for Wizards and Necromancers plus Champion-summoned Huntsmen who dart across the board via coin-flip fueled bursts.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Intended for master tacticians who can leverage high-risk, high-reward magic.</p>
            </div>
        </div>
        <div class="variant-option">
            <button id="variant-btn-ccb" data-ready="false" onclick="handleVariantClick('ccb')">24's Close-Combat Battle</button>
            <div id="variant-info-ccb" class="variant-info">
                <p class="variant-description">Board: 8x12. Layout: no buffer columns, keeping Infantry and the elite Cavalry/Troll/Dragon/Wizard formation in immediate close-quarters contact.</p>
                <p class="variant-difficulty"><strong>Recommended skill:</strong> Best for aggressive intermediate-to-advanced players who enjoy fast tactical clashes.</p>
            </div>
        </div>
        
        <div id="player-setup">
            <label for="player-name-input">Player Name</label>
            <input id="player-name-input" type="text" maxlength="20" placeholder="Enter your hero name" />
        </div>
        <div id="high-score-panel">
            <h3>Local High Scores</h3>
            <ol id="high-score-list"></ol>
            <button id="clear-high-scores" type="button" onclick="clearHighScores()">Clear High Scores</button>
        </div>

        <div id="difficulty-selector">
            <h3>Select AI Difficulty</h3>
            <button id="diff-easy" onclick="setDifficulty('Easy', this)">Easy</button>
            <button id="diff-medium" onclick="setDifficulty('Medium', this)" class="selected-diff">Medium</button>
            <button id="diff-hard" onclick="setDifficulty('Hard', this)">Hard</button>
        </div>

        <div id="opponent-selector">
            <h3>Select Your Opponent</h3>
            <button id="opp-random" onclick="setOpponent('Random', this)" class="selected-opponent">Random</button>
            <button id="opp-berserker" onclick="setOpponent('Berserker', this)">Berserker</button>
            <button id="opp-guardian" onclick="setOpponent('Guardian', this)">Guardian</button>
            <button id="opp-tactician" onclick="setOpponent('Tactician', this)">Tactician</button>
            <button id="opp-sorcerer" onclick="setOpponent('Sorcerer', this)">Sorcerer</button>
            <button id="opp-nomad" onclick="setOpponent('Nomad', this)">Nomad</button>
        </div>

        <div id="hint-selector">
            <h3>Hint System</h3>
            <button id="hint-on" onclick="setHintMode('On', this)">On</button>
            <button id="hint-off" onclick="setHintMode('Off', this)" class="selected-hint">Off</button>
        </div>

        <div id="game-timer-selector">
            <h3>Select Game Timer</h3>
            <button id="game-timer-quick" onclick="setGameTimer('quick', this)">10 mins (Quick)</button>
            <button id="game-timer-standard" onclick="setGameTimer('standard', this)" class="selected-option">30 mins (Standard)</button>
            <button id="game-timer-long" onclick="setGameTimer('long', this)">60 mins (Long)</button>
        </div>
        <div id="turn-timer-selector">
            <h3>Select Round Timer</h3>
            <button id="turn-timer-blitz" onclick="setTurnTimer('blitz', this)">30 secs (Blitz)</button>
            <button id="turn-timer-standard" onclick="setTurnTimer('standard', this)" class="selected-option">60 secs (Standard)</button>
        </div>
    </div>
    <footer id="landing-footer">RATIX &copy; 2025 Skobel Games</footer>
    <div id="game-container">
        <div id="top-bar">
            <div id="top-buttons-left">
                <button class="how-to-button" onclick="openHowToPlay()">How to Play</button>
                <button id="RATIX-brand-button" type="button">RATIX</button>
                <button onclick="returnToMainMenu()">Main Menu</button>
            </div>
            <div id="top-buttons-right">
                <button onclick="resetGame()">Reset Game</button>
                <button class="toggle-button" id="game-log-toggle" onclick="toggleGameLog()">Game Log</button>
                <button class="toggle-button" id="graveyard-toggle" onclick="toggleGraveyard()">Graveyard</button>
            </div>
        </div>
        <div id="game-layout">
            <aside id="left-panel">
                <div class="player-panel" id="player-panel">
                <div id="player-reaction-emoji" class="reaction-emoji"></div>
                <div class="panel-content">
                <div class="player-name" id="player-name-label">Player</div>
                <div class="player-score" id="player-score-value">Score: 0</div>
                <div class="timer-row player" id="player-timer-row">Turn Time: 00:00</div>
                </div>
                </div>
                <div id="round-timer-box">
                    <div id="round-number-display">Round 1</div>
                    <div id="game-timer-row">Game Time: 00:00</div>
                </div>
            </aside>
            <div id="board-column">
                <div id="board"></div>
                <div id="controls">
            <button id="turn-button" onclick="openTurnModal(this)" style="display: none;">Turn Piece</button>
            <button id="turn-move-button" onclick="openTurnAndMoveModal(this)" style="display: none;">Turn and Move</button>
            <button id="turn-shoot-button" onclick="openTurnAndShootModal(this)" style="display: none;">Turn and Shoot</button>
            <button id="archer-move-diag-shoot-button" onclick="activateArcherMoveDiagShoot(this)" style="display: none;">Skirmish (Move+Diag Shot)</button>
            <button id="archer-diag2-shoot-button" onclick="activateArcherDiag2Shoot(this)" style="display: none;">Longshot Diagonal</button>
            <button id="guard-honour-button" onclick="activateGuardOfHonour(this)" style="display: none;">Guard of Honour</button>
            <button id="king-summon-pistolier-button" onclick="requestKingSummon('Pistolier')" style="display: none;">Summon Pistolier</button>
            <button id="king-summon-fusilier-button" onclick="requestKingSummon('Fusilier')" style="display: none;">Summon Fusilier</button>
            <button id="teleport-button" onclick="activateTeleport(this)" style="display: none;">Teleport</button>
            <button id="teleport-swap-button" onclick="activateTeleportSwap(this)" style="display: none;">Teleport Swap</button>
            <button id="charge-button" onclick="activateCharge(this)" style="display: none;">Charge</button>
            <button id="ogre-rage-button" onclick="activateOgreRage(this)" style="display: none;">Rage</button>
            <button id="inferno-button" onclick="activateInferno(this)" style="display: none;">Inferno</button>
            <button id="strafe-button" onclick="activateStrafe(this)" style="display: none;">Strafe</button>
            <button id="summon-spectre-button" onclick="activateSummonSpectre(this)" style="display: none;">Summon Spectre</button>
            <button id="energy-blast-button" onclick="activateEnergyBlast(this)" style="display: none;">Energy Blast</button>
            <button id="lich-soul-blast-button" onclick="activateLichSoulBlast(this)" style="display: none;">Soul Blast</button>
            <button id="sacrifice-button" onclick="activateSacrifice(this)" style="display: none;">Sacrifice</button>
            <button id="hint-button" onclick="showHint()" style="display: none;">Get Hint</button>
            <button id="end-turn-button" onclick="endTurn()" disabled>End Round</button>
                </div>
            </div>
            <aside id="right-panel">
                <div class="player-panel" id="ai-panel">
                <div id="ai-reaction-emoji" class="reaction-emoji"></div>
                <div class="panel-content ai-content">
                <div class="player-name" id="ai-name-label">Opponent</div>
                <div class="player-score" id="ai-score-value">Score: 0</div>
                <div class="timer-row ai" id="ai-timer-row">Turn Time: 00:00</div>
                </div>
                </div>
                <div id="status">Player's turn: 3 moves remaining</div>
                <div id="game-log"></div>
                <div id="info-box"></div>
                <div id="captured-pieces" aria-label="Graveyard">
                    <div class="graveyard-header">
                        <div class="graveyard-title">The Graveyard</div>
                        <div class="graveyard-subtitle">Where claimed souls linger until recalled</div>
                    </div>
                    <div class="graveyard-columns">
                        <div class="captured-column">
                            <h3>Player's Graveyard</h3>
                            <div id="player-captured" class="captured-grid"></div>
                        </div>
                        <div class="captured-column">
                            <h3>AI's Graveyard</h3>
                            <div id="ai-captured" class="captured-grid"></div>
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </div>
    <div id="modal-overlay"></div>
    <div id="reinforce-modal">
        <h3>Select Reinforcement Piece</h3>
        <select id="reinforce-select"></select>
        <button onclick="confirmReinforcement()">Confirm</button>
    </div>
    <div id="spell-direction-modal">
        <div class="modal-header"><span id="spell-direction-title">Select Direction</span><button class="modal-close" onclick="closeSpellDirectionModal()" aria-label="Close">&times;</button></div>
        <select id="spell-direction-select"></select>
        <button onclick="confirmSpellDirection()">Confirm</button>
    </div>
    <div id="protection-modal">
        <div class="modal-header"><span>Spell Protection</span><button class="modal-close" onclick="declineProtection()" aria-label="Close">&times;</button></div>
        <div class="modal-content">
            <p id="protection-message"></p>
            <select id="protection-select"></select>
        </div>
        <div class="modal-footer">
            <button onclick="confirmProtection()">Sacrifice</button>
            <button onclick="declineProtection()">Decline</button>
        </div>
    </div>
    <div id="turn-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnModal()" aria-label="Close">&times;</button></div>
        <select id="turn-select"></select>
                <button onclick="confirmTurn()">Confirm</button>
    </div>
    <div id="turn-move-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnMoveModal()" aria-label="Close">&times;</button></div>
        <select id="turn-move-select"></select>
        <button onclick="confirmTurnAndMove()">Confirm</button>
    </div>
    <div id="turn-shoot-modal">
        <div class="modal-header"><span>Select Facing Direction</span><button class="modal-close" onclick="closeTurnShootModal()" aria-label="Close">&times;</button></div>
        <select id="turn-shoot-select"></select>
        <button onclick="confirmTurnAndShoot()">Confirm</button>
    </div>
    <div id="how-to-play-modal">
        <div class="modal-header">
            <span>How to Play - RATIX</span>
            <button class="modal-close" onclick="closeHowToPlay()" aria-label="Close">&times;</button>
        </div>
        <div class="modal-content">
            <div id="rules-content"></div>
        </div>
        <div class="modal-footer">
            <button onclick="closeHowToPlay()">Resume Game</button>
        </div>
    </div>
    <div id="truce-modal">
        <div class="modal-header">
            <span>Truce Proposal</span>
        </div>
        <div class="modal-content">
            <p id="truce-message">Both players have 6 or fewer pieces remaining. Do you wish to agree to a truce and end the game in a draw?</p>
            <p id="truce-attempts"></p>
        </div>
        <div class="modal-footer">
            <button onclick="acceptTruce()" style="background-color: #4CAF50;">Accept Truce</button>
            <button onclick="declineTruce()" style="background-color: #f44336;">Decline</button>
        </div>
    </div>
    <div id="coin-toss-modal">
        <div class="modal-header">
            <span id="coin-toss-title">Coin Toss</span>
        </div>
        <div class="modal-content">
            <div id="coin-result" class="coin"></div>
            <p id="coin-toss-message"></p>
            <p id="coin-toss-description" style="font-size: 14px; margin-top: 10px;"></p>
        </div>
        <div class="modal-footer">
            <button id="coin-toss-start" onclick="startCoinToss()" style="display: none; background-color: #2196F3; visibility: hidden;">Flip Coin</button>
            <button id="coin-toss-continue" onclick="closeCoinToss()" style="display: none; background-color: #4CAF50; visibility: hidden;">Continue</button>
            <span id="coin-toss-progress" class="coin-progress">Successes: 0/0</span>
        </div>
    </div>

    <div id="dice-roll-modal">
        <div class="modal-header">
            <span id="dice-roll-title">Dice Roll</span>
        </div>
        <div class="modal-content">
            <p id="dice-roll-message" style="font-size: 18px; margin: 10px 0;"></p>
            <div class="dice-display">
                <div class="dice-face" id="dice-face-d10">
                    <span class="dice-label">d10</span>
                    <span class="dice-value" id="dice-d10-value">?</span>
                </div>
                <div class="dice-face" id="dice-face-d14">
                    <span class="dice-label">d14</span>
                    <span class="dice-value" id="dice-d14-value">?</span>
                </div>
            </div>
            <p id="dice-roll-description" style="font-size: 14px; margin-top: 8px;"></p>
            <p id="dice-roll-outcome" class="dice-outcome"></p>
        </div>
    </div>
    <div id="warcry-achievement-modal">
        <h1>WARCRY</h1>
        <p>Bonus Granted</p>
    </div>
    <div id="dark-void-modal">
        <h1>DARK VOID</h1>
        <p>The square is swallowed and never lets go.</p>
    </div>
    <div id="energy-blast-popup">
        <h1>ENERGY BLAST</h1>
        <p>Spell Unleashed</p>
    </div>
    <div id="coin-flip-popup">
        <h2 id="coin-flip-popup-title">Success</h2>
        <p id="coin-flip-popup-message"></p>
    </div>
    <div id="endgame-overlay"></div>
    <div id="game-stats-modal">
        <div class="modal-header">
            <span id="game-stats-title">Game Complete</span>
        </div>
        <div class="modal-content">
            <div id="game-stats-content">
                <div id="stats-victory-message">
                    <p id="stats-reason"></p>
                </div>
                <div id="stats-head-to-head">
                    <div id="stats-player-column" class="stats-column">
                        <h3 id="stats-player-name">Player</h3>
                        <div class="stat-item">
                            <span class="stat-label">Final Score</span>
                            <span id="stats-player-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Warcry Bonuses</span>
                            <span id="stats-player-warcry" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Despair Penalties</span>
                            <span id="stats-player-despair" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Most Captures (Round)</span>
                            <span id="stats-player-captures" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Highest Score (Round)</span>
                            <span id="stats-player-high-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Successful Summons</span>
                            <span id="stats-player-summons" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Reinforcements</span>
                            <span id="stats-player-reinforcements" class="stat-value"></span>
                        </div>
                    </div>
                    <div id="stats-ai-column" class="stats-column">
                        <h3 id="stats-ai-name">AI</h3>
                        <div class="stat-item">
                            <span class="stat-label">Final Score</span>
                            <span id="stats-ai-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Warcry Bonuses</span>
                            <span id="stats-ai-warcry" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Despair Penalties</span>
                            <span id="stats-ai-despair" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Most Captures (Round)</span>
                            <span id="stats-ai-captures" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Highest Score (Round)</span>
                            <span id="stats-ai-high-score" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Successful Summons</span>
                            <span id="stats-ai-summons" class="stat-value"></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Reinforcements</span>
                            <span id="stats-ai-reinforcements" class="stat-value"></span>
                        </div>
                    </div>
                </div>
                <div id="stats-game-info">
                    <p id="stats-turn-count"></p>
                    <p id="stats-duration"></p>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button id="game-stats-close" onclick="closeGameStats()" style="background-color: #4CAF50; color: white; padding: 12px 30px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer;">Return to Main Menu</button>
        </div>
    </div>

    <!-- Embedded move sound effect (realistic chess piece click) -->
    <audio id="move-sound" preload="auto">
        <source src="assets/audio/move-sound.wav" type="audio/wav">
    </audio>

    <script>
        let ROWS = 10;
        let COLS = 12;
        let gameVariant = '24s';
        let isFirstPlayerTurn = true;
        let lastAction = null;
        let turnAndMoveMode = false;
        let turnAndShootMode = false;
        let archerMoveDiagMode = false;
        let archerDiagShootSelectMode = false;
        let archerMoveDiagStart = null;
        let archerDiag2ShootMode = false;
        let guardOfHonourMode = false;
        let teleportMode = false;
        let teleportSwapMode = false;
        let chargeMode = false;
        let ogreRageMode = false; // New state for Ogre Rage
        let infernoMode = false; // New state for Dragon's Inferno
        let strafeMode = false; // New state for Wizard/Dragon Strafe
        let summonSpectreMode = false; // New state for Wizard Spectre summoning
        let elephantryChargeMode = false; // New state for Elephantry Charge
        let voidBlastMode = false; // New state for Undead Champion Void Blast
        let elephantryExtendedRangeActive = false; // Active when player is in extended range shooting mode
        let elephantryMoveShootMode = false; // Active when Elephantry has moved and needs to select shoot target
        let elephantryMoveShootPosition = null; // Store the position Elephantry moved to
        let elephantryTripleShotFlipResults = [];
        let elephantryTripleShotNextShot = 0;
        let elephantryTripleShotAwaitingTargets = false;
        let elephantryTripleShotPieceKey = null;
        let pistolierMoveShootMode = false; // Active when Pistolier has moved and needs to select shoot target
        let pistolierMoveShootPosition = null; // Store the position Pistolier moved to
        let fusilierCrackShotActive = null; // Holds Fusilier piece currently empowered by Crack Shot
        let fusilierStrafeActive = false; // Active when Fusilier is selecting strafe move
        let huntsmenSummoned = { 'W': 0, 'B': 0 }; // Track Huntsman summons per player
        let huntsmenOnBoard = { 'W': 0, 'B': 0 }; // Track active Huntsmen
        let huntsmanBurstMode = null; // Active when Huntsman is selecting burst destination
        let pendingHuntsmanBurst = null; // Tracks ongoing Huntsman flip sequence
        let huntsmanBurstPauseState = null; // Preserve timers while burst flips resolve
        let championSummonMode = null; // Champion summon targeting state
        let necromancerSummonMode = null; // Necromancer summon targeting state
        let kingShotMode = null; // King shot targeting mode
        let kingEvadeMode = null; // King evade destination selection
        let kingSummonMode = null; // King summon placement selection { unitType, emptySquares }
        let pendingLichSoulBlast = null; // Tracks pending Soul Blast coin flip
        let lichSoulBlastMode = null; // Soul Blast targeting context
        let lichSoulBlastResolving = false; // Prevent inputs while blast resolves
        let lichSoulBlastPendingCompletion = false; // True once a target must be captured
        let lichSoulBlastTargetInfo = null; // Stores info about the current blast target
        let soulBlastPreviewSquares = new Set(); // Squares highlighted while aiming Soul Blast
        let soulBlastPauseState = null; // Preserve timer state during Soul Blast resolution
        let coinTossSoulBlastHold = false; // Keep game paused while Soul Blast coin flip is pending
        let darkVoidMode = null; // Active when selecting Dark Void target
        let darkVoidPopupTimeout = null; // Controls Dark Void popup timing
        let darkVoidUses = { 'W': 0, 'B': 0 }; // Track Dark Void uses per player
        let darkVoidSquares = new Set(); // Track squares occupied by Dark Void
        const blockingActionCounters = {
            coinFlip: 0,
            zombieFlip: 0,
            barrage: 0,
            energyBlast: 0,
            elephantryTripleShot: 0
        };
        let barragePauseState = null;

        function freezeGameForBarrage() {
            if (barragePauseState) return;
            const turnPlayer = currentTurnTimerPlayer;
            barragePauseState = {
                wasGamePaused: gamePaused,
                gameTimerRunning: !!gameTimerInterval,
                turnTimerRunning: !!turnTimerInterval,
                turnPlayer
            };
            if (gameTimerInterval) {
                stopGameTimer();
            }
            if (turnTimerInterval) {
                stopTurnTimer();
            }
            if (!gamePaused) {
                gamePaused = true;
            }
        }

        function resumeGameAfterBarrage() {
            if (!barragePauseState) return;
            const { wasGamePaused, gameTimerRunning, turnTimerRunning, turnPlayer } = barragePauseState;
            barragePauseState = null;
            if (!wasGamePaused) {
                gamePaused = false;
            }
            if (gameTimerRunning && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (turnTimerRunning && turnPlayer) {
                if (turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
        }

        function beginBlockingAction(type) {
            if (!blockingActionCounters.hasOwnProperty(type)) return;
            blockingActionCounters[type]++;
            if (type === 'barrage' && blockingActionCounters[type] === 1) {
                freezeGameForBarrage();
            }
        }

        function endBlockingAction(type) {
            if (!blockingActionCounters.hasOwnProperty(type)) return;
            blockingActionCounters[type] = Math.max(0, blockingActionCounters[type] - 1);
            if (type === 'barrage' && blockingActionCounters[type] === 0) {
                resumeGameAfterBarrage();
            }
        }

        function isBlockingActionPending() {
            return Object.values(blockingActionCounters).some(count => count > 0);
        }
        let moralBoostUses = { 'W': 0, 'B': 0 }; // Track Moral Boost activations
        let moralBoostSuccesses = { 'W': 0, 'B': 0 }; // Track successful Moral Boosts
        let barrageUses = { 'W': 0, 'B': 0 };
        function canUseBarrage(player) {
            if (!player) return false;
            return (barrageUses[player] || 0) < BARRAGE_USE_LIMIT;
        }

        function registerBarrageUse(player) {
            if (!player) return;
            barrageUses[player] = (barrageUses[player] || 0) + 1;
        }
        let kingShotUsed = { 'W': false, 'B': false }; // Track King Shot usage
        let kingEvadeUsed = { 'W': false, 'B': false }; // Track King Evade usage
        let initialMovesLeft = 3;
        let baseMovesThisTurn = 3; // Track base moves without bonus (to know when bonus moves are spent)
        let aiPending = false; // Prevent duplicate AI scheduling
        let gamePaused = false; // Track if game is paused
        let gameOver = false; // Track if game has ended
        let pausedTimers = { game: null, turn: null, turnPlayer: null }; // Store timer states when paused
        let playerDisplayName = 'Player';
        const PLAYER_NAME_STORAGE_KEY = 'belicusLastPlayerName';
        const HIGH_SCORE_STORAGE_KEY = 'belicusLocalHighScores';
        const MAX_HIGH_SCORE_ENTRIES = 10;
        const MAX_PLAYER_NAME_LENGTH = 20;
        let localHighScores = [];

        const ENERGY_BLAST_FLIP_COUNT = 4;
        const ENERGY_BLAST_RESIDUAL_DURATION = 6; // 3 full rounds (both players' turns)
        const ENERGY_BLAST_STEP_PROBABILITIES = [0, 0.9375, 0.6875, 0.3125, 0.0625];
        const ENERGY_BLAST_AI_THRESHOLD = 2; // Lowered from 6 to 2 to encourage more usage
        const SACRIFICE_SUCCESS_PROBABILITY = 0.5;
        const SACRIFICE_AI_THRESHOLD = 2; // Lowered from 6 to 2 to encourage more usage
        const HUNTSMAN_MAX_ACTIVE = 2;
        const HUNTSMAN_SUMMON_LIMIT = 6;
        const HUNTSMAN_BURST_FLIP_COUNT = 4;
        const HUNTSMAN_BURST_SUCCESS_PROBS = [1, 0.9375, 0.6875, 0.3125, 0.0625];
        const HUNTSMAN_BURST_AI_THRESHOLD = 3.5;
        const KING_SUMMON_AI_THRESHOLD = 1;
        const MORAL_BOOST_SUCCESS_LIMIT = 3;
        const MORAL_BOOST_BONUS = 2;
        const BARRAGE_TARGET_COUNT = 6;
        const BARRAGE_COST = 2;
        const BARRAGE_REQUIRED_MORAL_BOOSTS = MORAL_BOOST_SUCCESS_LIMIT;
        const BARRAGE_USE_LIMIT = 2;
        const VARIANT_LABELS = {
            '24s': "24's (Standard)",
            '36s': "36's (Advanced)",
            '36s-expert': "36's (Expert)",
            '36s-elite': "36's (Elite)",
            '36s-supreme': "36's (Supreme)",
            'ccb': "24's Close-Combat Battle"
        };
        const VARIANT_KEYS = Object.keys(VARIANT_LABELS);

        // Provide a consistent coordinate formatter that maps the horizontal axis (left-to-right)
        // to row labels (1 through COLS) and the vertical axis (top-to-bottom) to column labels (1 through ROWS).
        function getBoardGridRow(rowIndex, colIndex) {
            return colIndex + 1;
        }

        function getBoardGridCol(rowIndex, colIndex) {
            return rowIndex + 1;
        }

        function formatBoardCoordinates(rowIndex, colIndex) {
            const gridRow = getBoardGridRow(rowIndex, colIndex);
            const gridCol = getBoardGridCol(rowIndex, colIndex);
            return '(' + gridRow + ',' + gridCol + ')';
        }

        const FACING_VECTORS = {
            'U': [-1, 0],
            'D': [1, 0],
            'L': [0, -1],
            'R': [0, 1]
        };
        const ELEPHANTRY_TRIPLE_SHOT_DIRECTIONS = {
            'U': [[-1, 0], [-1, -1], [-1, 1]],
            'D': [[1, 0], [1, -1], [1, 1]],
            'L': [[0, -1], [-1, -1], [1, -1]],
            'R': [[0, 1], [-1, 1], [1, 1]]
        };
        function getElephantryTripleShotDirections(facing) {
            return ELEPHANTRY_TRIPLE_SHOT_DIRECTIONS[facing] || ELEPHANTRY_TRIPLE_SHOT_DIRECTIONS['U'];
        }

        function filterInfantryForwardMoves(moves, facing, fromRow, fromCol) {
            if (!facing || !FACING_VECTORS[facing]) {
                return [];
            }
            const vector = FACING_VECTORS[facing];
            return moves.filter(move => {
                if (!move.pos) return false;
                if (move.special === 'infantryStrafe') return false;
                const dr = move.pos[0] - fromRow;
                const dc = move.pos[1] - fromCol;
                return (dr * vector[0] + dc * vector[1]) > 0;
            });
        }

        function resetVariantSelections() {
            VARIANT_KEYS.forEach(variant => {
                const button = document.getElementById(`variant-btn-${variant}`);
                if (button) {
                    button.classList.remove('selected-variant');
                    button.textContent = VARIANT_LABELS[variant];
                    button.dataset.ready = 'false';
                }
                const info = document.getElementById(`variant-info-${variant}`);
                if (info) {
                    info.classList.remove('visible');
                }
            });
        }

        function setActiveControlButton(button) {
            if (!button) return;
            if (activeControlButton && activeControlButton !== button) {
                activeControlButton.classList.remove('control-button-active');
            }
            activeControlButton = button;
            button.classList.add('control-button-active');
        }

        function setActiveControlButtonById(id) {
            const button = document.getElementById(id);
            if (button) {
                setActiveControlButton(button);
            }
            return button;
        }

        function clearActiveControlButton(button = null) {
            const target = button || activeControlButton;
            if (!target) return;
            target.classList.remove('control-button-active');
            if (!button || target === activeControlButton) {
                activeControlButton = null;
            }
        }

        function updateMoralBoostButtonLabel(player) {
            const button = document.getElementById('moral-boost-button');
            if (!button) return;
            const successes = Math.min(moralBoostSuccesses[player] || 0, MORAL_BOOST_SUCCESS_LIMIT);
            button.textContent = `Moral Boost (${successes}/${MORAL_BOOST_SUCCESS_LIMIT})`;
        }

        function setMercenaryHighlight(position) {
            if (position) {
                mercenaryBonusHighlight = { row: position.row, col: position.col };
            } else {
                mercenaryBonusHighlight = null;
            }
        }

        function deactivateMercenaryBonusTurn() {
            mercenaryBonusTurnActive = false;
            mercenaryBonusTurnPiece = null;
            setMercenaryHighlight(null);
        }

        function handleVariantClick(variant) {
            const button = document.getElementById(`variant-btn-${variant}`);
            const info = document.getElementById(`variant-info-${variant}`);
            if (!button || !info) return;

            if (button.dataset.ready === 'true') {
                startGame(variant);
                return;
            }

            resetVariantSelections();
            info.classList.add('visible');
            button.classList.add('selected-variant');
            button.dataset.ready = 'true';
            button.textContent = 'Start Game';
        }

        // Truce/Draw system
        let truceAttempts = 0;
        let truceMaxAttempts = 3;
        let truceDeclinedTurns = 0;
        let truceEligible = true;
        let trucePlayerVote = null; // null, 'accept', 'decline'
        let truceAIVote = null;

        function returnToMainMenu() {
            if (confirm('Return to main menu? Current game will be lost.')) {
                // Stop all timers and intervals
                stopGameTimer();
                stopTurnTimer();
                if (window.aiTurnWatch) {
                    clearInterval(window.aiTurnWatch);
                    window.aiTurnWatch = null;
                }

                // Clear zombie advance timer if active
                if (zombieAdvanceTimer) {
                    clearTimeout(zombieAdvanceTimer);
                    zombieAdvanceTimer = null;
                }

                // Reset all game state variables
                currentPlayer = 'W';
                roundCount = 1;
                playerRoundNumber = 0;
                aiRoundNumber = 0;
                gameRound = 1;
                firstPlayer = null;
                selectedPiece = null;
                validMoves = [];
                movedPieces.clear();
                reinforcementPending = null;
                aiPending = false;
                aiTurnTimeoutForced = false;
                movesLeft = 0;
                initialMovesLeft = 0;
                capturedPieces = { 'W': [], 'B': [] };
                wizardSacrificedByPlayer = { 'W': false, 'B': false };
                scores = { 'W': 0, 'B': 0 };
                gameLog = [];
                lastAction = null;
                zombieAutoAdvanceInProgress = false;
                clearZombieCoinAnimations();
                clearDiceRollAnimations();

                // Reset game pause state
                gamePaused = false;

                // Reset mercenary bonus turn state
                deactivateMercenaryBonusTurn();
                mercenaryBonusTurnUsed = { 'W': new Set(), 'B': new Set() };
                mercenaryBonusTurnCount = { 'W': 0, 'B': 0 };

                // Close any open modals and clear pending special modes
                cancelSpecialModes();
                const reinforceModal = document.getElementById('reinforce-modal');
                if (reinforceModal) reinforceModal.style.display = 'none';

                // Show main menu
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('start-menu').style.display = 'flex';
                document.body.classList.remove('game-loaded');
                const landingHeader = document.getElementById('landing-header');
                if (landingHeader) landingHeader.style.display = 'block';
                const landingFooter = document.getElementById('landing-footer');
                if (landingFooter) landingFooter.style.display = 'block';
                resetVariantSelections();
            }
        }

        function openHowToPlay() {
            gamePaused = true;
            // Pause timers - save state BEFORE stopping
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer; // Save which player's timer was running
            stopGameTimer();
            stopTurnTimer();

            // Generate and display rules content
            generateRulesContent();
            const overlay = document.getElementById('modal-overlay');
            if (overlay) overlay.style.display = 'block';
            document.getElementById('how-to-play-modal').style.display = 'block';
        }

        function closeHowToPlay() {
            document.getElementById('how-to-play-modal').style.display = 'none';
            const overlay = document.getElementById('modal-overlay');
            if (overlay) overlay.style.display = 'none';
            gamePaused = false;

            // Resume timers if they were running
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
        }

        function toggleGameLog() {
            const gameLog = document.getElementById('game-log');
            const gameLogToggle = document.getElementById('game-log-toggle');
            const graveyard = document.getElementById('captured-pieces');
            const graveyardToggle = document.getElementById('graveyard-toggle');

            // If game log is already expanded, collapse it
            if (gameLog.classList.contains('expanded')) {
                gameLog.classList.remove('expanded');
                gameLogToggle.classList.remove('active');
            } else {
                // Expand game log
                gameLog.classList.add('expanded');
                gameLogToggle.classList.add('active');

                // Collapse graveyard if it's open (only one can be open at a time)
                if (graveyard.classList.contains('expanded')) {
                    graveyard.classList.remove('expanded');
                    graveyardToggle.classList.remove('active');
                }
            }
        }

        function toggleGraveyard() {
            const gameLog = document.getElementById('game-log');
            const gameLogToggle = document.getElementById('game-log-toggle');
            const graveyard = document.getElementById('captured-pieces');
            const graveyardToggle = document.getElementById('graveyard-toggle');

            // If graveyard is already expanded, collapse it
            if (graveyard.classList.contains('expanded')) {
                graveyard.classList.remove('expanded');
                graveyardToggle.classList.remove('active');
            } else {
                // Expand graveyard
                graveyard.classList.add('expanded');
                graveyardToggle.classList.add('active');

                // Collapse game log if it's open (only one can be open at a time)
                if (gameLog.classList.contains('expanded')) {
                    gameLog.classList.remove('expanded');
                    gameLogToggle.classList.remove('active');
                }
            }
        }

        function generateRulesContent() {
            const rulesDiv = document.getElementById('rules-content');

            let html = `
                <h2>Game Overview</h2>
                <p><strong>RATIX</strong> is a strategic chess-like war game where you command an army against an AI opponent. Victory comes through capturing the enemy King or achieving alternate win conditions. Each game features tactical depth with special abilities, summoning mechanics, and strategic resource management.</p>

                <h2>Game Variants</h2>
                <ul>
                    <li><strong>24's (Standard):</strong> 1014 board, 24 pieces per side. Perfect for learning the fundamentals with Infantry, Cavalry, Trolls, Dragons, Wizards, Guards, a Champion, and King.</li>
                    <li><strong>36's (Advanced):</strong> 1014 board, 36 pieces per side. Adds Archers, Ballistas, and Ogres for expanded tactical options.</li>
                    <li><strong>36's (Expert):</strong> 1014 board, 36 pieces per side. Includes all Advanced pieces plus Mercenaries and Elephantry with powerful special abilities.</li>
                    <li><strong>36's (Elite):</strong> 1014 board, 36 pieces per side. Adds Necromancers, Liches, and Zombies enabling advanced summoning strategies and dark magic.</li>
                    <li><strong>36's (Supreme):</strong> 1014 board with the Elite roster. Unlocks experimental spellcraft including Energy Blast, Sacrifice spells, and Champion-summoned Huntsmen.</li>
                    <li><strong>24's Close-Combat Battle:</strong> Compact 812 board for fast-paced aggressive gameplay with immediate piece-to-piece contact.</li>
                </ul>

                <h2>Victory Conditions</h2>
                <ul>
                    <li><strong>Regicide:</strong> Capture the enemy King for instant victory (most common).</li>
                    <li><strong>Supremacy:</strong> Capture the enemy Champion, reduce their score to 1 point, and move your King or Champion to their back row.</li>
                    <li><strong>Relentless:</strong> Activate 3 reinforcements using Infantry while your opponent has zero reinforcements available.</li>
                    <li><strong>Score Victory:</strong> Have the highest score when the game timer expires.</li>
                </ul>

                <h2>Draw Conditions</h2>
                <ul>
                    <li><strong>Truce:</strong> When both players have 6 or fewer pieces remaining, either player can propose a truce. Both must agree to end in a draw. If declined, the truce can be re-proposed for up to 3 attempts across subsequent rounds. After 3 declined attempts, truce is no longer available.</li>
                    <li><strong>Match:</strong> When both players only have their King remaining, the game automatically ends in a draw.</li>
                </ul>

                <h2>Basic Gameplay</h2>
                <h3>Move Points System</h3>
                <ul>
                    <li>You start each round with <strong>3 move points</strong> (reduced to 2 if your Champion is captured).</li>
                    <li>Basic moves cost 1 point, special abilities cost 1-3 points depending on power.</li>
                    <li>Plan your actions carefullyonce you spend your points, your turn ends.</li>
                </ul>

                <h3>Bonus Moves & Penalties</h3>
                <ul>
                    <li><strong>Warcry:</strong> Score 10+ points in a single round to gain +2 bonus moves next round. The board glows gold when active.</li>
                    <li><strong>Despair:</strong> Lose 2 or more non-Infantry pieces in a round to suffer -2 moves next round. Poor planning has consequences!</li>
                    <li><strong>Champion Pressure:</strong> If your Champion reaches the enemy's back row, your opponent loses 1 move point each round while it remains there.</li>
                </ul>

                <h3>Reinforcements</h3>
                <p>When your Infantry, Champion, or King reaches the opponent's back row <strong>without capturing a piece</strong>, you earn a reinforcement. Choose one previously captured piece from your graveyard to return to the board on that square.</p>
                <ul>
                    <li>Infantry reinforcements: Return any captured piece.</li>
                    <li>Champion/King reinforcements: In Expert+ variants, you can select Ballistas, Elephantry, or Mercenaries for immediate tactical pressure.</li>
                    <li>Strategic tip: Reinforcements can swing the gameprotect pieces making the journey to the back row!</li>
                </ul>

                <h2>Special Abilities by Piece</h2>
                <h3>Royal Pieces</h3>
                <ul>
                    <li><strong>King - Guard of Honour:</strong> Swap positions with an adjacent Guard (costs 2 points, usable once per game). Use this to escape danger or reposition defensively.</li>
                    <li><strong>Champion:</strong> Can summon Pistoliers or Fusiliers (costs 2 points). Also enables Barrage ability when you have Moral Boost.</li>
                </ul>

                <h3>Magic Units</h3>
                <ul>
                    <li><strong>Wizard - Teleport:</strong> Instantly move to any empty square of the same color (costs 2 points, usable twice per game).</li>
                    <li><strong>Wizard - Teleport Swap:</strong> Swap positions with an enemy Wizard on the same color square (costs 2 points, usable once per game).</li>
                    <li><strong>Necromancer:</strong> Can summon Zombies and Spectres near Dark Void tiles (costs 2 points, requires coin flip). Can also create Dark Void squares (costs 2 points).</li>
                    <li><strong>Lich:</strong> Requires souls from captures to unlock abilities. Can use Soulstride (2-square leap) after 2 captures and Soul Blast (ranged attack) with increasing range per 3 souls collected. Immune to most magical attacksrequires Wizards, Necromancers, or Spectres to capture.</li>
                </ul>

                <h3>Heavy Assault</h3>
                <ul>
                    <li><strong>Cavalry - Charge:</strong> Move unlimited squares in one straight direction (costs 2 points, usable once per game). Great for surprise attacks or escaping.</li>
                    <li><strong>Dragon - Inferno:</strong> Move 1 square and capture all adjacent enemies in a devastating area attack (costs 2 points, usable once per game).</li>
                    <li><strong>Dragon - Strafe:</strong> Move then attack diagonally (usable twice per game).</li>
                    <li><strong>Ogre - Rage:</strong> Rush 2 squares straight (horizontal or vertical) and capture every enemy in a 23 corridor along the path (costs 2 points, usable once per game).</li>
                    <li><strong>Elephantry - Charge:</strong> One-time 3-square charge that captures all enemies along the path (devastating when lanes are clear).</li>
                    <li><strong>Elephantry - Triple Shot:</strong> Fire three coin-flip attacks at 2-square range without moving (costs 2 points).</li>
                    <li><strong>Elephantry - Move+Shoot:</strong> Move then shoot in one action (costs 2 points).</li>
                </ul>

                <h3>Ranged & Skirmish Units</h3>
                <ul>
                    <li><strong>Archer - Skirmish:</strong> Move then shoot diagonally 1 square (costs 2 points, usable twice per game).</li>
                    <li><strong>Archer - Longshot Diagonal:</strong> Shoot diagonally 2 squares (costs 2 points, usable twice per game).</li>
                    <li><strong>Ballista - Extend Range:</strong> Gain +1 shooting range for the current round (costs 2 points, usable once per round).</li>
                    <li><strong>Ballista - Double Time:</strong> Move 2 squares in one direction (costs 2 points, usable twice per game).</li>
                    <li><strong>Pistolier:</strong> Can move then shoot diagonally in one action.</li>
                    <li><strong>Fusilier - Crack Shot:</strong> Fire three coin-flip shots (costs 2 points). Also has Strafe repositioning ability.</li>
                </ul>

                <h3>Elite Units</h3>
                <ul>
                    <li><strong>Mercenary - Bonus Turn:</strong> After a successful capture, flip a coin. If you win, continue moving with this piece and ignore move point costs for the rest of the round (usable once per round). High risk, high reward!</li>
                    <li><strong>Huntsman (Supreme only):</strong> Champions can summon Huntsmen (max 2 active, 6 total per game). Huntsmen move 1 square normally or spend 2 points for Burstflip four coins to chain up to 4 movement steps. Opponents need coin flips to capture Huntsmen, but Huntsmen auto-capture Zombies.</li>
                </ul>

                <h2>Advanced Mechanics</h2>
                <h3>Dark Void (Elite & Supreme)</h3>
                <p>Necromancers and Liches can create <strong>Dark Void</strong> squares (costs 2 points). These cursed tiles remove any piece on that square and create a dangerous zone:</p>
                <ul>
                    <li>All captures or attacks adjacent to Dark Void require a coin flip to succeed.</li>
                    <li>Failed captures near Dark Void root the attacker in place.</li>
                    <li>Necromancers can summon Zombies, Spectres, or other undead adjacent to Dark Void tiles.</li>
                    <li>Lich summoning may spawn additional Dark Void squares as the darkness spreads.</li>
                </ul>

                <h3>Barrage (All Variants)</h3>
                <p>When you earn a <strong>Moral Boost</strong> (by winning multiple coin flips or achieving specific thresholds), your Champion or King can unleash Barrage (costs 2 points, requires Champion alive).</p>
                <ul>
                    <li>Targets six random squares across the board.</li>
                    <li>Each square is resolved with an independent coin flipsuccess captures the piece.</li>
                    <li><strong>Warning:</strong> Barrage can hit your own pieces! Use carefully.</li>
                    <li>AI opponents can also use Barrage when they earn Moral Boosts.</li>
                </ul>

                <h3>Supreme Spellcraft (Supreme Variant Only)</h3>
                <p>The Supreme variant unlocks experimental magic:</p>
                <ul>
                    <li><strong>Energy Blast:</strong> Wizards and Necromancers first succeed on a spellcasting coin flip (costs 2 move points even if failed), then flip four coins to determine blast distance (1 square per success). The blast travels straight or diagonally toward the opponent's side, vaporizing all enemies in its path while ignoring friendlies. First use costs 2 points, second costs 3.</li>
                    <li><strong>Sacrifice Spell:</strong> Once per game, a Wizard or Necromancer can spend 3 move points and win a coin flip to remove themselves from play, detonating a blast reaching 2 squares orthogonally and 1 square diagonally. Only available if the coin flip succeeds.</li>
                    <li><strong>Protection:</strong> When a spell would capture your King, you may (once per game) sacrifice a Wizard, Necromancer, or Champion to negate the capture. This also deducts 2 move points from the start of your next round.</li>
                </ul>

                <h2>Piece Information</h2>
            `;

            // Add piece information
            for (let [pieceName, info] of Object.entries(pieceInfo)) {
                // Format the info.extra to make "Special Moves:" or "Special Move:" bold
                let formattedExtra = info.extra.replace(/Special Moves?:/g, '<strong>$&</strong>');

                html += `
                    <div class="piece-info">
                        <div class="piece-name">${pieceName}</div>
                        <div><strong>Movement:</strong> ${info.points}</div>
                        <div><strong>Important:</strong> ${formattedExtra}</div>
                    </div>
                `;
            }

            html += `
                <h2>Piece Point Values</h2>
                <p>When you capture an enemy piece, you gain points based on the piece's value:</p>
                <ul>
                    <li><strong>Archer:</strong> 2 points</li>
                    <li><strong>Ballista:</strong> 5 points</li>
                    <li><strong>Cavalry:</strong> 3 points</li>
                    <li><strong>Champion:</strong> 12 points</li>
                    <li><strong>Dragon:</strong> 7 points</li>
                    <li><strong>Elephantry:</strong> 11 points</li>
                    <li><strong>Fusilier:</strong> 4 points</li>
                    <li><strong>Guard:</strong> 4 points</li>
                    <li><strong>Huntsman:</strong> 6 points</li>
                    <li><strong>Infantry:</strong> 1 point</li>
                    <li><strong>King:</strong> 13 points</li>
                    <li><strong>Lich:</strong> 11 points</li>
                    <li><strong>Mercenary:</strong> 3 points</li>
                    <li><strong>Necromancer:</strong> 10 points</li>
                    <li><strong>Ogre:</strong> 8 points</li>
                    <li><strong>Pistolier:</strong> 3 points</li>
                    <li><strong>Spectre:</strong> 5 points</li>
                    <li><strong>Troll:</strong> 6 points</li>
                    <li><strong>Undead:</strong> 4 points</li>
                    <li><strong>Wizard:</strong> 9 points</li>
                    <li><strong>Zombie:</strong> 3 points</li>
                </ul>

                <h2>Strategy Tips</h2>
                <ul>
                    <li><strong>Protect Your Royals:</strong> Losing your King ends the game. Losing your Champion reduces your move points to 2 per round and disables Barrageprotect them at all costs!</li>
                    <li><strong>Plan Your Move Points:</strong> With only 3 points per round, every action matters. Think aheadcan you afford that special ability or should you save points for critical captures?</li>
                    <li><strong>Save Special Abilities:</strong> Most special abilities can only be used once or twice per game. Don't waste them on low-value targetssave them for game-changing moments.</li>
                    <li><strong>Mind the Timers:</strong> Both game and round timers are ticking. Running out of time forfeits your turn or can lead to time-based defeat. Stay focused!</li>
                    <li><strong>Control the Back Row:</strong> Getting Infantry, Champions, or your King to the enemy back row without capturing earns reinforcements. Plan safe paths to resurrect your fallen pieces.</li>
                    <li><strong>Value High-Point Targets:</strong> Prioritize capturing high-value pieces like Wizards (9), Necromancers (10), Mercenaries (10), Elephantry (11), and Champions (12) to boost your score.</li>
                    <li><strong>Pursue Warcry Bonuses:</strong> Scoring 10+ points in one round grants +2 moves next round. Chain captures for explosive turns!</li>
                    <li><strong>Avoid Despair:</strong> Losing 2+ non-Infantry pieces in a round costs you 2 moves next round. Play defensively when exposed.</li>
                    <li><strong>Use Coin Flips Wisely:</strong> Many advanced abilities require coin flips. Don't gamble important pieces unless you can afford to lose the flip.</li>
                    <li><strong>Study Your Opponent:</strong> Different AI personalities (Berserker, Guardian, Tactician, Sorcerer, Nomad) play differently. Adapt your strategy!</li>
                    <li><strong>Dark Void Dangers:</strong> In Elite/Supreme variants, avoid clustering near Dark Void tilesall captures adjacent to them require coin flips.</li>
                    <li><strong>Friendly Fire Warning:</strong> Barrage, Dragon Inferno, and some spell effects can hit your own pieces. Position carefully before unleashing area attacks!</li>
                </ul>
            `;

            rulesDiv.innerHTML = html;
        }

        function countPieces(player) {
            let count = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].player === player) {
                        count++;
                    }
                }
            }
            return count;
        }

        function checkForMatch() {
            const playerPieces = countPieces('W');
            const aiPieces = countPieces('B');

            // Check if both players only have their King left
            if (playerPieces === 1 && aiPieces === 1) {
                let playerHasOnlyKing = false;
                let aiHasOnlyKing = false;

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c]) {
                            if (board[r][c].player === 'W' && board[r][c].type === 'King') {
                                playerHasOnlyKing = true;
                            }
                            if (board[r][c].player === 'B' && board[r][c].type === 'King') {
                                aiHasOnlyKing = true;
                            }
                        }
                    }
                }

                if (playerHasOnlyKing && aiHasOnlyKing) {
                    gameLog.push('Match: Both players only have their King remaining. Game ends in a draw.');
                    updateGameLog();
                    endGame('draw', 'Match');
                    return true;
                }
            }
            return false;
        }

        function checkForTruce() {
            if (!truceEligible || truceAttempts >= truceMaxAttempts) return;

            const playerPieces = countPieces('W');
            const aiPieces = countPieces('B');

            // Check if both players have 6 or fewer pieces
            if (playerPieces <= 6 && aiPieces <= 6) {
                // Only show truce modal at the start of player's turn after a decline
                if (truceDeclinedTurns > 0 && truceDeclinedTurns <= 3) {
                    proposeTruce();
                } else if (truceDeclinedTurns === 0) {
                    // First time checking - propose immediately
                    proposeTruce();
                }
            }
        }

        function proposeTruce() {
            gamePaused = true;
            stopGameTimer();
            stopTurnTimer();

            truceAttempts++;
            const attemptsRemaining = truceMaxAttempts - truceAttempts;

            document.getElementById('truce-attempts').textContent =
                `Attempt ${truceAttempts} of ${truceMaxAttempts}. ${attemptsRemaining} attempts remaining.`;

            // Calculate AI decision based on piece point values
            const aiPieces = countPieces('B');
            const playerPieces = countPieces('W');

            // Calculate total piece values for both players
            let aiTotalValue = 0;
            let playerTotalValue = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        const value = pieceValues[piece.type] || 0;
                        if (piece.player === 'B') {
                            aiTotalValue += value;
                        } else if (piece.player === 'W') {
                            playerTotalValue += value;
                        }
                    }
                }
            }

            // AI decision logic:
            // Base 50% chance, then adjusted by piece value difference
            // If AI has lower total value, more likely to accept
            // If AI has higher total value, less likely to accept
            const valueDifference = aiTotalValue - playerTotalValue;
            let acceptanceChance = 0.5; // Base 50% chance

            // Adjust based on value difference (normalized by typical piece value)
            acceptanceChance -= valueDifference / 50; // Adjust by ~2% per point difference

            // Clamp between 10% and 90%
            acceptanceChance = Math.max(0.1, Math.min(0.9, acceptanceChance));

            truceAIVote = (Math.random() < acceptanceChance) ? 'accept' : 'decline';

            // Set up 30-second timeout for auto-decline
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
            }
            window.truceTimeout = setTimeout(() => {
                if (document.getElementById('truce-modal').style.display === 'block') {
                    // Auto-decline if player hasn't responded
                    gameLog.push('Truce proposal timed out after 30 seconds. Automatically declined.');
                    updateGameLog();
                    declineTruce();
                }
            }, 30000); // 30 seconds

            document.getElementById('truce-modal').style.display = 'block';
        }

        function acceptTruce() {
            trucePlayerVote = 'accept';

            // Clear the timeout
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
                window.truceTimeout = null;
            }

            document.getElementById('truce-modal').style.display = 'none';

            if (truceAIVote === 'accept') {
                gameLog.push('Player accepted truce.');
                gameLog.push('AI accepted truce.');
                gameLog.push('Truce accepted by both players. Game ends in a draw.');
                updateGameLog();
                endGame('draw', 'Truce');
                return;
            } else {
                gameLog.push('Player accepted truce.');
                gameLog.push('AI declined truce.');
                gameLog.push(`Truce not established. ${truceMaxAttempts - truceAttempts} attempts remaining.`);
                updateGameLog();
                truceDeclinedTurns = 1;
                resumeAfterTruce();
            }
        }

        function declineTruce() {
            trucePlayerVote = 'decline';

            // Clear the timeout
            if (window.truceTimeout) {
                clearTimeout(window.truceTimeout);
                window.truceTimeout = null;
            }

            document.getElementById('truce-modal').style.display = 'none';

            gameLog.push('Player declined truce.');
            if (truceAIVote === 'accept') {
                gameLog.push('AI accepted truce.');
            } else {
                gameLog.push('AI declined truce.');
            }
            gameLog.push(`Truce not established. ${truceMaxAttempts - truceAttempts} attempts remaining.`);
            updateGameLog();

            if (truceAttempts >= truceMaxAttempts) {
                truceEligible = false;
                gameLog.push('Truce is no longer available for this game.');
                updateGameLog();
            } else {
                truceDeclinedTurns = 1;
            }

            resumeAfterTruce();
        }

        function resumeAfterTruce() {
            gamePaused = false;
            startGameTimer();
            if (currentPlayer === 'W') {
                startTurnTimer('W', { reset: false });
            } else {
                startTurnTimer('B', { reset: false });
            }
        }

        function performCoinToss(title, message, callback, automated = false, showOverlay = true) {
            gamePaused = true;
            beginBlockingAction('coinFlip');
            // Save timer state before stopping
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();

            coinTossCallback = callback;

            // Store overlay state for later cleanup
            window.coinTossShowOverlay = showOverlay;

            // Determine if this is the first round coin toss or an in-game outcome
            const isFirstTurn = title === 'First Round';
            window.coinTossContext = isFirstTurn ? 'first-turn' : 'in-game';

            document.getElementById('coin-toss-title').textContent = title;
            document.getElementById('coin-toss-message').textContent = message;

            // Set appropriate description based on context
            if (isFirstTurn) {
                document.getElementById('coin-toss-description').textContent = 'The coin will flip to determine the outcome. White side means you go first, black side means AI goes first.';
            } else {
                document.getElementById('coin-toss-description').textContent = 'The coin will flip to determine the outcome. White side means success, black side means failure.';
            }

            const continueBtn = document.getElementById('coin-toss-continue');
            if (continueBtn) continueBtn.style.display = 'none';
            updateCoinTossEnergyBlastProgress();

            // Always hide buttons and auto-start
            document.getElementById('coin-toss-start').style.display = 'none';

            const coinResult = document.getElementById('coin-result');
            // Reset coin to initial state
            coinResult.className = 'coin';
            coinResult.textContent = '';
            coinResult.style.backgroundColor = '#666';
            coinResult.style.color = 'white';

            // Show overlay and modal (conditionally show overlay)
            if (showOverlay) {
                document.getElementById('modal-overlay').style.display = 'block';
            }
            document.getElementById('coin-toss-modal').style.display = 'block';

            // Always auto-start coin flip after a short delay
            setTimeout(() => startCoinToss(), 500);
        }

        function startCoinToss() {
            // Hide the start button and description
            document.getElementById('coin-toss-start').style.display = 'none';
            document.getElementById('coin-toss-description').textContent = '';

            const coinResult = document.getElementById('coin-result');
            const continueBtn = document.getElementById('coin-toss-continue');
            const isEnergyBlastFlip = !!coinTossEnergyBlastMode;
            const isFirstTurn = window.coinTossContext === 'first-turn';

            // Determine result
            const result = Math.random() < 0.5; // true = white (success), false = black (failure)
            window.lastCoinTossResult = result;

            // Only show animation for first turn, instant for in-game flips
            const animationDelay = isFirstTurn ? 2000 : 0;

            if (isFirstTurn) {
                document.getElementById('coin-toss-message').textContent = 'Flipping...';
                // Add spinning animation only for first turn
                coinResult.classList.add('spinning');
            }

            // After animation completes (2 seconds for first turn, instant for others), show result
            setTimeout(() => {
                // Remove spinning class
                coinResult.classList.remove('spinning');

                if (result) {
                    coinResult.classList.add('white');
                    coinResult.style.backgroundColor = 'white';
                    coinResult.style.color = 'black';

                    if (isFirstTurn) {
                        document.getElementById('coin-toss-message').textContent = "You won the coin toss! You're going first.";
                    } else {
                        // For in-game flips, hide modal immediately and show popup instead
                        applyCoinFlipSuccessEffect(coinTossSpecialEffect);
                    }
                } else {
                    coinResult.classList.add('black');
                    coinResult.style.backgroundColor = 'black';
                    coinResult.style.color = 'white';

                    if (isFirstTurn) {
                        document.getElementById('coin-toss-message').textContent = `${getOpponentDisplayName()} won the coin toss and is going first.`;
                    } else {
                        // For in-game flips, hide modal immediately and show popup instead
                        applyCoinFlipFailureEffect();
                    }
                }

                const savedSpecialEffect = coinTossSpecialEffect;
                coinTossSpecialEffect = null;

                if (coinTossEnergyBlastMode) {
                    coinTossEnergyBlastMode.successes = Math.min(
                        coinTossEnergyBlastMode.total || ENERGY_BLAST_FLIP_COUNT,
                        (coinTossEnergyBlastMode.successes || 0) + (result ? 1 : 0)
                    );
                    updateCoinTossEnergyBlastProgress();
                }

                // For in-game flips, close modal immediately and show popup notification
                if (!isFirstTurn) {
                    // Close modal immediately
                    if (window.coinTossShowOverlay) {
                        document.getElementById('modal-overlay').style.display = 'none';
                    }
                    document.getElementById('coin-toss-modal').style.display = 'none';

                    // Show popup notification
                    showCoinFlipPopup(result, savedSpecialEffect, isEnergyBlastFlip);

                    // Execute callback immediately
                    setTimeout(() => {
                        if (coinTossCallback) {
                            const callback = coinTossCallback;
                            coinTossCallback = null;
                            callback(result);
                        }

                        const skipResume = coinTossSoulBlastHold;
                        if (skipResume) {
                            coinTossSoulBlastHold = false;
                        } else {
                            gamePaused = false;
                            if (pausedTimers.game && gameTimeRemaining > 0) {
                                startGameTimer();
                            }
                            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                                    startTurnTimer('W', { reset: false });
                                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                                    startTurnTimer('B', { reset: false });
                                }
                            }
                        }
                        endBlockingAction('coinFlip');
                        pausedTimers = { game: null, turn: null, turnPlayer: null };
                    }, 100);
                    return;
                }

                // For first turn, keep original behavior with delays
                const showDelay = isEnergyBlastFlip ? 0 : 500;
                setTimeout(() => {
                    const autoCloseDelay = isEnergyBlastFlip ? 800 : 2000;
                    setTimeout(() => {
                        if (window.coinTossShowOverlay) {
                            document.getElementById('modal-overlay').style.display = 'none';
                        }
                        document.getElementById('coin-toss-modal').style.display = 'none';

                        setTimeout(() => {
                            if (coinTossCallback) {
                                const callback = coinTossCallback;
                                coinTossCallback = null;
                                callback(result);
                            }

                            const skipResume = coinTossSoulBlastHold;
                            if (skipResume) {
                                coinTossSoulBlastHold = false;
                            } else {
                                gamePaused = false;
                                if (pausedTimers.game && gameTimeRemaining > 0) {
                                    startGameTimer();
                                }
                                if (pausedTimers.turn && pausedTimers.turnPlayer) {
                                    if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                                        startTurnTimer('W', { reset: false });
                                    } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                                        startTurnTimer('B', { reset: false });
                                    }
                                }
                            }
                            endBlockingAction('coinFlip');
                            pausedTimers = { game: null, turn: null, turnPlayer: null };
                        }, 300);
                    }, autoCloseDelay);
                }, showDelay);
            }, animationDelay);
        }

        function closeCoinToss() {
            // Close overlay and modal
            if (window.coinTossShowOverlay) {
                document.getElementById('modal-overlay').style.display = 'none';
            }
            document.getElementById('coin-toss-modal').style.display = 'none';

            // Wait for modal to be completely hidden before starting game
            setTimeout(() => {
                // Execute callback if it exists
                if (coinTossCallback) {
                    const callback = coinTossCallback;
                    coinTossCallback = null;
                    // Use the stored result from the coin toss
                    callback(window.lastCoinTossResult);
                }

                // Unpause game and resume timers
                gamePaused = false;

                // Resume timers if they were running before the coin toss
                if (pausedTimers.game && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (pausedTimers.turn && pausedTimers.turnPlayer) {
                    if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                endBlockingAction('coinFlip');
                pausedTimers = { game: null, turn: null, turnPlayer: null };
            }, 300);
        }

        function showCoinFlipPopup(success, specialEffect, isEnergyBlastFlip) {
            const popup = document.getElementById('coin-flip-popup');
            const title = document.getElementById('coin-flip-popup-title');
            const message = document.getElementById('coin-flip-popup-message');

            // Clear previous classes
            popup.className = '';

            // Set success or failure styling
            if (success) {
                popup.classList.add('success');
                title.textContent = 'Success!';

                // Determine message based on special effect
                if (specialEffect === 'energy-blast' || specialEffect === 'lich-soul-blast') {
                    message.textContent = 'Ability activated successfully.';
                } else if (isEnergyBlastFlip) {
                    const successes = coinTossEnergyBlastMode?.successes || 0;
                    const total = coinTossEnergyBlastMode?.total || ENERGY_BLAST_FLIP_COUNT;
                    message.textContent = `Coin flip successful! (${successes}/${total} successes)`;
                } else {
                    message.textContent = 'The coin flip was successful!';
                }
            } else {
                popup.classList.add('failure');
                title.textContent = 'Failure!';

                if (isEnergyBlastFlip) {
                    const successes = coinTossEnergyBlastMode?.successes || 0;
                    const total = coinTossEnergyBlastMode?.total || ENERGY_BLAST_FLIP_COUNT;
                    message.textContent = `Coin flip failed. (${successes}/${total} successes)`;
                } else {
                    message.textContent = 'The coin flip failed.';
                }
            }

            // Show popup
            popup.style.display = 'block';
            popup.style.animation = 'popupFadeIn 0.2s ease-out';

            // Auto-hide after delay
            const displayDuration = isEnergyBlastFlip ? 800 : 1500;
            setTimeout(() => {
                popup.style.animation = 'popupFadeOut 0.3s ease-out';
                setTimeout(() => {
                    popup.style.display = 'none';
                }, 300);
            }, displayDuration);
        }

        function isElephantrySpecialActive() {
            return elephantryChargeMode || elephantryExtendedRangeActive || elephantryMoveShootMode;
        }

        function rollElephantryTripleShotFlips(onComplete, shot = 1, allFlips = []) {
            performCoinToss(
                'Elephantry Triple Shot',
                `Triple Shot coin flip ${shot}/3...`,
                (success) => {
                    allFlips.push(success);
                    if (shot < 3) {
                        rollElephantryTripleShotFlips(onComplete, shot + 1, allFlips);
                    } else {
                        // Only store successful flips - failed flips don't result in shots
                        elephantryTripleShotFlipResults = allFlips.filter(r => r);
                        onComplete();
                    }
                },
                false,
                false
            );
        }

        function finishElephantryTripleShot() {
            elephantryExtendedRangeActive = false;
            elephantryTripleShotAwaitingTargets = false;
            elephantryTripleShotFlipResults = [];
            elephantryTripleShotNextShot = 0;
            elephantryTripleShotPieceKey = null;
            validMoves = [];
            selectedPiece = null;
            clearActiveControlButton();
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            endBlockingAction('elephantryTripleShot');
            // Add delay before turn transition to ensure action is visually complete
            if (movesLeft === 0 && !reinforcementPending) {
                setTimeout(() => {
                    triggerAiTurn();
                }, 500);
            } else {
                ensureAITurnIfNeeded();
            }
        }

        function triggerAiTurn() {
            if (gameOver || gamePaused || aiPending || reinforcementPending || currentPlayer !== 'W' || lichSoulBlastResolving) return;
            if (isBlockingActionPending()) return;
            if (isElephantrySpecialActive()) return;
            stopTurnTimer();
            // Remove warcry active background when switching to AI turn
            removeWarcryActiveBackground();
            applyEndTurnEffects('W');
            // Update round statistics before switching to AI
            updateRoundStats('W');

            // Increment round when second player finishes their round
            if (firstPlayer === 'B') {
                // AI went first, so player finishing means round is complete
                gameRound++;
            }

            aiPending = true;
            try {
                aiTurn();
            } catch (err) {
                console.error('AI round failed:', err);
                completeAiTurn({ reason: 'AI encountered an error taking its round.' });
            } finally {
                // aiTurn clears the flag when it begins; keep safety fallback here
                if (aiPending) {
                    aiPending = false;
                }
            }
        }

        function completeAiTurn({ reason = null, skipEndEffects = false } = {}) {
            if (!skipEndEffects) {
                applyEndTurnEffects('B');
            }
            // Update round statistics before switching players
            updateRoundStats('B');
            aiPending = false;
            aiTurnTimeoutForced = false;
            stopTurnTimer();
            highlightSquares = [];
            currentPlayer = 'W';
            roundCount++; // Increment round counter when AI finishes and control returns to player

            // Increment round when second player finishes their round
            if (firstPlayer === 'W') {
                // Player went first, so AI finishing means round is complete
                gameRound++;
            }
            ballistaRangeBoostActive['W'] = false;
            ballistaRangeBoostUsedThisTurn['W'] = false;
            // Reset wizard summoning flag for new round
            wizardSummonedThisTurn['W'] = false;
            // Clear wizard movement restrictions from previous round
            wizardCannotMoveNextTurn['W'].clear();

            const humanBaseMoves = calculateBaseMoves('W');
            const playerCanMove = applyStartTurnModifiers('W', humanBaseMoves);

            movedPieces.clear();
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            checkGameOver();

            if (!playerCanMove) {
                triggerAiTurn();
            } else {
                ensureAITurnIfNeeded();
            }

            if (reason) {
                gameLog.push(reason);
                updateGameLog();
            }
        }

        function ensureAITurnIfNeeded() {
            if (gamePaused || currentPlayer !== 'W' || reinforcementPending || aiPending) return;
            if (isBlockingActionPending()) return;
            // Don't end turn if pistolier or elephantry specials are waiting for targeting
            if (pistolierMoveShootMode || isElephantrySpecialActive()) return;
            if (movesLeft <= 0) {
                triggerAiTurn();
                return;
            }
            // For larger boards, always check if turn should end (not just when moves used)
            // For smaller boards, only check if at least one move has been used
            if (movesLeft < initialMovesLeft || isLargeBoardVariant()) {
                let anyValidActions = false;
                outer: for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const piece = board[r][c];
                        if (piece && piece.player === 'W' && !movedPieces.has(`${r},${c}`)) {
                            const vm = getValidMoves(r, c);
                            // Check if any moves are actually affordable
                            for (let move of vm) {
                                if (move.cost <= movesLeft) {
                                    anyValidActions = true;
                                    break outer;
                                }
                            }
                        }
                    }
                }
                if (!anyValidActions) {
                    movesLeft = 0; // Ensure movesLeft is 0 before triggering
                    triggerAiTurn();
                }
            }
        }

        function isAnySpecialModeActive() {
            return turnAndShootMode || turnAndMoveMode || guardOfHonourMode || teleportMode || teleportSwapMode || chargeMode || ogreRageMode || infernoMode || strafeMode || summonSpectreMode || archerMoveDiagMode || archerDiagShootSelectMode || archerDiag2ShootMode || elephantryChargeMode || elephantryExtendedRangeActive || elephantryMoveShootMode || pistolierMoveShootMode || fusilierCrackShotActive || fusilierStrafeActive || huntsmanBurstMode || pendingHuntsmanBurst || championSummonMode || necromancerSummonMode || kingShotMode || kingEvadeMode || lichSoulBlastMode || darkVoidMode || voidBlastMode;
        }

        function cancelSpecialModes(options = {}) {
            const { resetSelection = true } = options;
            turnAndShootMode = false;
            turnAndMoveMode = false;
            guardOfHonourMode = false;
            teleportMode = false;
            teleportSwapMode = false;
            chargeMode = false;
            ogreRageMode = false;
            infernoMode = false;
            strafeMode = false;
            summonSpectreMode = false;
            darkVoidMode = null;
            archerMoveDiagMode = false;
            archerDiagShootSelectMode = false;
            archerDiag2ShootMode = false;
            elephantryChargeMode = false;
            elephantryExtendedRangeActive = false;
            elephantryTripleShotAwaitingTargets = false;
            elephantryTripleShotFlipResults = [];
            elephantryTripleShotNextShot = 0;
            elephantryTripleShotPieceKey = null;
            fusilierCrackShotActive = null;
            fusilierStrafeActive = false;
            elephantryMoveShootMode = false;
            elephantryMoveShootPosition = null;
            pistolierMoveShootMode = false;
            pistolierMoveShootPosition = null;
            const huntsmanContext = huntsmanBurstMode;
            huntsmanBurstMode = null;
            pendingHuntsmanBurst = null;
            resumeGameAfterHuntsmanBurst();
            if (huntsmanContext && typeof huntsmanContext.onComplete === 'function') {
                huntsmanContext.onComplete();
            }
            championSummonMode = null;
            necromancerSummonMode = null;
            darkVoidMode = null;
            kingShotMode = null;
            kingEvadeMode = null;
            kingSummonMode = null;
            pendingLichSoulBlast = null;
            lichSoulBlastMode = null;
            voidBlastMode = false;
            clearSoulBlastPreview();
            lichSoulBlastResolving = false;
            lichSoulBlastPendingCompletion = false;
            lichSoulBlastTargetInfo = null;
            soulBlastPauseState = null;
            removeSoulBlastSlowMo(true);
            resumeGameAfterSoulBlast();
            archerMoveDiagStart = null;
            const turnModalEl = document.getElementById('turn-modal');
            if (turnModalEl) turnModalEl.style.display = 'none';
            const turnMoveModalEl = document.getElementById('turn-move-modal');
            if (turnMoveModalEl) turnMoveModalEl.style.display = 'none';
            const turnShootModalEl = document.getElementById('turn-shoot-modal');
            if (turnShootModalEl) turnShootModalEl.style.display = 'none';
            lastAction = null;

            if (resetSelection) {
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
            } else if (selectedPiece) {
                const { row, col } = selectedPiece;
                if (board[row][col] && board[row][col].player === currentPlayer) {
                    validMoves = getValidMoves(row, col);
                    showPieceInfo(board[row][col], currentPlayer);
                } else {
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                }
            } else {
                validMoves = [];
            }

            pendingEnergyBlast = null;
            activeEnergyBlastCost = null;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            resumeGameForEnergyBlastFlips();
            removeEnergyBlastGlow();
            clearActiveControlButton();
        }

        function applyEndTurnEffects(player) {
            const opponent = getOpponent(player);
            let logUpdated = false;

            if (roundScoreGain[player] >= HONOUR_THRESHOLD) {
                nextRoundModifier[player] += HONOUR_BONUS;
                gameStats.warcryBonusCount[player]++;
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} triggered Warcry bonus (+${HONOUR_BONUS} moves next round).`);
                logUpdated = true;
            }

            const losses = roundLosses[opponent] || {};
            for (let type in losses) {
                if (losses[type] >= 2 && !DESPAIR_EXCLUDED.has(type)) {
                    nextRoundModifier[opponent] -= DESPAIR_PENALTY;
                    gameStats.despairPenaltyCount[opponent]++;
                    gameLog.push(`${opponent === 'W' ? 'Player' : 'AI'} suffers Despair penalty (-${DESPAIR_PENALTY} moves next round).`);
                    logUpdated = true;
                    break;
                }
            }

            roundScoreGain[player] = 0;
            roundCaptureValue[player] = 0;
            roundLosses[player] = {};
            roundLosses[opponent] = {};
            warcryAchievedThisRound[player] = false;

            // Update Fusilier cooldowns at the end of the player's round
            finalizeFusilierShots(player);

            // Clear mercenary bonus turn tracking at the end of the player's round
            mercenaryBonusTurnUsed[player].clear();

            // Clear mercenary bonus turn state to prevent it from carrying over to next round
            if (mercenaryBonusTurnActive && mercenaryBonusTurnPiece) {
                deactivateMercenaryBonusTurn();
            }

            if (logUpdated) {
                updateGameLog();
            }
        }

        function finalizeFusilierShots(player) {
            const lastTurnSet = fusilierShotLastTurn[player];
            if (!lastTurnSet) return;

            if (fusilierCrackShotActive && fusilierCrackShotActive.player === player) {
                fusilierCrackShotActive = null;
            }

            lastTurnSet.clear();
            fusilierShotThisTurn[player].forEach(piece => {
                if (piece && piece.player === player && piece.type === 'Fusilier') {
                    lastTurnSet.add(piece);
                }
            });
            fusilierShotThisTurn[player].clear();
        }

        function pruneFusilierShotTracking(player) {
            const activeFusiliers = new Set();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'Fusilier') {
                        activeFusiliers.add(piece);
                    }
                }
            }

            const lastTurnSet = fusilierShotLastTurn[player];
            if (lastTurnSet) {
                const keep = [];
                lastTurnSet.forEach(piece => {
                    if (activeFusiliers.has(piece)) {
                        keep.push(piece);
                    }
                });
                lastTurnSet.clear();
                keep.forEach(piece => lastTurnSet.add(piece));
            }

            const thisTurnSet = fusilierShotThisTurn[player];
            if (thisTurnSet) {
                const keep = [];
                thisTurnSet.forEach(piece => {
                    if (activeFusiliers.has(piece)) {
                        keep.push(piece);
                    }
                });
                thisTurnSet.clear();
                keep.forEach(piece => thisTurnSet.add(piece));
            }
        }

        function calculateBaseMoves(player) {
            let base = championCaptured[player] ? 2 : 3;
            const opponent = getOpponent(player);
            base -= championsOnBackRow[opponent].length;
            return Math.max(0, base);
        }

        function applyStartTurnModifiers(player, baseMoves, options = {}) {
            const { skipStopTimer = false } = options;
            if (!skipStopTimer) {
                stopTurnTimer();
            }
            pruneFusilierShotTracking(player);
            const opponent = getOpponent(player);
            let modifier = nextRoundModifier[player] || 0;
            let moves = Math.max(0, baseMoves + modifier);

            if (modifier > 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} gains Warcry bonus (+${modifier} moves).`);
                // Apply warcry active background
                applyWarcryActiveBackground();
            } else if (modifier < 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} is hindered by Despair penalty (-${Math.abs(modifier)} moves).`);
            }

            if (modifier !== 0) {
                updateGameLog();
            }

            nextRoundModifier[player] = 0;
            movesLeft = moves;
            initialMovesLeft = moves;
            baseMovesThisTurn = baseMoves; // Store base moves for tracking when bonus is spent
            roundScoreGain[player] = 0;
            roundCaptureValue[player] = 0;
            roundLosses[player] = roundLosses[player] || {};
            roundLosses[opponent] = {};
            decrementNecromancerCooldown(player);
            decrementUndeadChampionCooldown(player);
            decayEnergyBlastResiduals(player);
            let turnStartHandled = false;
            const finalizeTurnStart = () => {
                if (turnStartHandled) return;
                turnStartHandled = true;
                if (moves === 0) {
                    if (player === 'W') {
                        playerTurnTimeRemaining = 0;
                    } else {
                        aiTurnTimeRemaining = 0;
                    }
                    updateTimerDisplay();
                    gameLog.push(`${player === 'W' ? 'Player' : 'AI'} is immobilized this round.`);
                    updateGameLog();
                    return;
                }

                startTurnTimer(player);

                // Check for truce at start of player's round
                if (player === 'W' && truceDeclinedTurns > 0) {
                    truceDeclinedTurns++;
                    if (truceDeclinedTurns <= 3) {
                        checkForTruce();
                    }
                } else if (player === 'W' && truceDeclinedTurns === 0) {
                    checkForTruce();
                }
            };

            const zombiesPending = advanceZombiesForPlayer(player, finalizeTurnStart);
            if (!zombiesPending) {
                finalizeTurnStart();
            }

            return moves > 0;
        }
        let highlightSquares = [];
        let pendingSpellAction = null;
        let energyBlastUsage = new Map();
        let energyBlastUses = { 'W': 0, 'B': 0 };
        let sacrificeAttemptedPieces = new Set();
        let energyBlastFlipContext = null;
        let pendingEnergyBlast = null;
        let activeEnergyBlastCost = null;
        let energyBlastGlowActive = false;
        let energyBlastGlowVariant = null;
        let energyBlastGlowRemovalTimeout = null;
        let energyBlastResidualSquares = new Map();
        let energyBlastFlipPauseState = null;
        let coinTossEnergyBlastMode = null;
        let coinTossSpecialEffect = null;
        let pendingAiEnergyBlastResume = null;
        let soulBlastSlowMoTimeout = null;
        let activeControlButton = null;
        let mercenaryBonusHighlight = null;
        let protectionUsed = { 'W': false, 'B': false };
        let pendingProtection = null;
        let kingSpecialUsed = { 'W': false, 'B': false };
        let wizardTeleportUsed = { 'W': 0, 'B': 0 };
        let wizardTeleportSwapUsed = { 'W': false, 'B': false };
        let cavalryChargeUsed = { 'W': false, 'B': false };
        let dragonInfernoUsed = { 'W': false, 'B': false }; // New state for Inferno usage
        let ogreRageUsed = { 'W': false, 'B': false }; // Rage special (once per game per player)
        let wizardStrafeUsed = { 'W': 0, 'B': 0 }; // Strafe move (limit 2)
        let dragonStrafeUsed = { 'W': 0, 'B': 0 }; // Strafe move (limit 2)
        let spectresSummoned = { 'W': 0, 'B': 0 }; // Spectre summoning (limit 2 per player)
        let wizardSummonedThisTurn = { 'W': false, 'B': false }; // Track if wizard summoned this turn
        let wizardCannotMoveNextTurn = { 'W': new Set(), 'B': new Set() }; // Wizards that cannot move next turn
        let wizardSacrificedByPlayer = { 'W': false, 'B': false }; // Track if player has sacrificed a wizard
        let necromancersSummoned = { 'W': 0, 'B': 0 }; // Necromancer summoning (limit 2 per player)
        let necromancerTeleportCounts = new Map(); // Track per-piece teleport usage
        let necromancerShootCooldown = new Map(); // Track per-piece ranged cooldown
        let zombiesSummoned = { 'W': 0, 'B': 0 }; // Total Zombies currently controlled (base cap 3)
        let undeadSummoned = { 'W': 0, 'B': 0 }; // Undead summons per player (limit 2)
        let zombiePendingAdvanceQueue = []; // Pending automatic Zombie advances requests
        let zombieConversions = { 'W': 0, 'B': 0 }; // Successful zombie conversions (max 2 to raise cap)
        let zombieCoinQueue = []; // Pending zombie coin flip animations
        let zombieCoinAnimating = false;
        let zombieCoinModalTimeouts = [];
        let diceRollQueue = [];
        let diceRolling = false;
        let diceRollModalTimeouts = [];
        let zombieAutoAdvanceInProgress = false;
        let zombieAdvanceTimer = null;
        let coinTossCallback = null; // Callback for coin toss result
        let archerMoveDiagShootUsed = { 'W': 0, 'B': 0 }; // Move then shoot diagonally (limit 2)
        let archerDiag2ShootUsed = { 'W': 0, 'B': 0 }; // Diagonal 2-square shot (limit 2)
        let capturedSquares = []; // Track squares where captures occur
        // Ballista specials
        let ballistaRangeBoostActive = { 'W': false, 'B': false };
        let ballistaRangeBoostUsedThisTurn = { 'W': false, 'B': false };
        let ballistaDoubleTimeUsed = { 'W': 0, 'B': 0 };
        // Elephantry specials
        let elephantryChargeUsed = new WeakSet(); // Track which elephantry pieces have used charge (per piece per game)
        let elephantryExtendedRangeShotsRemaining = {}; // Map of "row,col,player" to remaining shots (starts at 3)
        let elephantryExtendedRangeMode = false; // Active during extended range shooting sequence
        // Fusilier specials
        let fusilierShotLastTurn = { 'W': new Set(), 'B': new Set() }; // Fusiliers that fired last turn (wait one turn before shooting again)
        let fusilierShotThisTurn = { 'W': new Set(), 'B': new Set() }; // Fusiliers that have fired during the current turn
        let fusilierCrackShotUsed = new Set(); // Track which fusilier pieces have used crack shot (set of "row,col,player", max 3 uses)
        let fusilierCrackShotCount = {}; // Map of "row,col,player" to remaining uses (starts at 3)
        let fusilierStrafeUsed = new Set(); // Track which fusilier pieces have used strafe (set of "row,col,player", max 2 uses)
        let fusilierStrafeCount = {}; // Map of "row,col,player" to remaining uses (starts at 2)
        // Mercenary specials
        let mercenaryBonusTurnUsed = { 'W': new Set(), 'B': new Set() }; // Mercenaries that have used their bonus turn this turn
        let mercenaryBonusTurnCount = { 'W': 0, 'B': 0 }; // Count of bonus turns used per game (max 3 per player)
        let mercenaryBonusTurnActive = false; // Track if we're in mercenary bonus turn mode
        let mercenaryBonusTurnPiece = null; // Track which mercenary is in bonus turn (row, col)
        // King summoning
        let pistoliersSummoned = { 'W': 0, 'B': 0 }; // Track summoned pistoliers (max 2 per player)
        let fusiliersSummoned = { 'W': 0, 'B': 0 }; // Track summoned fusiliers (max 2 per player)
        let lichesSummoned = { 'W': 0, 'B': 0 }; // Track summoned liches (max 1 per player)
        let undeadChampionsSummoned = { 'W': 0, 'B': 0 }; // Track summoned undead champions (max 1 per player)
        let undeadChampionTeleportUsed = new WeakSet(); // Track which undead champions have used teleport
        let undeadChampionRangedCooldown = new Map(); // Track per-piece ranged attack cooldown

        function getMaxZombies(player) {
            return 3 + Math.min(zombieConversions[player] || 0, 2);
        }

        function getTotalCapturedCount() {
            return (capturedPieces['W'] || []).length + (capturedPieces['B'] || []).length;
        }

        function recordGraveyardCapture(player, piece) {
            if (!player || !piece) return;
            capturedPieces[player].push(piece);
        }

        function hasNecromancerSummonPrerequisite(player) {
            // Check if this player has sacrificed their Wizard
            if (wizardSacrificedByPlayer && wizardSacrificedByPlayer[player] === true) {
                return true;
            }
            // Check if there are at least 10 captured pieces collectively
            const totalCaptured = getTotalCapturedCount();
            if (totalCaptured >= 10) {
                return true;
            }
            // Prerequisites not met
            return false;
        }

        function canChampionSummonNecromancer(player) {
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return false;
            if ((necromancersSummoned[player] || 0) >= 2) return false;
            return hasNecromancerSummonPrerequisite(player);
        }

        function canChampionSummonHuntsman(player) {
            if (gameVariant !== '36s-supreme') return false;
            if ((huntsmenSummoned[player] || 0) >= HUNTSMAN_SUMMON_LIMIT) return false;
            if ((huntsmenOnBoard[player] || 0) >= HUNTSMAN_MAX_ACTIVE) return false;
            return true;
        }

        function recordHuntsmanSpawn(player) {
            huntsmenSummoned[player] = (huntsmenSummoned[player] || 0) + 1;
            huntsmenOnBoard[player] = (huntsmenOnBoard[player] || 0) + 1;
        }

        function getNecromancerTeleportCount(piece) {
            if (!piece) return 0;
            return necromancerTeleportCounts.get(piece) || 0;
        }

        function incrementNecromancerTeleportCount(piece) {
            if (!piece) return;
            const used = getNecromancerTeleportCount(piece);
            necromancerTeleportCounts.set(piece, used + 1);
        }

        function setNecromancerShotCooldown(piece, turns) {
            if (!piece) return;
            if (turns > 0) {
                necromancerShootCooldown.set(piece, turns);
            } else {
                necromancerShootCooldown.delete(piece);
            }
        }

        function setUndeadChampionRangedCooldown(piece, turns) {
            if (!piece) return;
            if (turns > 0) {
                undeadChampionRangedCooldown.set(piece, turns);
            } else {
                undeadChampionRangedCooldown.delete(piece);
            }
        }

        function createZombiePiece(player) {
            return { type: 'Zombie', player, facing: player === 'W' ? 'U' : 'D' };
        }

        function createUndeadPiece(player, lives, summonedBy) {
            const type = 'Undead';
            return { type, player, lives, maxLives: lives, summonedBy };
        }

        function createSpectrePiece(player) {
            return { type: 'Spectre', player };
        }

        function createUndeadChampionPiece(player, summonedBy) {
            return { type: 'UndeadChampion', player, lives: 2, maxLives: 2, summonedBy };
        }

        function isPieceOnBoard(piece) {
            if (!piece) return false;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r] && board[r][c] === piece) {
                        return true;
                    }
                }
            }
            return false;
        }

        function cleanupNecromancerTracking(piece) {
            if (!piece) return;
            necromancerTeleportCounts.delete(piece);
            necromancerShootCooldown.delete(piece);
            if (piece.type === 'Necromancer' && necromancersSummoned[piece.player] > 0) {
                necromancersSummoned[piece.player]--;
            }
            if (piece.type === 'Zombie' && zombiesSummoned[piece.player] > 0) {
                zombiesSummoned[piece.player]--;
            }
            if (isUndeadType(piece) && undeadSummoned[piece.player] > 0) {
                undeadSummoned[piece.player]--;
            }
            if (isUndeadChampionType(piece) && undeadChampionsSummoned[piece.player] > 0) {
                undeadChampionsSummoned[piece.player]--;
            }
            if (isUndeadChampionType(piece)) {
                undeadChampionTeleportUsed.delete(piece);
                undeadChampionRangedCooldown.delete(piece);
            }
        }

        function enqueueZombieCoinFlip(result, title, message) {
            zombieCoinQueue.push({ result, title, message });
            if (!zombieCoinAnimating) {
                processZombieCoinFlipQueue();
            }
        }

        function processZombieCoinFlipQueue() {
            if (!zombieCoinQueue.length) {
                zombieCoinAnimating = false;
                return;
            }
            zombieCoinAnimating = true;
            const { result, title, message } = zombieCoinQueue.shift();
            showZombieCoinFlipModal(result, title, message, () => {
                zombieCoinAnimating = false;
                processZombieCoinFlipQueue();
            });
        }

        function showZombieCoinFlipModal(result, title, message, done) {
            const modal = document.getElementById('coin-toss-modal');
            const coinResult = document.getElementById('coin-result');
            const titleEl = document.getElementById('coin-toss-title');
            const messageEl = document.getElementById('coin-toss-message');
            const descriptionEl = document.getElementById('coin-toss-description');
            const startBtn = document.getElementById('coin-toss-start');
            const continueBtn = document.getElementById('coin-toss-continue');

            if (!modal || !coinResult || !titleEl || !messageEl || !descriptionEl) {
                done();
                return;
            }

            beginBlockingAction('zombieFlip');
            if (startBtn) startBtn.style.display = 'none';
            if (continueBtn) continueBtn.style.display = 'none';

            titleEl.textContent = title || 'Coin Toss';
            messageEl.textContent = message || 'Flipping...';
            descriptionEl.textContent = 'The coin will flip to determine the outcome. White side means success, black side means failure.';

            coinResult.className = 'coin';
            coinResult.style.backgroundColor = '#666';
            coinResult.style.color = 'white';
            coinResult.textContent = '';

            modal.dataset.zombieFlip = 'true';
            modal.style.display = 'block';

            void coinResult.offsetWidth;
            coinResult.classList.add('spinning');

            const revealTimeout = setTimeout(() => {
                zombieCoinModalTimeouts = zombieCoinModalTimeouts.filter(id => id !== revealTimeout);
                coinResult.classList.remove('spinning');
                const outcomeText = result ? 'Success!' : 'Failure!';
                if (result) {
                    coinResult.classList.add('white');
                    coinResult.style.backgroundColor = 'white';
                    coinResult.style.color = 'black';
                    applyCoinFlipSuccessEffect();
                } else {
                    coinResult.classList.add('black');
                    coinResult.style.backgroundColor = 'black';
                    coinResult.style.color = 'white';
                    applyCoinFlipFailureEffect();
                }
                messageEl.textContent = message ? `${message} - ${outcomeText}` : outcomeText;

                const closeTimeout = setTimeout(() => {
                    zombieCoinModalTimeouts = zombieCoinModalTimeouts.filter(id => id !== closeTimeout);
                    if (modal.dataset.zombieFlip === 'true') {
                        modal.style.display = 'none';
                        delete modal.dataset.zombieFlip;
                    }
                    coinResult.className = 'coin';
                    coinResult.style.backgroundColor = '#666';
                    coinResult.style.color = 'white';
                    coinResult.textContent = '';
                    descriptionEl.textContent = '';
                    messageEl.textContent = '';
                    if (startBtn) startBtn.style.display = 'none';
                    if (continueBtn) continueBtn.style.display = 'none';
                    endBlockingAction('zombieFlip');
                    done();
                }, 1600);
                zombieCoinModalTimeouts.push(closeTimeout);
            }, 2000);
            zombieCoinModalTimeouts.push(revealTimeout);
        }

        function clearZombieCoinAnimations() {
            zombieCoinQueue = [];
            zombieCoinAnimating = false;
            while (zombieCoinModalTimeouts.length) {
                const timeoutId = zombieCoinModalTimeouts.pop();
                clearTimeout(timeoutId);
            }
            const modal = document.getElementById('coin-toss-modal');
            const coinResult = document.getElementById('coin-result');
            const messageEl = document.getElementById('coin-toss-message');
            const descriptionEl = document.getElementById('coin-toss-description');
            const startBtn = document.getElementById('coin-toss-start');
            const continueBtn = document.getElementById('coin-toss-continue');
            if (modal && modal.dataset.zombieFlip) {
                modal.style.display = 'none';
                delete modal.dataset.zombieFlip;
            }
            if (coinResult) {
                coinResult.className = 'coin';
                coinResult.style.backgroundColor = '#666';
                coinResult.style.color = 'white';
                coinResult.textContent = '';
            }
            if (descriptionEl) {
                descriptionEl.textContent = '';
            }
            if (messageEl) {
                messageEl.textContent = '';
            }
            if (startBtn) startBtn.style.display = 'none';
            if (continueBtn) continueBtn.style.display = 'none';
            blockingActionCounters.zombieFlip = 0;
        }

        function enqueueDiceRoll(options = {}) {
            diceRollQueue.push(options);
            if (!diceRolling) {
                processDiceRollQueue();
            }
        }

        function processDiceRollQueue() {
            if (!diceRollQueue.length) {
                diceRolling = false;
                return;
            }
            diceRolling = true;
            const options = diceRollQueue.shift();
            showDiceRollModal(options, () => {
                diceRolling = false;
                processDiceRollQueue();
            });
        }

        function showDiceRollModal(options = {}, done = () => {}) {
            const modal = document.getElementById('dice-roll-modal');
            const titleEl = document.getElementById('dice-roll-title');
            const messageEl = document.getElementById('dice-roll-message');
            const descriptionEl = document.getElementById('dice-roll-description');
            const outcomeEl = document.getElementById('dice-roll-outcome');
            const d10El = document.getElementById('dice-d10-value');
            const d14El = document.getElementById('dice-d14-value');
            const face10 = document.getElementById('dice-face-d10');
            const face14 = document.getElementById('dice-face-d14');

            if (!modal || !titleEl || !messageEl || !d10El || !d14El || !face10 || !face14) {
                done();
                return;
            }

            modal.dataset.diceRoll = 'true';
            modal.style.display = 'block';
            titleEl.textContent = options.title || 'Dice Roll';
            messageEl.textContent = options.message || 'Rolling the dice...';
            descriptionEl.textContent = options.description || '';
            outcomeEl.textContent = '';
            d10El.textContent = '?';
            d14El.textContent = '?';

            const clampDice = (value, max) => {
                if (typeof value !== 'number' || Number.isNaN(value)) return null;
                const rounded = Math.floor(value);
                return Math.min(Math.max(rounded, 1), max);
            };

            const randomD10 = () => Math.floor(Math.random() * 10) + 1;
            const randomD14 = () => Math.floor(Math.random() * 14) + 1;
            const sequence = options.diceSequence && options.diceSequence.length
                ? options.diceSequence.slice(0, BARRAGE_TARGET_COUNT)
                : Array.from({ length: BARRAGE_TARGET_COUNT }, () => ({
                    d10: randomD10(),
                    d14: randomD14()
                }));

            face10.classList.add('rolling');
            face14.classList.add('rolling');

            let currentIndex = 0;
            const stepDuration = options.stepDuration || 450;
            const showNextRoll = () => {
                const combo = sequence[Math.min(currentIndex, sequence.length - 1)];
                d10El.textContent = combo.d10;
                d14El.textContent = combo.d14;
                if (currentIndex < sequence.length - 1) {
                    currentIndex++;
                    const stepTimeout = setTimeout(() => showNextRoll(), stepDuration);
                    diceRollModalTimeouts.push(stepTimeout);
                } else {
                    finalizeDiceSequence();
                }
            };

            const finalizeDiceSequence = () => {
                face10.classList.remove('rolling');
                face14.classList.remove('rolling');
                const finalCombo = sequence[sequence.length - 1];
                const outcomeText = options.outcomeText || `Result -> D10: ${finalCombo.d10}, D14: ${finalCombo.d14}`;
                outcomeEl.textContent = outcomeText;
                if (typeof options.callback === 'function') {
                    options.callback(sequence);
                }
                const closeTimeout = setTimeout(() => {
                    diceRollModalTimeouts = diceRollModalTimeouts.filter(id => id !== closeTimeout);
                    if (modal.dataset.diceRoll === 'true') {
                        modal.style.display = 'none';
                        delete modal.dataset.diceRoll;
                    }
                    if (messageEl) messageEl.textContent = '';
                    if (descriptionEl) descriptionEl.textContent = '';
                    if (outcomeEl) outcomeEl.textContent = '';
                    if (d10El) d10El.textContent = '?';
                    if (d14El) d14El.textContent = '?';
                    if (face10) face10.classList.remove('rolling');
                    if (face14) face14.classList.remove('rolling');
                    done();
                }, 3000);
                diceRollModalTimeouts.push(closeTimeout);
            };

            showNextRoll();
        }

        function clearDiceRollAnimations() {
            diceRollQueue = [];
            diceRolling = false;
            while (diceRollModalTimeouts.length) {
                const timeoutId = diceRollModalTimeouts.pop();
                clearTimeout(timeoutId);
            }
            const modal = document.getElementById('dice-roll-modal');
            const messageEl = document.getElementById('dice-roll-message');
            const descriptionEl = document.getElementById('dice-roll-description');
            const outcomeEl = document.getElementById('dice-roll-outcome');
            const d10El = document.getElementById('dice-d10-value');
            const d14El = document.getElementById('dice-d14-value');
            const face10 = document.getElementById('dice-face-d10');
            const face14 = document.getElementById('dice-face-d14');
            if (modal && modal.dataset.diceRoll) {
                modal.style.display = 'none';
                delete modal.dataset.diceRoll;
            }
            if (messageEl) messageEl.textContent = '';
            if (descriptionEl) descriptionEl.textContent = '';
            if (outcomeEl) outcomeEl.textContent = '';
            if (d10El) d10El.textContent = '?';
            if (d14El) d14El.textContent = '?';
            if (face10) face10.classList.remove('rolling');
            if (face14) face14.classList.remove('rolling');
        }

        // Convenience wrapper so callers can await the dice outcome.
        function rollDiceWithPopup(options = {}) {
            const baseRandomD10 = () => Math.floor(Math.random() * 10) + 1;
            const baseRandomD14 = () => Math.floor(Math.random() * 14) + 1;
            const sequence = options.diceSequence && options.diceSequence.length
                ? options.diceSequence.slice(0, BARRAGE_TARGET_COUNT)
                : Array.from({ length: BARRAGE_TARGET_COUNT }, () => ({
                    d10: baseRandomD10(),
                    d14: baseRandomD14()
                }));
            return new Promise(resolve => {
                const userCallback = options.callback;
                enqueueDiceRoll({
                    ...options,
                    diceSequence: sequence,
                    callback: (result) => {
                        if (typeof userCallback === 'function') {
                            userCallback(result);
                        }
                        resolve(result);
                    }
                });
            });
        }

        function rollDieInBounds(sides, limit) {
            const effectiveLimit = Math.max(1, Math.min(limit, sides));
            let roll;
            do {
                roll = Math.floor(Math.random() * sides) + 1;
            } while (roll > effectiveLimit);
            return roll;
        }

        function generateBarrageTargets(count, sequence = null) {
            const targets = [];
            const addTarget = (diceRow, diceCol) => {
                const rowLimit = Math.max(1, Math.min(ROWS, 10));
                const colLimit = Math.max(1, Math.min(COLS, 14));
                const clampedRow = Math.min(Math.max(Math.floor(diceRow), 1), rowLimit);
                const clampedCol = Math.min(Math.max(Math.floor(diceCol), 1), colLimit);
                targets.push({
                    row: clampedRow - 1,
                    col: clampedCol - 1,
                    diceRow: clampedRow,
                    diceCol: clampedCol
                });
            };
            if (sequence && sequence.length) {
                for (let combo of sequence.slice(0, count)) {
                    addTarget(combo.d10, combo.d14);
                }
            }
            while (targets.length < count) {
                const rowRoll = rollDieInBounds(10, ROWS);
                const colRoll = rollDieInBounds(14, COLS);
                addTarget(rowRoll, colRoll);
            }
            return targets;
        }

        function zombieCoinFlip({ title = 'Zombie Coin Flip', message = '' } = {}) {
            const result = Math.random() < 0.5;
            enqueueZombieCoinFlip(result, title, message);
            return result;
        }

        function lichCoinFlip({ title = 'Lich Coin Flip', message = '' } = {}) {
            const result = Math.random() < 0.5;
            enqueueZombieCoinFlip(result, title, message);
            return result;
        }

        function resolveLichCaptureAttempt({ attackerType, attackerPlayer, targetRow, targetCol, actionLabel }) {
            if (!attackerType || LICH_CAPTURE_AUTO_TYPES.has(attackerType) || actionLabel === 'Soul Blast') {
                return true;
            }
            const playerLabel = attackerPlayer === 'W' ? 'Player' : getOpponentDisplayName();
            const verb = actionLabel || 'capture';
            const success = lichCoinFlip({
                title: 'Lich Capture',
                message: `${playerLabel} attempts to ${verb} the Lich at ${formatBoardCoordinates(targetRow,targetCol)}.`
            });
            if (!success) {
                gameLog.push(`${playerLabel} failed to ${verb} the Lich at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                updateGameLog();
                return false;
            }
            return true;
        }

        function mercenaryCoinFlip(player) {
            const result = Math.random() < 0.5;
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            const title = 'Mercenary Bonus Turn';
            const message = `${playerLabel} mercenary attempts bonus turn`;
            enqueueZombieCoinFlip(result, title, message);
            return result;
        }

        function randomCoinFlip() {
            return Math.random() < 0.5;
        }

        function getBackRow(player) {
            return player === 'W' ? ROWS - 1 : 0;
        }

        function getOpponentBackRow(player) {
            return player === 'W' ? 0 : ROWS - 1;
        }

        function findBackRowSpawnColumn(player, preferredCol = null) {
            const backRow = getBackRow(player);
            const columns = [];
            if (preferredCol !== null) columns.push(preferredCol);
            for (let c = 0; c < COLS; c++) {
                if (c !== preferredCol) columns.push(c);
            }
            for (const col of columns) {
                if (col >= 0 && col < COLS && !board[backRow][col]) {
                    return col;
                }
            }
            return null;
        }

        function hasBackRowSpawnSlot(player) {
            return findBackRowSpawnColumn(player) !== null;
        }

        function spawnZombieAtBackRow(player, preferredCol = null) {
            const spawnCol = findBackRowSpawnColumn(player, preferredCol);
            if (spawnCol === null) return false;
            const backRow = getBackRow(player);
            const zombie = createZombiePiece(player);
            board[backRow][spawnCol] = zombie;
            zombiesSummoned[player] = (zombiesSummoned[player] || 0) + 1;
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} zombie spawned at ${formatBoardCoordinates(backRow,spawnCol)}.`);
            return true;
        }

        function awardZombieBonus(player, reason) {
            scores[player] += 3;
            registerScoreGain(player, 3);
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} gained +3 points (${reason}).`);
        }

        function capturePieceForZombie(player, row, col, targetPiece) {
            cleanupNecromancerTracking(targetPiece);
            capturedSquares.push([row, col]);
            recordGraveyardCapture(player, targetPiece);
            const captureValue = pieceValues[targetPiece.type] || 0;
            scores[player] += captureValue;
            registerScoreGain(player, captureValue, true);
            registerPieceLoss(targetPiece.player, targetPiece.type);
            trackCapture(player); // Track capture for statistics
            if (targetPiece.type === 'Champion') {
                championCaptured[targetPiece.player] = true;
            }
            if (targetPiece.type === 'King') {
                endGame(player);
                return;
            }
            board[row][col] = null;
        }

        function handleZombieReachedOpponentBackRow(player, row, col) {
            const opponentBackRow = getOpponentBackRow(player);
            if (row !== opponentBackRow) return false;
            const zombie = board[row][col];
            if (!zombie || zombie.type !== 'Zombie') return false;
            cleanupNecromancerTracking(zombie);
            board[row][col] = null;
            awardZombieBonus(player, 'Zombie reached opponent back row');
            const spawnSuccess = spawnZombieAtBackRow(player, col);
            if (!spawnSuccess) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} zombie could not respawn due to lack of space.`);
            }
            return true;
        }

        function moveZombieTo(fromRow, fromCol, toRow, toCol, player) {
            const zombie = board[fromRow][fromCol];
            board[toRow][toCol] = zombie;
            board[fromRow][fromCol] = null;
            handleZombieReachedOpponentBackRow(player, toRow, toCol);
        }

        function attemptZombieCapture(fromRow, fromCol, targetRow, targetCol, player) {
            const zombie = board[fromRow][fromCol];
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece) {
                moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                return 'moved';
            }
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            if (targetPiece.type === 'Zombie') {
                const success = zombieCoinFlip({
                    title: 'Zombie Clash',
                    message: `${playerLabel} zombie challenges opposing Zombie.`
                });
                if (success) {
                    cleanupNecromancerTracking(targetPiece);
                    board[targetRow][targetCol] = null;
                    const spawnSuccess = zombieConversions[player] < 2 && spawnZombieAtBackRow(player);
                    if (spawnSuccess) {
                        zombieConversions[player]++;
                        gameLog.push(`${playerLabel} converted an opposing Zombie into their ranks.`);
                    } else if (zombieConversions[player] < 2) {
                        gameLog.push(`${playerLabel} destroyed an opposing Zombie but had no space to convert it.`);
                    } else {
                        gameLog.push(`${playerLabel} destroyed an opposing Zombie (conversion limit reached).`);
                    }
                    moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                    return 'moved';
                } else {
                    cleanupNecromancerTracking(zombie);
                    board[fromRow][fromCol] = null;
                    gameLog.push(`${playerLabel} zombie lost the clash against an opposing Zombie at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                    return 'removed';
                }
            }
            const success = zombieCoinFlip({
                title: 'Zombie Capture',
                message: `${playerLabel} zombie attacks ${targetPiece.type}.`
            });
            if (success) {
                capturePieceForZombie(player, targetRow, targetCol, targetPiece);
                moveZombieTo(fromRow, fromCol, targetRow, targetCol, player);
                return 'moved';
            } else {
                gameLog.push(`${playerLabel} zombie failed to capture ${targetPiece.type} at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                return 'stay';
            }
        }

        function handleZombieCaptureAttempt(attackerPiece, fromRow, fromCol, targetRow, targetCol, options = {}) {
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece || targetPiece.type !== 'Zombie') {
                return { handled: false };
            }
            if (attackerPiece.type === 'Elephantry') {
                gameLog.push(`${attackerPiece.player === 'W' ? 'Player' : 'AI'} Elephantry cannot capture Zombies by landing.`);
                return { handled: true, success: false, attackerRemoved: false };
            }
            if (attackerPiece.type === 'Huntsman') {
                cleanupNecromancerTracking(targetPiece);
                board[targetRow][targetCol] = null;
                capturedSquares.push([targetRow, targetCol]);
                recordGraveyardCapture(attackerPiece.player, targetPiece);
                const captureValue = pieceValues[targetPiece.type] || 0;
                scores[attackerPiece.player] += captureValue;
                registerScoreGain(attackerPiece.player, captureValue, true);
                registerPieceLoss(targetPiece.player, targetPiece.type);
                trackCapture(attackerPiece.player);
                gameLog.push(`${attackerPiece.player === 'W' ? 'Player' : 'AI'} Huntsman effortlessly captured Zombie at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateGameLog();
                return { handled: true, success: true };
            }
            const attackerLabel = attackerPiece.player === 'W' ? 'Player' : 'AI';
            const zombieOwner = targetPiece.player;
            const viaRanged = options.ranged;
            const attemptVerb = viaRanged ? 'shoot' : 'capture';
            const successVerb = viaRanged ? 'shot' : 'captured';
            const success = zombieCoinFlip({
                title: 'Zombie Defense',
                message: `${attackerLabel} ${viaRanged ? 'shoots at' : 'attacks'} Zombie.`
            });
            if (success) {
                cleanupNecromancerTracking(targetPiece);
                board[targetRow][targetCol] = null;
                capturedSquares.push([targetRow, targetCol]);
                recordGraveyardCapture(attackerPiece.player, targetPiece);
                const captureValue = pieceValues[targetPiece.type] || 0;
                scores[attackerPiece.player] += captureValue;
                registerScoreGain(attackerPiece.player, captureValue, true);
                registerPieceLoss(zombieOwner, targetPiece.type);
                trackCapture(attackerPiece.player); // Track capture for statistics
                gameLog.push(`${attackerLabel} ${successVerb} Zombie at ${formatBoardCoordinates(targetRow,targetCol)} after winning the coin flip.`);
                return { handled: true, success: true };
            } else {
                // For ranged/shooting attacks, the attacker stays on the board
                if (viaRanged) {
                    gameLog.push(`${attackerLabel} failed to ${attemptVerb} Zombie at ${formatBoardCoordinates(targetRow,targetCol)}. The shot missed and the attacker remains safe.`);
                    return { handled: true, success: false, attackerRemoved: false };
                } else {
                    // For landing captures, the attacker is captured by the zombie
                    board[fromRow][fromCol] = null;
                    cleanupNecromancerTracking(attackerPiece);
                    capturedSquares.push([fromRow, fromCol]);
                    recordGraveyardCapture(zombieOwner, attackerPiece);
                    registerPieceLoss(attackerPiece.player, attackerPiece.type);
                    scores[zombieOwner] += 3;
                    registerScoreGain(zombieOwner, 3);
                    trackCapture(zombieOwner); // Track capture for statistics
                    gameLog.push(`${attackerLabel} failed to ${attemptVerb} Zombie at ${formatBoardCoordinates(targetRow,targetCol)} and was lost in the attempt. (+3 bonus to ${zombieOwner === 'W' ? 'Player' : 'AI'})`);
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateGameLog();
                    return { handled: true, success: false, attackerRemoved: true };
                }
            }
        }

        function advanceZombieFromPosition(row, col, player) {
            const zombie = board[row][col];
            if (!zombie || zombie.type !== 'Zombie' || zombie.player !== player) return false;
            const direction = player === 'W' ? -1 : 1;
            if (handleZombieReachedOpponentBackRow(player, row, col)) {
                return true;
            }
            const forwardRow = row + direction;
            if (!isValid(forwardRow, col)) {
                if (handleZombieReachedOpponentBackRow(player, row, col)) {
                    return true;
                }
                return false;
            }
            const forwardPiece = board[forwardRow][col];
            if (!forwardPiece) {
                moveZombieTo(row, col, forwardRow, col, player);
                return true;
            }
            if (forwardPiece.type !== 'DarkVoid' && forwardPiece.player !== player) {
                const result = attemptZombieCapture(row, col, forwardRow, col, player);
                return result === 'moved' || result === 'removed';
            }
            const diagonals = [col - 1, col + 1];
            for (const diagCol of diagonals) {
                if (!isValid(forwardRow, diagCol)) continue;
                const diagPiece = board[forwardRow][diagCol];
                if (!diagPiece) {
                    moveZombieTo(row, col, forwardRow, diagCol, player);
                    return true;
                }
                if (diagPiece.type === 'DarkVoid') {
                    continue;
                }
                if (diagPiece.player !== player) {
                    const result = attemptZombieCapture(row, col, forwardRow, diagCol, player);
                    if (result === 'moved' || result === 'removed') {
                        return true;
                    }
                }
            }
            return false;
        }

        function advanceZombiesForPlayer(player, onComplete = null) {
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return false;
            }
            const positions = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.type === 'Zombie' && piece.player === player) {
                        positions.push({ row: r, col: c });
                    }
                }
            }
            if (!positions.length) {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return false;
            }
            if (zombieAutoAdvanceInProgress) {
                zombiePendingAdvanceQueue.push({ player, onComplete });
                return true;
            }
            positions.sort((a, b) => {
                if (a.col !== b.col) {
                    return a.col - b.col;
                }
                return player === 'W' ? a.row - b.row : b.row - a.row;
            });
            if (zombieAdvanceTimer) {
                clearTimeout(zombieAdvanceTimer);
                zombieAdvanceTimer = null;
            }
            zombieAutoAdvanceInProgress = true;
            let pendingUpdate = false;
            const completeAdvance = () => {
                if (zombieAdvanceTimer) {
                    clearTimeout(zombieAdvanceTimer);
                    zombieAdvanceTimer = null;
                }
                zombieAutoAdvanceInProgress = false;
                if (pendingUpdate) {
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                }
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                if (zombiePendingAdvanceQueue.length) {
                    const nextRequest = zombiePendingAdvanceQueue.shift();
                    zombieAdvanceTimer = setTimeout(() => advanceZombiesForPlayer(nextRequest.player, nextRequest.onComplete), 200);
                }
            };
            const processNextZombie = () => {
                if (!positions.length) {
                    completeAdvance();
                    return;
                }
                const pos = positions.shift();
                const piece = board[pos.row]?.[pos.col];
                if (!piece || piece.type !== 'Zombie' || piece.player !== player) {
                    processNextZombie();
                    return;
                }
                const moved = advanceZombieFromPosition(pos.row, pos.col, player);
                if (moved) {
                    pendingUpdate = true;
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                }
                zombieAdvanceTimer = setTimeout(processNextZombie, 280);
            };
            processNextZombie();
            return true;
        }

        function decrementNecromancerCooldown(player) {
            necromancerShootCooldown.forEach((turns, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                    return;
                }
                if (piece.player === player && turns > 0) {
                    const next = turns - 1;
                    if (next <= 0) {
                        necromancerShootCooldown.delete(piece);
                    } else {
                        necromancerShootCooldown.set(piece, next);
                    }
                }
            });
            necromancerTeleportCounts.forEach((_, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                }
            });
        }

        function decrementUndeadChampionCooldown(player) {
            undeadChampionRangedCooldown.forEach((turns, piece) => {
                if (!isPieceOnBoard(piece)) {
                    cleanupNecromancerTracking(piece);
                    return;
                }
                if (piece.player === player && turns > 0) {
                    const next = turns - 1;
                    if (next <= 0) {
                        undeadChampionRangedCooldown.delete(piece);
                    } else {
                        undeadChampionRangedCooldown.set(piece, next);
                    }
                }
            });
        }
        
        // AI Difficulty
        let aiDifficulty = 'Medium';
        let baseAiDepth = 53; // Track difficulty selection (defaults to Medium, increased by additional 20% intelligence)
        let aiMaxDepth = 53; // Effective depth after variant adjustments - allows AI to plan 3+ moves ahead
        let pieceValueScale = 12.9166202; // Defaults to Medium (increased by additional 10% difficulty)

        // Opponent Selection
        let selectedOpponent = 'Random'; // Default to random selection

        // Hint System
        let hintModeEnabled = false; // Default to off
        const AI_LEFTOVER_PENALTY = 0.75;
        const AI_TIE_EPSILON = 0.0001;
        const AI_TIME_LIMIT_DEFAULT = 5400; // Increased to 5400ms to give AI more thinking time (50% increase from 3600ms)
        const AI_TIME_LIMIT_LARGE = 1800; // Increased to 1800ms for large boards to give AI more thinking time (50% increase from 1200ms)

        // AI Player Profiles - Different strategies and play styles (invisible to player)
        const AI_PROFILES = {
            'Berserker': {
                name: 'Berserker',
                displayName: 'Ragnar the Berserker',
                description: 'Hyper-aggressive attacker, prioritizes captures above all else',
                threatWeight: 1.8,           // Heavily values threatening enemy pieces
                mobilityWeight: 0.25,        // Lower mobility concern
                centerWeight: 0.15,          // Lower center control concern
                captureBonus: 1.4,           // +40% bonus to capture values
                specialAbilityBonus: 1.6,    // Increased from 1.3 to encourage special abilities
                aggressionLevel: 1.5         // Highly aggressive
            },
            'Guardian': {
                name: 'Guardian',
                displayName: 'Thorne the Guardian',
                description: 'Defensive player, focuses on piece preservation and center control',
                threatWeight: 0.6,           // Lower threat priority
                mobilityWeight: 0.7,         // Values having options
                centerWeight: 0.6,           // Strongly values center control
                captureBonus: 0.8,           // -20% capture bonus (more cautious)
                specialAbilityBonus: 1.2,    // Increased from 0.9 to encourage special abilities
                aggressionLevel: 0.6         // Defensive playstyle
            },
            'Tactician': {
                name: 'Tactician',
                displayName: 'Astra the Tactician',
                description: 'Balanced strategist, adapts to board position',
                threatWeight: 1.0,           // Balanced threat evaluation
                mobilityWeight: 0.55,        // Moderate mobility value
                centerWeight: 0.35,          // Moderate center control
                captureBonus: 1.0,           // Normal capture values
                specialAbilityBonus: 1.4,    // Increased from 1.1 to encourage special abilities
                aggressionLevel: 1.0         // Balanced approach
            },
            'Sorcerer': {
                name: 'Sorcerer',
                displayName: 'Zephyr the Sorcerer',
                description: 'Special ability specialist, maximizes use of unique powers',
                threatWeight: 0.85,          // Moderate threat focus
                mobilityWeight: 0.6,         // Values positioning for abilities
                centerWeight: 0.25,          // Lower center concern
                captureBonus: 0.95,          // Slightly lower capture priority
                specialAbilityBonus: 2.1,    // Increased from 1.7 to strongly encourage special abilities
                aggressionLevel: 1.1         // Slightly aggressive
            },
            'Nomad': {
                name: 'Nomad',
                displayName: 'Kira the Nomad',
                description: 'Mobility-focused player, constantly repositioning for advantage',
                threatWeight: 0.75,          // Lower direct threat focus
                mobilityWeight: 0.85,        // Highly values movement options
                centerWeight: 0.4,           // Moderate center value
                captureBonus: 0.9,           // Slightly cautious on captures
                specialAbilityBonus: 1.3,    // Increased from 1.0 to encourage special abilities
                aggressionLevel: 0.85        // Moderately cautious, prefers mobility
            }
        };

        let lastRandomAiProfileName = null;

        function getRandomInt(max) {
            if (max <= 0) return 0;
            if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
                const array = new Uint32Array(1);
                crypto.getRandomValues(array);
                return array[0] % max;
            }
            return Math.floor(Math.random() * max);
        }

        function chooseRandomAiProfileName() {
            const profileNames = Object.keys(AI_PROFILES);
            if (!profileNames.length) return null;
            let index = getRandomInt(profileNames.length);
            let candidate = profileNames[index];
            if (profileNames.length > 1 && candidate === lastRandomAiProfileName) {
                const offset = 1 + getRandomInt(profileNames.length - 1);
                candidate = profileNames[(index + offset) % profileNames.length];
            }
            lastRandomAiProfileName = candidate;
            return candidate;
        }

        // AI Reaction Emoji System
        const AI_REACTION_EMOJIS = {
            'Berserker': {
                highCapture: ['', '', '', '', ''],
                mediumCapture: ['', '', '', ''],
                lowCapture: ['', ''],
                playerHighCapture: ['', '', '', ''],
                playerMediumCapture: ['', '', ''],
                neutral: ['', '', ''],
                winning: ['', '', '', ''],
                losing: ['', '', '']
            },
            'Guardian': {
                highCapture: ['', '', '', ''],
                mediumCapture: ['', '', ''],
                lowCapture: ['', ''],
                playerHighCapture: ['', '', '', ''],
                playerMediumCapture: ['', '', ''],
                neutral: ['', '', ''],
                winning: ['', '', ''],
                losing: ['', '', '']
            },
            'Tactician': {
                highCapture: ['', '', '', '', ''],
                mediumCapture: ['', '', ''],
                lowCapture: ['', ''],
                playerHighCapture: ['', '', '', ''],
                playerMediumCapture: ['', '', ''],
                neutral: ['', '', ''],
                winning: ['', '', ''],
                losing: ['', '', '']
            },
            'Sorcerer': {
                highCapture: ['', '', '', '', ''],
                mediumCapture: ['', '', ''],
                lowCapture: ['', ''],
                playerHighCapture: ['', '', '', ''],
                playerMediumCapture: ['', '', ''],
                neutral: ['', '', ''],
                winning: ['', '', ''],
                losing: ['', '', '']
            },
            'Nomad': {
                highCapture: ['', '', '', '', ''],
                mediumCapture: ['', '', ''],
                lowCapture: ['', ''],
                playerHighCapture: ['', '', '', ''],
                playerMediumCapture: ['', '', ''],
                neutral: ['', '', ''],
                winning: ['', '', ''],
                losing: ['', '', '']
            }
        };

        let lastEmojiTime = 0;
        const EMOJI_COOLDOWN = 1500; // Minimum time between emoji displays in ms

        function shouldShowEmoji(captureValue, isPlayerMove) {
            // Always show for high value captures (6+)
            if (captureValue >= 6) return true;

            // For medium captures (3-5), show 60% of the time
            if (captureValue >= 3) return Math.random() < 0.6;

            // For low captures (1-2), show 30% of the time
            if (captureValue >= 1) return Math.random() < 0.3;

            // For non-capture moves, show 15% of the time
            return Math.random() < 0.15;
        }

        function displayAiReactionEmoji(captureValue, isPlayerMove, scoreDifference) {
            // Check cooldown
            const now = Date.now();
            if (now - lastEmojiTime < EMOJI_COOLDOWN) return;

            // Determine if we should show an emoji
            if (!shouldShowEmoji(captureValue, isPlayerMove)) return;

            lastEmojiTime = now;

            const profile = currentAiProfile ? currentAiProfile.name : 'Tactician';
            const emojiSet = AI_REACTION_EMOJIS[profile] || AI_REACTION_EMOJIS['Tactician'];

            let emojiArray;

            if (isPlayerMove) {
                // Player made a move - AI reacts based on capture value
                if (captureValue >= 6) {
                    emojiArray = emojiSet.playerHighCapture;
                } else if (captureValue >= 3) {
                    emojiArray = emojiSet.playerMediumCapture;
                } else if (captureValue > 0) {
                    emojiArray = emojiSet.playerMediumCapture;
                } else {
                    // No capture by player - show neutral or winning/losing based on score
                    if (scoreDifference > 10) {
                        emojiArray = emojiSet.winning;
                    } else if (scoreDifference < -10) {
                        emojiArray = emojiSet.losing;
                    } else {
                        emojiArray = emojiSet.neutral;
                    }
                }
            } else {
                // AI made a move - show happy reactions
                if (captureValue >= 6) {
                    emojiArray = emojiSet.highCapture;
                } else if (captureValue >= 3) {
                    emojiArray = emojiSet.mediumCapture;
                } else if (captureValue > 0) {
                    emojiArray = emojiSet.lowCapture;
                } else {
                    emojiArray = emojiSet.neutral;
                }
            }

            // Select random emoji from array
            const emoji = emojiArray[Math.floor(Math.random() * emojiArray.length)];

            // Display the emoji in AI panel
            const emojiElement = document.getElementById('ai-reaction-emoji');
            if (emojiElement) {
                emojiElement.textContent = emoji;
                emojiElement.classList.remove('show');

                // Trigger reflow to restart animation
                void emojiElement.offsetWidth;

                emojiElement.classList.add('show');

                // Hide after 2 seconds
                setTimeout(() => {
                    emojiElement.classList.remove('show');
                }, 2000);
            }
        }

        function displayPlayerReactionEmoji(captureValue) {
            // Check cooldown
            const now = Date.now();
            if (now - lastEmojiTime < EMOJI_COOLDOWN) return;

            // Determine if we should show an emoji (AI celebrating their capture)
            if (!shouldShowEmoji(captureValue, false)) return;

            lastEmojiTime = now;

            // Player emojis when AI is doing well (inverse of AI emotions)
            const playerEmojiSets = {
                highCapture: ['', '', '', '', ''],
                mediumCapture: ['', '', '', ''],
                lowCapture: ['', '', ''],
                neutral: ['', '', '']
            };

            let emojiArray;

            if (captureValue >= 6) {
                emojiArray = playerEmojiSets.highCapture;
            } else if (captureValue >= 3) {
                emojiArray = playerEmojiSets.mediumCapture;
            } else if (captureValue > 0) {
                emojiArray = playerEmojiSets.lowCapture;
            } else {
                emojiArray = playerEmojiSets.neutral;
            }

            // Select random emoji from array
            const emoji = emojiArray[Math.floor(Math.random() * emojiArray.length)];

            // Display the emoji in player panel
            const emojiElement = document.getElementById('player-reaction-emoji');
            if (emojiElement) {
                emojiElement.textContent = emoji;
                emojiElement.classList.remove('show');

                // Trigger reflow to restart animation
                void emojiElement.offsetWidth;

                emojiElement.classList.add('show');

                // Hide after 2 seconds
                setTimeout(() => {
                    emojiElement.classList.remove('show');
                }, 2000);
            }
        }

        // Current AI profile (selected randomly at game start)
        let currentAiProfile = null;
        const LARGE_BOARD_VARIANTS = ['36s', '36s-expert', '36s-elite', '36s-supreme'];
        let aiSearchDeadline = 0;
        function aiTimeExpired() {
            return aiSearchDeadline && Date.now() >= aiSearchDeadline;
        }

        const pieceIcons = {
            'Cavalry': 'C', 'Troll': 'T', 'Dragon': 'D', 'Wizard': 'W', 'Guard': 'G',
            'King': 'K', 'Champion': '', 'Infantry': 'I', 'Archer': 'A', 'Ballista': 'B',
            'Elephantry': 'E', 'Mercenary': 'M', 'Ogre': 'O', 'Spectre': 'S', 'Pistolier': 'P', 'Fusilier': 'F',
            'Lich': 'L'
        };
        pieceIcons['Necromancer'] = 'N';
        pieceIcons['Zombie'] = 'Z';
        pieceIcons['Undead'] = 'U';
        pieceIcons['Undead3'] = 'U';
        pieceIcons['UndeadChampion'] = '';
        pieceIcons['Huntsman'] = 'H';
        const facingIcons = {
            'U': '^', 'D': 'v', 'L': '<', 'R': '>'
        };
        const basePieceValues = {
            'Infantry': 1, 'Archer': 2, 'Cavalry': 3, 'Pistolier': 3, 'Fusilier': 4, 'Guard': 4, 'Ballista': 5,
            'Troll': 6, 'Dragon': 7, 'Ogre': 8, 'Wizard': 9, 'Spectre': 5, 'Mercenary': 3,
            'Elephantry': 11, 'Champion': 12, 'King': 13, 'Lich': 11
        };
        // Force the Mercenary value to 3 so AI evaluations match the desired scoring.
        basePieceValues['Mercenary'] = 3;
        basePieceValues['Necromancer'] = 10;
        basePieceValues['Zombie'] = 3;
        basePieceValues['Undead'] = 4;
        basePieceValues['Undead3'] = 4;
        basePieceValues['UndeadChampion'] = 10;
        basePieceValues['Huntsman'] = 6;
        basePieceValues['DarkVoid'] = 0;
        const pieceValues = basePieceValues;
        let aiPieceValues = { ...basePieceValues };

        function isLargeBoardVariant() {
            return LARGE_BOARD_VARIANTS.includes(gameVariant);
        }

        function getAiTimeBudget() {
            let base = isLargeBoardVariant() ? AI_TIME_LIMIT_LARGE : AI_TIME_LIMIT_DEFAULT;
            if (aiDifficulty === 'Hard') {
                base += isLargeBoardVariant() ? 1200 : 3600; // Increased significantly for depth 91 planning: allows extensive multi-move lookahead (doubled from 600/1800)
            } else if (aiDifficulty === 'Medium') {
                base += isLargeBoardVariant() ? 800 : 2400; // Increased significantly for depth 53 planning: allows deeper tactical analysis (doubled from 400/1200)
            } else if (aiDifficulty === 'Easy') {
                base += isLargeBoardVariant() ? 400 : 1200; // Increased for depth 25 planning: allows better 3+ move lookahead (doubled from 200/600)
            }
            return base;
        }

        const GAME_TIME_OPTIONS = {
            quick: 10 * 60,
            standard: 30 * 60,
            long: 60 * 60
        };
        const TURN_TIME_OPTIONS = {
            blitz: 30,
            standard: 60
        };
        let selectedGameTimerKey = 'standard';
        let selectedTurnTimerKey = 'standard';
        let gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
        let gameTimerInterval = null;
        let turnTimerInterval = null;
        let playerTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
        let aiTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
        let currentTurnTimerPlayer = null;
        let aiTurnTimeoutForced = false;
        let roundCount = 1; // Initialize round counter early for timer display
        let playerRoundNumber = 0; // Track player's round count (for first 2 rounds features)
        let aiRoundNumber = 0; // Track AI's round count (for first 2 rounds features)
        let gameRound = 1; // Track game rounds (both players taking 1 round = 1 complete round)
        let firstPlayer = null; // Track who went first to properly count rounds

        const HONOUR_THRESHOLD = 10;
        const HONOUR_BONUS = 2;
        const DESPAIR_PENALTY = 2;
        const DESPAIR_EXCLUDED = new Set(['Mercenary', 'Infantry', 'Archer']);
        const RELENTLESS_THRESHOLD = 3;
        const KING_SHOT_RANGE = 3;
        const LICH_SOULSTRIDE_THRESHOLD = 2;
        const LICH_SUMMON_LIMIT = 1;
        const LICH_SUMMON_SOUL_THRESHOLD = 1;
        const LICH_SOUL_BLAST_COST = 2;
        const LICH_SOUL_BLAST_SOULS_PER_RANGE = 3;
        const LICH_SOUL_BLAST_MAX_RANGE = 5;
        const LICH_CAPTURE_AUTO_TYPES = new Set(['Wizard', 'Necromancer', 'Spectre']);
        const UNDEAD_SUMMON_LIMIT = 2;
        const UNDEAD_SUMMON_COST = 2;
        const UNDEAD_LIVES_BY_SUMMONER = { 'Necromancer': 2, 'Lich': 2 };
        const UNDEAD_TYPES = new Set(['Undead']);
        const UNDEAD_CHAMPION_SUMMON_LIMIT = 1;
        const UNDEAD_CHAMPION_TELEPORT_RANGE = 3;
        const KING_EVADE_RANGE = 2;
        const KING_SHOT_AI_THRESHOLD = 5; // Minimum target value before AI considers King Shot
        const KING_EVADE_CAPTURE_BONUS = 6; // Weight applied to captured piece value when evading
        const KING_EVADE_DISTANCE_BONUS = 1; // Small reward for creating distance while evading
        const WARCRY_POPUP_DELAY_MS = 200; // Base delay before showing warcry popup
        const CAPTURE_EFFECT_SETTLE_MS = 2000; // Allow capture animation to finish before warcry popup
        const BOARD_ANCHORED_MODAL_IDS = [
            'modal-overlay',
            'reinforce-modal',
            'spell-direction-modal',
            'protection-modal',
            'turn-modal',
            'turn-move-modal',
            'turn-shoot-modal',
            'how-to-play-modal',
            'truce-modal',
            'coin-toss-modal',
            'warcry-achievement-modal',
            'energy-blast-popup',
            'game-stats-modal'
        ];
        let boardModalObservers = [];
        let boardAnchorUpdateScheduled = false;
        let boardResizeObserver = null;

        let roundScoreGain = { 'W': 0, 'B': 0 };
        let roundCaptureValue = { 'W': 0, 'B': 0 }; // Track captures-only for warcry
        let roundLosses = { 'W': {}, 'B': {} };
        let nextRoundModifier = { 'W': 0, 'B': 0 };
        let warcryAchievedThisRound = { 'W': false, 'B': false };
        let pendingWarcryCelebrations = [];
        let warcryPopupTimeoutId = null;
        let captureEffectActiveUntil = 0;
        let reinforcementTotals = { 'W': 0, 'B': 0 };
        let infantryReinforcements = { 'W': 0, 'B': 0 };

        function getBoardAnchorRect() {
            const boardElement = document.getElementById('board');
            if (!boardElement) return null;
            const rect = boardElement.getBoundingClientRect();
            const scrollX = window.scrollX || window.pageXOffset || 0;
            const scrollY = window.scrollY || window.pageYOffset || 0;
            return {
                left: rect.left + scrollX,
                top: rect.top + scrollY,
                width: rect.width,
                height: rect.height,
                centerX: rect.left + scrollX + rect.width / 2,
                centerY: rect.top + scrollY + rect.height / 2
            };
        }

        function updateBoardAnchoredElements() {
            const anchor = getBoardAnchorRect();
            if (!anchor) {
                updateSidePanelScrollLimits(null);
                return;
            }
            BOARD_ANCHORED_MODAL_IDS.forEach(id => {
                const el = document.getElementById(id);
                if (!el || getComputedStyle(el).display === 'none') {
                    return;
                }
                if (id === 'modal-overlay') {
                    el.style.left = `${anchor.left}px`;
                    el.style.top = `${anchor.top}px`;
                    el.style.width = `${anchor.width}px`;
                    el.style.height = `${anchor.height}px`;
                } else {
                    el.style.left = `${anchor.centerX}px`;
                    el.style.top = `${anchor.centerY}px`;
                    el.style.transform = 'translate(-50%, -50%)';
                }
            });
            updateSidePanelScrollLimits(anchor);
            constrainSidePanelsToBoard(anchor);
        }

        function scheduleBoardAnchorUpdate() {
            if (boardAnchorUpdateScheduled) return;
            boardAnchorUpdateScheduled = true;
            requestAnimationFrame(() => {
                boardAnchorUpdateScheduled = false;
                updateBoardAnchoredElements();
            });
        }

        function initializeBoardAnchoredModals() {
            const boardElement = document.getElementById('board');
            if (typeof ResizeObserver !== 'undefined' && boardElement) {
                boardResizeObserver = new ResizeObserver(() => scheduleBoardAnchorUpdate());
                boardResizeObserver.observe(boardElement);
            }
            window.addEventListener('scroll', () => scheduleBoardAnchorUpdate());
            window.addEventListener('resize', () => scheduleBoardAnchorUpdate());
            if (typeof MutationObserver !== 'undefined') {
                BOARD_ANCHORED_MODAL_IDS.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const observer = new MutationObserver(() => scheduleBoardAnchorUpdate());
                    observer.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });
                    boardModalObservers.push(observer);
                });
            }
            scheduleBoardAnchorUpdate();
        }

        function updateSidePanelScrollLimits(anchorRect) {
            const root = document.documentElement;
            if (anchorRect) {
                root.style.setProperty('--board-panel-max-height', `${anchorRect.height}px`);
            } else {
                root.style.removeProperty('--board-panel-max-height');
            }
        }

        function constrainSidePanelsToBoard(anchorRect) {
            ['info-box', 'captured-pieces'].forEach(id => {
                const element = document.getElementById(id);
                constrainElementToBoardBounds(element, anchorRect);
            });
        }

        function constrainElementToBoardBounds(element, anchorRect) {
            if (!element || !anchorRect) return;
            const style = window.getComputedStyle(element);
            if (style.display === 'none') return;
            const rect = element.getBoundingClientRect();
            const scrollY = window.scrollY || window.pageYOffset || 0;
            const elementTop = rect.top + scrollY;
            const available = anchorRect.top + anchorRect.height - elementTop - 10;
            if (available >= 0) {
                element.style.maxHeight = `${available}px`;
            } else {
                element.style.maxHeight = '0px';
            }
        }

        // Game statistics tracking
        let gameStats = {
            warcryBonusCount: { 'W': 0, 'B': 0 },
            despairPenaltyCount: { 'W': 0, 'B': 0 },
            gameStartTime: null,
            gameDuration: 0,
            // New statistics for end game display
            capturesThisRound: { 'W': 0, 'B': 0 },
            mostCapturesInRound: { 'W': 0, 'B': 0 },
            scoreThisRound: { 'W': 0, 'B': 0 },
            highestScoreInRound: { 'W': 0, 'B': 0 },
            summonCount: { 'W': 0, 'B': 0 },
            reinforcementCount: { 'W': 0, 'B': 0 }
        };

        // Helper functions for tracking statistics
        function trackCapture(player) {
            gameStats.capturesThisRound[player]++;
        }

        function trackScore(player, scoreGain) {
            gameStats.scoreThisRound[player] += scoreGain;
        }

        function updateRoundStats(player) {
            // Update max captures if this round had more
            if (gameStats.capturesThisRound[player] > gameStats.mostCapturesInRound[player]) {
                gameStats.mostCapturesInRound[player] = gameStats.capturesThisRound[player];
            }
            // Update max score if this round had more
            if (gameStats.scoreThisRound[player] > gameStats.highestScoreInRound[player]) {
                gameStats.highestScoreInRound[player] = gameStats.scoreThisRound[player];
            }
            // Reset for next round
            gameStats.capturesThisRound[player] = 0;
            gameStats.scoreThisRound[player] = 0;
        }

        function sanitizePlayerName(name) {
            const trimmed = (name || '').trim();
            if (!trimmed) {
                return 'Player';
            }
            return trimmed.slice(0, MAX_PLAYER_NAME_LENGTH);
        }

        function persistPlayerName(name) {
            if (typeof localStorage === 'undefined') return;
            try {
                localStorage.setItem(PLAYER_NAME_STORAGE_KEY, name);
            } catch (error) {
                console.warn('Unable to persist player name', error);
            }
        }

        function loadStoredPlayerName() {
            if (typeof localStorage === 'undefined') return null;
            try {
                return localStorage.getItem(PLAYER_NAME_STORAGE_KEY);
            } catch (error) {
                return null;
            }
        }

        function setPlayerDisplayName(name, persist = true) {
            const sanitized = sanitizePlayerName(name);
            playerDisplayName = sanitized;
            const playerLabel = document.getElementById('player-name-label');
            if (playerLabel) {
                playerLabel.textContent = sanitized;
            }
            const statsNameLabel = document.getElementById('stats-player-name');
            if (statsNameLabel) {
                statsNameLabel.textContent = sanitized;
            }
            if (persist) {
                persistPlayerName(sanitized);
            }
        }

        function getStoredHighScores() {
            if (typeof localStorage === 'undefined') return [];
            try {
                const stored = localStorage.getItem(HIGH_SCORE_STORAGE_KEY);
                if (!stored) {
                    return [];
                }
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    return parsed;
                }
            } catch (error) {
                console.warn('Unable to load high scores', error);
            }
            return [];
        }

        function saveHighScores() {
            if (typeof localStorage === 'undefined') return;
            try {
                localStorage.setItem(HIGH_SCORE_STORAGE_KEY, JSON.stringify(localHighScores));
            } catch (error) {
                console.warn('Unable to save high scores', error);
            }
        }

        function renderHighScores() {
            const list = document.getElementById('high-score-list');
            if (!list) return;
            list.innerHTML = '';
            if (!localHighScores.length) {
                const emptyItem = document.createElement('li');
                emptyItem.className = 'empty';
                emptyItem.textContent = 'No scores recorded yet.';
                list.appendChild(emptyItem);
                return;
            }
            localHighScores.forEach((entry, index) => {
                const row = document.createElement('li');
                const scoreText = typeof entry.score === 'number'
                    ? entry.score.toLocaleString('en-US')
                    : entry.score;
                row.innerHTML = `<span class="rank">${index + 1}.</span><span class="entry-name">${entry.name}</span><span class="entry-score">${scoreText}</span>`;
                list.appendChild(row);
            });
        }

        function loadHighScores() {
            localHighScores = getStoredHighScores().filter(entry => (
                entry && entry.name && typeof entry.score === 'number'
            ));
            localHighScores.sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                return (a.timestamp || 0) - (b.timestamp || 0);
            });
            localHighScores = localHighScores.slice(0, MAX_HIGH_SCORE_ENTRIES);
            renderHighScores();
        }

        function addHighScoreEntry(name, score) {
            const numericScore = Number(score);
            if (Number.isNaN(numericScore)) {
                return;
            }
            localHighScores.push({
                name: sanitizePlayerName(name),
                score: numericScore,
                timestamp: Date.now()
            });
            localHighScores.sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                return (a.timestamp || 0) - (b.timestamp || 0);
            });
            localHighScores = localHighScores.slice(0, MAX_HIGH_SCORE_ENTRIES);
            saveHighScores();
            renderHighScores();
        }

        function clearHighScores() {
            localHighScores = [];
            saveHighScores();
            renderHighScores();
        }

        function initializeHighScoreSystem() {
            const storedName = loadStoredPlayerName();
            const nameToUse = (storedName || '').trim();
            const nameInput = document.getElementById('player-name-input');
            if (nameInput) {
                const inputValue = nameToUse && nameToUse !== 'Player' ? nameToUse : '';
                nameInput.value = inputValue;
                nameInput.addEventListener('input', () => setPlayerDisplayName(nameInput.value));
                nameInput.addEventListener('change', () => setPlayerDisplayName(nameInput.value));
            }
            setPlayerDisplayName(nameToUse || 'Player', false);
            loadHighScores();
        }

        function updateAiPieceValues() {
            aiPieceValues = Object.fromEntries(Object.entries(basePieceValues).map(([k, v]) => [k, Math.round(v * pieceValueScale)]));
        }

        updateAiPieceValues();
        function setGameTimer(option, element) {
            selectedGameTimerKey = option;
            gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
            const buttons = document.querySelectorAll('#game-timer-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-option'));
            if (element) {
                element.classList.add('selected-option');
            }
            updateTimerDisplay();
        }

        function setTurnTimer(option, element) {
            selectedTurnTimerKey = option;
            const duration = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            playerTurnTimeRemaining = duration;
            aiTurnTimeRemaining = duration;
            const buttons = document.querySelectorAll('#turn-timer-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-option'));
            if (element) {
                element.classList.add('selected-option');
            }
            updateTimerDisplay();
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            const gameTimerRow = document.getElementById('game-timer-row');
            const playerTimerRow = document.getElementById('player-timer-row');
            const aiTimerRow = document.getElementById('ai-timer-row');
            const roundDisplay = document.getElementById('round-number-display');
            const board = document.getElementById('board');
            const opponentLabel = getOpponentDisplayName();

            if (gameTimerRow) {
                gameTimerRow.textContent = `Game Time: ${formatTime(Math.max(0, gameTimeRemaining))}`;
            }
            if (roundDisplay) {
                roundDisplay.textContent = `Round ${roundCount}`;
            }

            // Update player timer with warning color
            if (playerTimerRow) {
                playerTimerRow.textContent = `Player Time: ${formatTime(Math.max(0, playerTurnTimeRemaining))}`;
                if (playerTurnTimeRemaining <= 10 && playerTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'W') {
                    playerTimerRow.classList.add('low-time');
                } else {
                    playerTimerRow.classList.remove('low-time');
                }
            }

            // Update AI timer with warning color
            if (aiTimerRow) {
                aiTimerRow.textContent = `${opponentLabel} Time: ${formatTime(Math.max(0, aiTurnTimeRemaining))}`;
                if (aiTurnTimeRemaining <= 10 && aiTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'B') {
                    aiTimerRow.classList.add('low-time');
                } else {
                    aiTimerRow.classList.remove('low-time');
                }
            }

            // Update board border color based on active timer
            if (board) {
                const isPlayerTimerLow = playerTurnTimeRemaining <= 10 && playerTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'W';
                const isAiTimerLow = aiTurnTimeRemaining <= 10 && aiTurnTimeRemaining > 0 && currentTurnTimerPlayer === 'B';

                if (isPlayerTimerLow || isAiTimerLow) {
                    board.classList.add('low-time');
                } else {
                    board.classList.remove('low-time');
                }
            }
        }

        function stopGameTimer() {
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
                gameTimerInterval = null;
            }
        }

        function startGameTimer() {
            stopGameTimer();
            // Record game start time
            if (gameStats.gameStartTime === null) {
                gameStats.gameStartTime = Date.now();
            }
            gameTimerInterval = setInterval(() => {
                if (gameTimeRemaining > 0) {
                    gameTimeRemaining -= 1;
                    updateTimerDisplay();
                    if (gameTimeRemaining <= 0) {
                        gameTimeRemaining = 0;
                        updateTimerDisplay();
                        stopGameTimer();
                        handleGameTimerExpired();
                    }
                }
            }, 1000);
        }

        function handleGameTimerExpired() {
            gameLog.push('Game timer expired.');
            updateGameLog();
            stopTurnTimer();
            const playerScore = scores['W'];
            const aiScore = scores['B'];
            if (playerScore > aiScore) {
                endGame('W', 'Game timer expired.');
            } else if (aiScore > playerScore) {
                endGame('B', 'Game timer expired.');
            } else {
                endGame('draw', 'Game timer expired.');
            }
        }

        function stopTurnTimer() {
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }
            currentTurnTimerPlayer = null;
        }

        function startTurnTimer(player, options = {}) {
            const { reset = true } = options;
            stopTurnTimer();
            currentTurnTimerPlayer = player;
            if (reset) {
                const duration = TURN_TIME_OPTIONS[selectedTurnTimerKey];
                if (player === 'W') {
                    playerTurnTimeRemaining = duration;
                } else {
                    aiTurnTimeRemaining = duration;
                }
            } else {
                const remaining = player === 'W' ? playerTurnTimeRemaining : aiTurnTimeRemaining;
                if (!remaining || remaining <= 0) {
                    currentTurnTimerPlayer = null;
                    return;
                }
            }
            updateTimerDisplay();
            turnTimerInterval = setInterval(() => {
                if (currentTurnTimerPlayer === 'W') {
                    playerTurnTimeRemaining = Math.max(0, playerTurnTimeRemaining - 1);
                    updateTimerDisplay();
                    if (playerTurnTimeRemaining === 0) {
                        stopTurnTimer();
                        handleTurnTimeout('W');
                    }
                } else if (currentTurnTimerPlayer === 'B') {
                    aiTurnTimeRemaining = Math.max(0, aiTurnTimeRemaining - 1);
                    updateTimerDisplay();
                    if (aiTurnTimeRemaining === 0) {
                        stopTurnTimer();
                        handleTurnTimeout('B');
                    }
                }
            }, 1000);
        }

        function handleTurnTimeout(player) {
            if (player === 'W') {
                playerTurnTimeRemaining = 0;
            } else {
                aiTurnTimeRemaining = 0;
            }
            updateTimerDisplay();
            if (player === 'W') {
                gameLog.push('Player round timer expired. Round forfeited.');
                cancelSpecialModes();
                if (reinforcementPending && reinforcementPending.player === 'W') {
                    reinforcementPending = null;
                    const modal = document.getElementById('reinforce-modal');
                    if (modal) modal.style.display = 'none';
                }
                movesLeft = 0;
                updateGameLog();
                updateStatus();
                updateEndTurnButton();
                triggerAiTurn();
            } else {
                aiTurnTimeoutForced = true;
                movesLeft = 0;
                completeAiTurn({ reason: 'AI round timer expired. Player resumes round.' });
            }
        }

        updateTimerDisplay();

        function getOpponent(player) {
            return player === 'W' ? 'B' : 'W';
        }

        function isAiPlayer(player) {
            return player === 'B';
        }

        function registerScoreGain(player, amount, isCapture = false) {
            const previousScore = roundScoreGain[player] || 0;
            roundScoreGain[player] = previousScore + amount;
            const newScore = roundScoreGain[player];

            // Track captures separately for warcry
            if (isCapture) {
                const previousCaptureValue = roundCaptureValue[player] || 0;
                roundCaptureValue[player] = previousCaptureValue + amount;
                const newCaptureValue = roundCaptureValue[player];

                // Check if warcry threshold was just reached (only from captures)
                if (previousCaptureValue < HONOUR_THRESHOLD && newCaptureValue >= HONOUR_THRESHOLD && !warcryAchievedThisRound[player]) {
                    warcryAchievedThisRound[player] = true;
                    queueWarcryCelebration(player);
                }
            }

            // Track score for statistics
            trackScore(player, amount);
        }

        function queueWarcryCelebration(player) {
            pendingWarcryCelebrations.push(player);
            if (pendingWarcryCelebrations.length === 1) {
                scheduleNextWarcryPopup();
            }
        }

        function scheduleNextWarcryPopup() {
            if (!pendingWarcryCelebrations.length) {
                if (warcryPopupTimeoutId) {
                    clearTimeout(warcryPopupTimeoutId);
                    warcryPopupTimeoutId = null;
                }
                return;
            }
            if (warcryPopupTimeoutId) {
                clearTimeout(warcryPopupTimeoutId);
            }
            const now = Date.now();
            const captureDelay = Math.max(0, captureEffectActiveUntil - now);
            const delay = Math.max(WARCRY_POPUP_DELAY_MS, captureDelay);
            warcryPopupTimeoutId = setTimeout(() => {
                warcryPopupTimeoutId = null;
                const nextPlayer = pendingWarcryCelebrations.shift();
                if (nextPlayer === undefined) {
                    scheduleNextWarcryPopup();
                    return;
                }
                if (captureEffectActiveUntil > Date.now()) {
                    pendingWarcryCelebrations.unshift(nextPlayer);
                    scheduleNextWarcryPopup();
                    return;
                }
                showWarcryAchievementPopup(nextPlayer);
                if (pendingWarcryCelebrations.length) {
                    scheduleNextWarcryPopup();
                }
            }, delay);
        }

        function registerPieceLoss(player, type) {
            if (type === 'Huntsman') {
                huntsmenOnBoard[player] = Math.max(0, (huntsmenOnBoard[player] || 0) - 1);
            }
            if (DESPAIR_EXCLUDED.has(type)) return;
            if (!roundLosses[player]) roundLosses[player] = {};
            roundLosses[player][type] = (roundLosses[player][type] || 0) + 1;
        }

        function registerReinforcement(player, type) {
            reinforcementTotals[player] = (reinforcementTotals[player] || 0) + 1;
            gameStats.reinforcementCount[player]++; // Track reinforcement for statistics
            if (type !== 'Infantry') {
                return false;
            }
            infantryReinforcements[player] = (infantryReinforcements[player] || 0) + 1;
            const opponent = getOpponent(player);
            if (infantryReinforcements[player] >= RELENTLESS_THRESHOLD && (reinforcementTotals[opponent] || 0) === 0) {
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} achieved Relentless victory!`);
                updateGameLog();
                endGame(player, 'Relentless');
                return true;
            }
            return false;
        }

        function isSupremacyPosition(player) {
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            if (championsOnBackRow[player] && championsOnBackRow[player].some(([r]) => r === opponentBackRow)) {
                return true;
            }
            for (let c = 0; c < COLS; c++) {
                if (board[opponentBackRow] && board[opponentBackRow][c] && board[opponentBackRow][c].player === player && board[opponentBackRow][c].type === 'King') {
                    return true;
                }
            }
            return false;
        }

        function checkSupremacy(player) {
            const opponent = getOpponent(player);
            if (!championCaptured[opponent]) return;
            if (scores[opponent] > 1) return;
            if (!isSupremacyPosition(player)) return;
            gameLog.push(`${player === 'W' ? 'Player' : 'AI'} achieved Supremacy victory!`);
            updateGameLog();
            endGame(player);
        }

        const pieceInfo = {
            'Archer': {
                points: '1 point to move 1 square vertically/horizontally, shoot 2 squares in facing direction, or turn; 2 points to turn+shoot or use a special.',
                extra: 'Specials: Move then shoot diagonally 1 square (2 uses per game); or shoot diagonally 2 squares without moving (2 uses per game). Can turn 90 left or right per action.'
            },
            'Ballista': {
                points: '1 point to move 1 square vertically/horizontally or shoot 3 (or 4 with Extend Range) squares based on facing; 2 points to turn or activate specials.',
                extra: 'Specials: Extend Range (+1 shoot range this round, 2 points, once per round); Double Time (move +1 extra square, 2 points, 2 uses per game). Shoots without moving. Can turn 90 left or right per action.'
            },
            'Cavalry': {
                points: '1 point to move up to 5 squares vertically or horizontally. Special Moves: Charge - once per game, move unlimited squares horizontally or vertically for 2 move points; Diagonal Rush - on rounds 1 and 2 only, move up to 3 squares diagonally for 2 move points.',
                extra: 'Stops at the first piece in its path.'
            },
            'Champion': {
                points: '1 point to move 1 square in any direction; 2 points for 2 squares in any direction.',
                extra: 'Cannot move through own pieces. Reduces opponents move points by 1 when on their back row. Can activate reinforcements.'
            },
            'Dragon': {
                points: '1 point to move 1 square diagonally or jump 2 squares diagonally + 1 square in any diagonal direction. Special Moves: Inferno - once per game, move 1 square in any direction for 2 move points, capturing all adjacent opponent pieces (except Dragons); Strafe - twice per game, move 1 square horizontally or vertically for 2 move points (cannot capture).',
                extra: 'Can change diagonal direction after 2-square jump.'
            },
            'Elephantry': {
                points: '1 point to move 1 square any direction, shoot 1 square, or turn; 2 points to move+shoot.',
                extra: 'Special Moves: Charge - once per piece per game, move forward (straight or diagonal) 3 squares, capturing anything except Spectre; stops on Elephantry/Ogre/Troll/Dragon. Triple Shot - 2 points for 3 shots at 2-square range with coin flip each (stays in position, can retarget). Can turn 90 left or right per action.'
            },
            'Fusilier': {
                points: '1 point to move 2 squares diagonally or shoot forward/diagonally up to 3 squares. Cannot move and shoot in same round.',
                extra: 'Can move through own pieces. After shooting, cannot shoot next round (can still move). Only captures by shooting. Special Moves: Crack Shot - increase range by +1 for next shot (2 points, 3 uses per piece; success determined by coin flip); Strafe - move 1 square vertically/horizontally without capturing (2 points, 2 uses per piece).'
            },
            'Guard': {
                points: '1 point to move 1 square in any direction.',
                extra: 'Versatile movement in all directions.'
            },
            'Infantry': {
                points: '1 point to move 1 square forward or diagonally forward; 1 point to turn.',
                extra: 'Round 1 only: can move up to 3 squares forward. Turn (1 point) or Turn and Move (2 points) via buttons. Both finalize action. Cannot move then turn. Can turn 90 left or right per action.'
            },
            'King': {
                points: '1 point to move 1 square vertically or horizontally.',
                extra: 'Cannot move into check. Capture ends the game. Can activate reinforcements. Special Move: Guard of Honour - once per game, swap positions with an adjacent Guard for 2 move points.'
            },
            'Lich': {
                points: '1 point to move 1 square in any direction; unlocks a 2-square Soulstride in the same line once you have captured 2+ enemy pieces (graveyard power).',
                extra: 'Soulstride requires the midpoint square to be empty and still costs 1 move point. Soul Blast spends 2 move points plus a coin flip to fire along any clear straight/diagonal line, reaching 1 square per 3 captured enemy souls (max 5). Liches shrug off Inferno, Energy Blast, and Sacrifice, and only Wizards, Necromancers, or Spectres capture them without a coin flip.'
            },
            'Undead': {
                points: '1 point to move 1 square diagonally; 2 points to strafe horizontally or vertically.',
                extra: 'Summoned by Necromancers or Liches adjacent to Dark Void tiles. Displays 2 lives (Necromancer summon) or 3 lives (Lich summon) as hearts in the info panel. Every capture attempt and every attack against it requires a coin flip; failed captures leave it rooted while failed attacks send the attacker to the graveyard.'
            },
            'UndeadChampion': {
                points: '1 point to move 1 square in any direction; 2 points for ranged attack up to 2 squares away (1-round cooldown); 2 points to teleport up to 3 squares (once per game).',
                extra: 'Summoned by Liches adjacent to Dark Void tiles. Maximum 1 per player per game. Has 2 lives displayed as hearts. Ranged attack can target enemies 2 squares away in any direction. Every capture attempt and every attack against it requires a coin flip; failed captures leave it rooted while failed attacks send the attacker to the graveyard.'
            },
            'Mercenary': {
                points: '1 point to move 1 square in any direction; 2 points for 2 squares in any direction.',
                extra: 'Can move or capture in any direction. Special Move: After a successful capture, triggers a coin flip - if successful, the mercenary continues its round instantly without move point costs (once per round).'
            },
            'Necromancer': {
                points: '1 point to move 1 square in any direction. Special actions cost 2 points: summon Zombie or Spectre (coin flip) or channel a 2-range shot.',
                extra: 'Max 2 per player, arrives via Champion summoning. Shoots require a 1-round cooldown and always resolve captures with coin flips. Teleport twice per game. Can summon Zombies, Spectres, andafter capturing enough soulsa single Lich onto the back row (all via coin flips).'
            },
            'Huntsman': {
                points: '1 point to move 1 square in any direction.',
                extra: '36s (Supreme) exclusive. Special Move: Stalking Burst (2 move points) performs 4 coin flipseach success grants 1 chained step of movement (up to 4) that round. Huntsmen require a coin flip to be captured by shooting, but automatically capture Zombies without coin flips.'
            },
            'Ogre': {
                points: '1 point to move 1 square vertically/horizontally or jump 1 square in any direction.',
                extra: 'Captures by jumping over or landing. Cannot jump over other Ogres. Special Move: Rage (2 points, once per game) rushes 2 squares straight and captures every enemy inside the 2x3 corridor it sweeps.'
            },
            'Pistolier': {
                points: '1 point to move diagonally up to 3 squares or shoot diagonally up to 2 squares; 2 points to move+shoot (1 square shoot range).',
                extra: 'Capturing by landing (not shooting) requires coin flip (50/50). Does not turn - shoots and moves diagonally only.'
            },
            'Spectre': {
                points: '1 point to move in knight-diagonal pattern (2 diagonal + 1 perpendicular). Summoned by Wizard.',
                extra: 'Can move through all pieces. Capturing requires 50/50 coin toss (except vs Wizards/Spectres). Cannot trigger reinforcements. Max 2 per player.'
            },
            'Troll': {
                points: '1 point to move up to 2 squares vertically/horizontally or 1 square diagonally; +1 point for 1 extra square in same vertical/horizontal direction (total 2 points).',
                extra: 'On first round, can move up to 4 squares vertically/horizontally or 2 squares diagonally at normal cost. No extra move on first round.'
            },
            'Wizard': {
                points: '1 point to move up to 4 squares diagonally; 2 points to move up to 5 squares and/or through own pieces. Special Moves: Teleport - twice per game, move to any unoccupied square of the same color for 2 move points; Teleport Swap - once per game, swap with an opponent Wizard on the same color square for 2 move points; Strafe - twice per game, move 1 square horizontally or vertically for 2 move points (cannot capture); Summon Spectre - twice per game, costs 2 points, requires 5+ captured pieces, 50/50 chance, wizard cannot move next round.',
                extra: 'Cannot move through opponent pieces.'
            },
            'Zombie': {
                points: 'Automatically shambles forward each round without spending move points.',
                extra: 'Summoned to the back row. Moves forward, attempting diagonal detours if blocked, and resolves captures (including defending) via coin flip. Converts opposing Zombies on successful clashes.'
            }
        };
        const turnablePieces = ['Archer', 'Ballista', 'Elephantry', 'Fusilier', 'Infantry'];
        const turnCosts = {
            'Archer': 1,
            'Ballista': 2,
            'Elephantry': 1,
            'Fusilier': 1,
            'Infantry': 1
        };
        const DARK_VOID_COST = 2;
        const DARK_VOID_USE_LIMIT = 2;
        const DARK_VOID_TRAVELERS = new Set(['Dragon', 'Necromancer', 'Lich', 'Spectre']);

        function darkVoidKey(row, col) {
            return `${row},${col}`;
        }

        function isDarkVoidSquare(row, col) {
            return darkVoidSquares.has(darkVoidKey(row, col));
        }
        function isUndeadType(value) {
            if (!value) return false;
            const type = typeof value === 'string' ? value : value.type;
            return UNDEAD_TYPES.has(type);
        }
        function isUndeadChampionType(value) {
            if (!value) return false;
            const type = typeof value === 'string' ? value : value.type;
            return type === 'UndeadChampion';
        }
        function requiresCoinFlipCapture(value) {
            if (!value) return false;
            const type = typeof value === 'string' ? value : value.type;
            return UNDEAD_TYPES.has(type) || type === 'UndeadChampion';
        }
        function isAdjacentToDarkVoid(row, col) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = row + dr;
                    const nc = col + dc;
                    if (darkVoidSquares.has(darkVoidKey(nr, nc))) {
                        return true;
                    }
                }
            }
            return false;
        }
        function getAdjacentsToDarkVoid(row, col) {
            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            const freeSquares = [];
            for (let [dr, dc] of dirs) {
                const nr = row + dr;
                const nc = col + dc;
                if (!isValid(nr, nc)) continue;
                if (board[nr][nc]) continue;
                freeSquares.push([nr, nc]);
            }
            return freeSquares;
        }
        function getUndeadSummonTargets() {
            const targets = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (!board[r][c] && isAdjacentToDarkVoid(r, c)) {
                        targets.push([r, c]);
                    }
                }
            }
            return targets;
        }

        function createDarkVoidUndeadMove(row, col, summonType = 'undead') {
            const nearby = getAdjacentsToDarkVoid(row, col);
            if (!nearby.length) return null;
            const target = nearby[0];
            return { type: 'summon', pos: target, cost: UNDEAD_SUMMON_COST, special: 'necromancerSummon', summonType: summonType, darkVoidSource: [row, col] };
        }

        function handleDarkVoidCollision(pieceType, row, col) {
            if (!isDarkVoidSquare(row, col)) return null;
            return DARK_VOID_TRAVELERS.has(pieceType) ? 'skip' : 'stop';
        }
        const pieceTypes = {
            'Cavalry': { move: (r, c, board, player) => {
                let moves = [];
                // Standard orthogonal movement (up to 5 squares)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    for (let i = 1; i <= 5; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Diagonal Rush on rounds 1 and 2 only (costs 2 points, up to 3 squares)
                if (gameRound <= 2) {
                    for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        for (let i = 1; i <= 3; i++) {
                            let nr = r + d[0] * i, nc = c + d[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player !== player) {
                                    moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                                }
                                break;
                            }
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                        }
                    }
                }
                return moves;
            }},
            'Troll': { move: (r, c, board, player, firstMove, _, movesLeft) => {
                let moves = [];
                let isFirstTurn = firstMove && isFirstPlayerTurn;
                let maxOrtho = isFirstTurn ? 4 : 2;
                let maxDiag = isFirstTurn ? 2 : 1;
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    for (let i = 1; i <= maxOrtho; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (!isFirstTurn && movesLeft >= 2) {
                    for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                        let nr1 = r + d[0], nc1 = c + d[1];
                        let nr2 = r + d[0] * 2, nc2 = c + d[1] * 2;
                        let nr3 = r + d[0] * 3, nc3 = c + d[1] * 3;
                        if (isValid(nr1, nc1) && isValid(nr2, nc2) && isValid(nr3, nc3) && !board[nr1][nc1] && !board[nr2][nc2] && !board[nr3][nc3]) {
                            moves.push({ type: 'move', pos: [nr3, nc3], cost: 2 });
                        }
                    }
                }
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= maxDiag; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'Dragon': { move: (r, c, board, player) => {
                let moves = [];
                // Normal moves
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !isDarkVoidSquare(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [[2,2], [2,-2], [-2,2], [-2,-2]]) {
                    let midr = r + d[0]/2, midc = c + d[1]/2;
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        for (let d2 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                            let nnr = nr + d2[0], nnc = nc + d2[1];
                            if (isValid(nnr, nnc)) {
                                if (!isDarkVoidSquare(nnr, nnc)) {
                                    moves.push({ type: 'move', pos: [nnr, nnc], cost: 1 });
                                }
                            }
                        }
                    }
                }
                return moves;
            }},
            'Wizard': { move: (r, c, board, player, firstMove, facing, movesLeft) => {
                let moves = [];
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 4; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (movesLeft >= 2) {
                    for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        let i = 1;
                        while (i <= 5) {
                            let nr = r + d[0] * i, nc = c + d[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player === player) {
                                    i++;
                                    continue;
                                } else {
                                    moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                                    break;
                                }
                            }
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2 });
                            i++;
                        }
                    }
                }
                return moves;
            }},
            'Guard': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                return moves;
            }},
            'Huntsman': { move: (r, c, board, player) => {
                let moves = [];
                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    const nr = r + d[0];
                    const nc = c + d[1];
                    if (!isValid(nr, nc)) continue;
                    const occupant = board[nr]?.[nc];
                    if (!occupant || occupant.player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
            'King': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !isCheckAfterMove(r, c, nr, nc, player)) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }},
        'Lich': { move: (r, c, board, player) => {
                let moves = [];
                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let [dr, dc] of directions) {
                    const nr = r + dr, nc = c + dc;
                    if (!isValid(nr, nc)) continue;
                    const target = board[nr][nc];
                    if (isDarkVoidSquare(nr, nc)) continue;
                    if (!target || target.player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                const souls = (capturedPieces[player] || []).length;
                if (souls >= LICH_SOULSTRIDE_THRESHOLD) {
                    for (let [dr, dc] of directions) {
                        const midr = r + dr, midc = c + dc;
                        const nr = r + dr * 2, nc = c + dc * 2;
                        if (!isValid(midr, midc) || !isValid(nr, nc)) continue;
                        const midPiece = board[midr][midc];
                        if (midPiece && midPiece.type !== 'DarkVoid') continue;
                        const target = board[nr][nc];
                        if (isDarkVoidSquare(nr, nc)) continue;
                        if (target && target.player === player) continue;
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1, special: 'lichSoulstride' });
                    }
                }
                return moves;
            }},
            'Champion': { move: (r, c, board, player) => {
                let moves = [];
                let directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                        if (!board[nr][nc]) {
                            for (let d2 of directions) {
                                let nnr = nr + d2[0], nnc = nc + d2[1];
                                if (isValid(nnr, nnc) && (nnr !== r || nnc !== c)) {
                                    if (!board[nnr][nnc] || board[nnr][nnc].player !== player) {
                                        moves.push({ type: 'move', pos: [nnr, nnc], cost: 2 });
                                    }
                                }
                            }
                        }
                    }
                }
                let uniqueMoves = {};
                for (let move of moves) {
                    let key = `${move.pos[0]},${move.pos[1]}`;
                    if (!uniqueMoves[key] || move.cost < uniqueMoves[key].cost) {
                        uniqueMoves[key] = move;
                    }
                }
                return Object.values(uniqueMoves);
            }},
            'Infantry': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Round 1 only: can move up to 3 squares forward
                let max = (gameRound === 1) ? 3 : 1;
                let dir, diag1, diag2;
                if (facing === 'U') { dir = [-1,0]; diag1 = [-1,-1]; diag2 = [-1,1]; }
                else if (facing === 'D') { dir = [1,0]; diag1 = [1,-1]; diag2 = [1,1]; }
                else if (facing === 'L') { dir = [0,-1]; diag1 = [-1,-1]; diag2 = [1,-1]; }
                else if (facing === 'R') { dir = [0,1]; diag1 = [-1,1]; diag2 = [1,1]; }
                
                if (!dir) return []; // Safety check if facing is null

                for (let i = 1; i <= max; i++) {
                    let nr = r + dir[0] * i, nc = c + dir[1] * i;
                    if (!isValid(nr, nc)) break;
                    if (board[nr][nc]) {
                        if (board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [diag1, diag2]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (!board[nr][nc]) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        } else if (board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                const strafeDirs = [[0, 1], [0, -1]];
                for (let [dr, dc] of strafeDirs) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (!isValid(nr, nc)) continue;
                    const occupant = board[nr][nc];
                    if (!occupant || occupant.player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'infantryStrafe' });
                    }
                }
                return moves;
            }},
            'Archer': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Movement: 1 square vertically or horizontally (only to empty squares - cannot capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Shooting: 1 or 2 squares in facing direction
                let dir;
                if (facing === 'U') dir = [-1, 0];
                else if (facing === 'D') dir = [1, 0];
                else if (facing === 'L') dir = [0, -1];
                else if (facing === 'R') dir = [0, 1];

                if (dir) { // Only shoot if facing is set
                    for (let dist = 1; dist <= 2; dist++) {
                        let nr = r + dir[0] * dist, nc = c + dir[1] * dist;
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                            moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }},
            'Ballista': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // Movement: 1 square vertically or horizontally (only to empty squares - cannot capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // Shooting: 1, 2, or 3 squares in specified directions based on facing
                let dirs;
                if (facing === 'U') dirs = [[-1,0], [-1,-1], [-1,1]];  // Up, Up-Left, Up-Right
                else if (facing === 'D') dirs = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
                else if (facing === 'L') dirs = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
                else if (facing === 'R') dirs = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right

                if (dirs) { // Only shoot if facing is set
                    const maxRange = (ballistaRangeBoostActive[player] ? 4 : 3);
                    for (let dir of dirs) {
                        for (let dist = 1; dist <= maxRange; dist++) {
                            let nr = r + dir[0] * dist, nc = c + dir[1] * dist;
                            if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                                moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Elephantry': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                // 1 point: move 1 square any direction (can capture by landing)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) {
                        if (board[nr][nc] && board[nr][nc].type === 'Zombie') continue;
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // 1 point: shoot 1 square in any direction (without moving)
                for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player && board[nr][nc].type !== 'Spectre') {
                        moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                    }
                }
                // 2 points: move+shoot combination (show move positions that have shoot targets available)
                if (movesLeft >= 2) {
                    for (let d1 of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                        let nr = r + d1[0], nc = c + d1[1];
                        if (isValid(nr, nc) && !board[nr][nc]) {
                            // Check if there are any shoot targets from this position
                            let hasShootTargets = false;
                            for (let d2 of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = nr + d2[0], shootC = nc + d2[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== player) {
                                    hasShootTargets = true;
                                    break;
                                }
                            }
                            // Only add this move if there are shoot targets available
                            if (hasShootTargets) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'elephantryMoveShoot' });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Pistolier': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                // 1 point: move diagonally up to 3 squares
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 3; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            // Capturing by landing requires coin flip - handled in handleClick
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 1, special: 'pistolierCapture' });
                            }
                            break;
                        }
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                // 1 point: shoot diagonally up to 2 squares (without moving)
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    for (let i = 1; i <= 2; i++) {
                        let nr = r + d[0] * i, nc = c + d[1] * i;
                        if (!isValid(nr, nc)) break;
                        if (board[nr][nc]) {
                            if (board[nr][nc].player !== player) {
                                moves.push({ type: 'shoot', pos: [nr, nc], cost: 1 });
                            }
                            break;
                        }
                    }
                }
                // 2 points: move+shoot combination (move diagonally, then shoot 1 square diagonally from new position)
                if (movesLeft >= 2) {
                    for (let d1 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                        for (let i = 1; i <= 3; i++) {
                            let nr = r + d1[0] * i, nc = c + d1[1] * i;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) break; // Can't move through pieces for move+shoot

                            // Check if there are any shoot targets from this position (1 square diagonal)
                            let hasShootTargets = false;
                            for (let d2 of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = nr + d2[0], shootC = nc + d2[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== player) {
                                    hasShootTargets = true;
                                    break;
                                }
                            }
                            // Only add this move if there are shoot targets available
                            if (hasShootTargets) {
                                moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'pistolierMoveShoot' });
                            }
                        }
                    }
                }
                return moves;
            }},
            'Fusilier': { move: (r, c, board, player, _, facing, movesLeft) => {
                let moves = [];
                const pieceKey = `${r},${c},${player}`;
                const piece = board[r][c];
                if (!piece) return moves;
                if (!(pieceKey in fusilierCrackShotCount)) {
                    fusilierCrackShotCount[pieceKey] = 3;
                }
                const shotBlocked = piece ? (fusilierShotLastTurn[player].has(piece) || fusilierShotThisTurn[player].has(piece)) : false;

                // 1 point: move up to 2 squares diagonally (1 or 2 squares)
                for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                    // 1 square diagonal movement
                    let nr1 = r + d[0], nc1 = c + d[1];
                    if (isValid(nr1, nc1)) {
                        if (!board[nr1][nc1]) {
                            moves.push({ type: 'move', pos: [nr1, nc1], cost: 1 });
                        }
                    }

                    // 2 squares diagonal movement (can move through own pieces)
                    let intermediateR = r + d[0], intermediateC = c + d[1];
                    let nr2 = r + d[0] * 2, nc2 = c + d[1] * 2;

                    if (!isValid(nr2, nc2)) continue;

                    // Can move through own pieces on intermediate square
                    const intermediateBlocked = board[intermediateR] && board[intermediateR][intermediateC] && board[intermediateR][intermediateC].player !== player;

                    if (!intermediateBlocked) {
                        if (!board[nr2][nc2]) {
                            moves.push({ type: 'move', pos: [nr2, nc2], cost: 1 });
                        }
                    }
                }

                // 1 point: shoot forward and diagonally up to 3 squares (only if didn't shoot last turn)
                // Crack Shot increases range to 4 squares
                if (!shotBlocked) {
                    let directions = [];
                    if (facing === 'U') {
                        directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
                    } else if (facing === 'D') {
                        directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
                    } else if (facing === 'L') {
                        directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
                    } else if (facing === 'R') {
                        directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
                    }

                    const crackShotActive = fusilierCrackShotActive === piece;
                    const crackShotsRemaining = fusilierCrackShotCount[pieceKey] || 0;
                    const canAutoCrackShot = !crackShotActive && crackShotsRemaining > 0 && movesLeft >= 3;

                    const maxRange = crackShotActive ? 4 : 3;
                    for (let d of directions) {
                        for (let i = 1; i <= 4; i++) {
                            let shootR = r + d[0] * i, shootC = c + d[1] * i;
                            if (!isValid(shootR, shootC)) break;
                            if (board[shootR][shootC]) {
                                if (board[shootR][shootC].player !== player) {
                                    if (i <= maxRange) {
                                        moves.push({ type: 'shoot', pos: [shootR, shootC], cost: 1 });
                                    } else if (i === 4 && canAutoCrackShot) {
                                        moves.push({ type: 'shoot', pos: [shootR, shootC], cost: 3, special: 'fusilierCrackShotAuto' });
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                return moves;
            }},
            'Mercenary': { move: (r, c, board, player, _, facing) => {
                let moves = [];
                // All 8 directions: orthogonal and diagonal
                const allDirections = [
                    [-1, 0],  // Up
                    [1, 0],   // Down
                    [0, -1],  // Left
                    [0, 1],   // Right
                    [-1, -1], // Up-Left
                    [-1, 1],  // Up-Right
                    [1, -1],  // Down-Left
                    [1, 1]    // Down-Right
                ];

                // 1 square in any direction for 1 point
                for (let dir of allDirections) {
                    let newPos = [r + dir[0], c + dir[1]];
                    if (isValid(newPos[0], newPos[1])) {
                        if (!board[newPos[0]][newPos[1]]) {
                            moves.push({ type: 'move', pos: newPos, cost: 1 });
                        } else if (board[newPos[0]][newPos[1]].player !== player) {
                            moves.push({ type: 'move', pos: newPos, cost: 1 });
                        }
                    }
                }

                // 2 squares in any direction for 2 points
                for (let dir of allDirections) {
                    let midPos = [r + dir[0], c + dir[1]];
                    let twoPos = [r + 2*dir[0], c + 2*dir[1]];

                    // Path must be clear
                    if (isValid(midPos[0], midPos[1]) && !board[midPos[0]][midPos[1]] &&
                        isValid(twoPos[0], twoPos[1])) {
                        if (!board[twoPos[0]][twoPos[1]]) {
                            moves.push({ type: 'move', pos: twoPos, cost: 2 });
                        } else if (board[twoPos[0]][twoPos[1]].player !== player) {
                            moves.push({ type: 'move', pos: twoPos, cost: 2 });
                        }
                    }
                }
                return moves;
            }},
            'Ogre': { move: (r, c, board, player) => {
                let moves = [];
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = r + d[0], nc = c + d[1];
                    if (isValid(nr, nc)) moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                }
                for (let d of [[0,2], [0,-2], [2,0], [-2,0], [2,2], [2,-2], [-2,2], [-2,-2]]) {
                    let nr = r + d[0], nc = c + d[1];
                    let midr = r + d[0]/2, midc = c + d[1]/2;
                    if (!isValid(midr, midc)) continue;
                    const midPiece = board[midr][midc];
                    const canJumpThrough = !midPiece || midPiece.player !== player || midPiece.type !== 'Ogre';
                    if (isValid(nr, nc) && canJumpThrough) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1, jump: [midr, midc] });
                    }
                }
                return moves;
            }},
            'Spectre': { move: (r, c, board, player) => {
                let moves = [];
                // Knight-like diagonal movement: 2 diagonal + 1 perpendicular
                // Moves through pieces
                const knightDiagMoves = [
                    [2, 2, [[3, 2], [2, 3]]], // NE diagonal +perpendicular
                    [2, -2, [[3, -2], [2, -3]]], // NW diagonal
                    [-2, 2, [[-3, 2], [-2, 3]]], // SE diagonal
                    [-2, -2, [[-3, -2], [-2, -3]]] // SW diagonal
                ];
                for (let [dr, dc, perps] of knightDiagMoves) {
                    for (let [pr, pc] of perps) {
                        let nr = r + pr, nc = c + pc;
                        if (isValid(nr, nc) && !isDarkVoidSquare(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                return moves;
            }}
        };

        pieceTypes['Necromancer'] = {
            move: (r, c, board, player, firstMove, facing, movesLeft = 0) => {
                let moves = [];
                const piece = board[r][c];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = r + dr;
                        const nc = c + dc;
                        if (!isValid(nr, nc)) continue;
                        if (isDarkVoidSquare(nr, nc)) continue;
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                        }
                    }
                }
                const cooldown = necromancerShootCooldown.get(piece) || 0;
                if (movesLeft >= 2 && cooldown === 0) {
                    const directions = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]];
                    for (const [dr, dc] of directions) {
                        for (let dist = 1; dist <= 2; dist++) {
                            const nr = r + dr * dist;
                            const nc = c + dc * dist;
                            if (!isValid(nr, nc)) break;
                            if (board[nr][nc]) {
                                if (board[nr][nc].player !== player) {
                                    moves.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'necromancerShoot' });
                                }
                                break;
                            }
                        }
                    }
                }
                return moves;
            }
        };

        pieceTypes['Undead'] = {
            move: (r, c, board, player, _, __, movesLeft = 0) => {
                let moves = [];
                const diagDirs = [[1,1], [1,-1], [-1,1], [-1,-1]];
                const orthDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for (let [dr, dc] of diagDirs) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (!isValid(nr, nc) || isDarkVoidSquare(nr, nc)) continue;
                    if (!board[nr][nc] || board[nr][nc].player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                if (movesLeft >= 2) {
                    for (let [dr, dc] of orthDirs) {
                        const nr = r + dr;
                        const nc = c + dc;
                        if (!isValid(nr, nc) || isDarkVoidSquare(nr, nc)) continue;
                        if (!board[nr][nc] || board[nr][nc].player !== player) {
                            moves.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'undeadStrafe' });
                        }
                    }
                }
                return moves;
            }
        };
        pieceTypes['Undead3'] = pieceTypes['Undead'];

        pieceTypes['UndeadChampion'] = {
            move: (r, c, board, player, _, __, movesLeft = 0) => {
                let moves = [];
                const piece = board[r][c];
                const allDirs = [[1,1], [1,-1], [-1,1], [-1,-1], [0,1], [0,-1], [1,0], [-1,0]];
                // Regular movement: any direction, 1 square, costs 1 move point
                for (let [dr, dc] of allDirs) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (!isValid(nr, nc) || isDarkVoidSquare(nr, nc)) continue;
                    if (!board[nr][nc] || board[nr][nc].player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 1 });
                    }
                }
                return moves;
            }
        };

        pieceTypes['DarkVoid'] = {
            move: () => []
        };

        pieceTypes['Zombie'] = {
            move: () => []
        };

        let board = [];
        let currentPlayer = 'W';
        let selectedPiece = null;
        let validMoves = [];
        let movesLeft = 3;
        let movedPieces = new Set();
        let capturedPieces = { 'W': [], 'B': [] };
        let championCaptured = { 'W': false, 'B': false };
        let championsOnBackRow = { 'W': [], 'B': [] };
        let scores = { 'W': 0, 'B': 0 };
        let firstMoves = new Set();
        let reinforcementPending = null;
        let gameLog = [];

        function setDifficulty(level, element) {
            aiDifficulty = level;
            const buttons = document.querySelectorAll('#difficulty-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-diff'));
            element.classList.add('selected-diff');

            if (level === 'Easy') {
                baseAiDepth = 25; // Increased by 60% intelligence + 30% general difficulty (12 * 1.6 * 1.3  25) - plans 3+ moves ahead
                pieceValueScale = 8.0031744; // Increased by 60% intelligence + 30% general difficulty (3.84768 * 1.6 * 1.3)
            } else if (level === 'Medium') {
                baseAiDepth = 53; // Increased by additional 20% intelligence (44 * 1.2  53) - deeper search for better tactical planning
                pieceValueScale = 12.9166202; // Increased by additional 10% difficulty (11.74238208 * 1.1) - better piece evaluation
            } else if (level === 'Hard') {
                baseAiDepth = 91; // Increased by additional 40% intelligence (65 * 1.4 = 91) - extensive multi-move lookahead
                pieceValueScale = 19.9264666; // Increased by additional 20% difficulty (16.6053888 * 1.2) - superior piece evaluation
            }
            applyAiDepthForVariant();
        }

        function setOpponent(opponent, element) {
            selectedOpponent = opponent;
            const buttons = document.querySelectorAll('#opponent-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-opponent'));
            element.classList.add('selected-opponent');
        }

        function setHintMode(mode, element) {
            hintModeEnabled = (mode === 'On');
            const buttons = document.querySelectorAll('#hint-selector button');
            buttons.forEach(btn => btn.classList.remove('selected-hint'));
            element.classList.add('selected-hint');
        }

        function getOpponentDisplayName() {
            return currentAiProfile ? currentAiProfile.displayName : 'AI';
        }

        function applyAiDepthForVariant() {
            // Apply difficulty-based depth limits that scale with selected difficulty level
            // Caps are now proportional to allow difficulty settings to apply properly
            if (gameVariant === '24s' || gameVariant === 'ccb') {
                // Cap at 70% of base depth for medium-sized variants
                aiMaxDepth = Math.max(3, Math.min(baseAiDepth, Math.floor(baseAiDepth * 0.7)));
            } else if (isLargeBoardVariant()) {
                // Cap at 30% of base depth for large variants (performance consideration)
                aiMaxDepth = Math.max(2, Math.min(baseAiDepth, Math.floor(baseAiDepth * 0.3)));
            } else {
                // Default variants can use full depth
                aiMaxDepth = Math.max(2, baseAiDepth);
            }
            updateAiPieceValues();
        }

        function startGame(variant) {
            gameVariant = variant;

            // Select AI profile based on player's choice
            if (selectedOpponent === 'Random') {
                const profileNames = Object.keys(AI_PROFILES);
                const randomIndex = Math.floor(Math.random() * profileNames.length);
                currentAiProfile = AI_PROFILES[profileNames[randomIndex]];
            } else {
                currentAiProfile = AI_PROFILES[selectedOpponent];
            }
            console.log(`AI Profile: ${currentAiProfile.name} - ${currentAiProfile.description}`);

            if (variant === '24s') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-expert') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-elite') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === '36s-supreme') {
                ROWS = 10;
                COLS = 14;
            } else if (variant === 'ccb') {
                ROWS = 8;
                COLS = 12;
            }
            applyAiDepthForVariant();
            document.getElementById('start-menu').style.display = 'none';
            const landingHeader = document.getElementById('landing-header');
            if (landingHeader) landingHeader.style.display = 'none';
            const landingFooter = document.getElementById('landing-footer');
            if (landingFooter) landingFooter.style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            document.body.classList.add('game-loaded');
            const boardDiv = document.getElementById('board');
            boardDiv.style.gridTemplateColumns = `repeat(${COLS}, 50px)`;
            boardDiv.style.gridTemplateRows = `repeat(${ROWS}, 50px)`;
            // Start aggressive watchdog to ensure AI turn always triggers when needed (especially for 36s variants)
            if (!window.aiTurnWatch) {
                window.aiTurnWatch = setInterval(() => {
                    try {
                        // Don't trigger AI turn if game is paused
                        if (gamePaused) return;

                        // Aggressively check turn transition
                        if (currentPlayer === 'W' && !reinforcementPending && !aiPending && movesLeft <= 0 && !isElephantrySpecialActive()) {
                            triggerAiTurn();
                        } else {
                            ensureAITurnIfNeeded();
                        }
                    } catch (e) {
                        // Silently ignore watchdog errors
                    }
                }, 200); // Check every 200ms for faster response
            }
            resetGame();
        }

        function initBoard() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            firstMoves.clear();
            championsOnBackRow = { 'W': [], 'B': [] };
            if (gameVariant === '24s') {
                const backRowW = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry'];
                const backRowB = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry']; // King and Champion swapped for AI
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[8][c] = { type: 'Infantry', player: 'W', facing: 'U' };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: 'Infantry', player: 'B', facing: 'D' };
                    if (backRowW[idx] === 'Troll') {
                        firstMoves.add(`9,${c},W`);
                    }
                    if (backRowB[idx] === 'Troll') {
                        firstMoves.add(`0,${c},B`);
                    }
                }
            } else if (gameVariant === '36s') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[7][c] = { type: 'Infantry', player: 'W', facing: 'U' };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: 'Infantry', player: 'B', facing: 'D' };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === '36s-expert') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                const infantryRow = ['Infantry', 'Infantry', 'Mercenary', 'Infantry', 'Elephantry', 'Infantry', 'Infantry', 'Elephantry', 'Infantry', 'Mercenary', 'Infantry', 'Infantry'];
                // Place pieces in columns 1-12, leaving columns 0 and 13 empty
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1; // Index into the piece arrays (0-11)
                    board[7][c] = { type: infantryRow[idx], player: 'W', facing: turnablePieces.includes(infantryRow[idx]) ? 'U' : null };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: infantryRow[idx], player: 'B', facing: turnablePieces.includes(infantryRow[idx]) ? 'D' : null };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === '36s-elite' || gameVariant === '36s-supreme') {
                const backRowW = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry'];
                const backRowB = ['Cavalry', 'Ogre', 'Ballista', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Ballista', 'Ogre', 'Cavalry']; // King and Champion swapped for AI
                const secondRow = ['Cavalry', 'Troll', 'Dragon', 'Archer', 'Archer', 'Guard', 'Guard', 'Archer', 'Archer', 'Dragon', 'Troll', 'Cavalry'];
                const infantryRow = ['Infantry', 'Infantry', 'Mercenary', 'Infantry', 'Elephantry', 'Infantry', 'Infantry', 'Elephantry', 'Infantry', 'Mercenary', 'Infantry', 'Infantry'];
                for (let c = 1; c <= 12; c++) {
                    const idx = c - 1;
                    board[7][c] = { type: infantryRow[idx], player: 'W', facing: turnablePieces.includes(infantryRow[idx]) ? 'U' : null };
                    board[8][c] = { type: secondRow[idx], player: 'W', facing: turnablePieces.includes(secondRow[idx]) ? 'U' : null };
                    board[9][c] = { type: backRowW[idx], player: 'W', facing: turnablePieces.includes(backRowW[idx]) ? 'U' : null };
                    board[0][c] = { type: backRowB[idx], player: 'B', facing: turnablePieces.includes(backRowB[idx]) ? 'D' : null };
                    board[1][c] = { type: secondRow[idx], player: 'B', facing: turnablePieces.includes(secondRow[idx]) ? 'D' : null };
                    board[2][c] = { type: infantryRow[idx], player: 'B', facing: turnablePieces.includes(infantryRow[idx]) ? 'D' : null };
                    if (secondRow[idx] === 'Troll') {
                        firstMoves.add(`8,${c},W`);
                        firstMoves.add(`1,${c},B`);
                    }
                }
            } else if (gameVariant === 'ccb') {
                const backRowW = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'Champion', 'King', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry'];
                const backRowB = ['Cavalry', 'Troll', 'Dragon', 'Wizard', 'Guard', 'King', 'Champion', 'Guard', 'Wizard', 'Dragon', 'Troll', 'Cavalry']; // King and Champion swapped for AI
                const infantryRow = Array(COLS).fill('Infantry');
                for (let c = 0; c < COLS; c++) {
                    board[6][c] = { type: infantryRow[c], player: 'W', facing: 'U' };
                    board[7][c] = { type: backRowW[c], player: 'W', facing: turnablePieces.includes(backRowW[c]) ? 'U' : null };
                    board[0][c] = { type: backRowB[c], player: 'B', facing: turnablePieces.includes(backRowB[c]) ? 'D' : null };
                    board[1][c] = { type: infantryRow[c], player: 'B', facing: 'D' };
                    if (backRowW[c] === 'Troll') {
                        firstMoves.add(`7,${c},W`);
                    }
                    if (backRowB[c] === 'Troll') {
                        firstMoves.add(`0,${c},B`);
                    }
                }
            }
            // Don't render board here - wait until coin toss determines starting player
        }

        function applyCoinFlipSuccessEffect(theme = null) {
            const boardDiv = document.getElementById('board');
            if (!boardDiv) return;
            const energyTheme = theme === 'energy-blast' || theme === 'lich-soul-blast';
            const effectClass = energyTheme ? 'coin-flip-success-energy' : 'coin-flip-success';
            boardDiv.classList.remove('coin-flip-success', 'coin-flip-success-energy');
            boardDiv.classList.add(effectClass);

            // Apply purple body overlay for energy blast or Soul Blast themed success
            const body = document.body;
            if (energyTheme && body) {
                body.classList.add('energy-blast-overlay');
                if (theme === 'lich-soul-blast') {
                    body.classList.add('soul-blast-overlay');
                }
            }

            let cleanupApplied = false;
            let cleanupScheduled = false;
            const handleEffectCleanup = () => {
                if (cleanupApplied) return;
                cleanupApplied = true;
                boardDiv.classList.remove(effectClass);
                // For energy/soul blast theme, only remove overlay if energy blast glow is not active
                if (energyTheme && body && !energyBlastGlowActive) {
                    body.classList.remove('energy-blast-overlay');
                    if (theme === 'lich-soul-blast') {
                        body.classList.remove('soul-blast-overlay');
                    }
                }
            };

            if (energyTheme) {
                const settleDelay = 400;
                const pollInterval = 120;
                const minDuration = 3400;
                const maxDuration = 6500;
                const startTime = Date.now();
                const waitForTransition = () => {
                    if (cleanupApplied) return;
                    const elapsed = Date.now() - startTime;
                    if (energyBlastGlowActive && elapsed >= minDuration) {
                        if (!cleanupScheduled) {
                            cleanupScheduled = true;
                            setTimeout(handleEffectCleanup, settleDelay);
                        }
                        return;
                    }
                    if (elapsed >= maxDuration) {
                        cleanupScheduled = true;
                        handleEffectCleanup();
                        return;
                    }
                    setTimeout(waitForTransition, pollInterval);
                };
                waitForTransition();
            } else {
                setTimeout(handleEffectCleanup, 1500);
            }
        }

        function applyCoinFlipFailureEffect() {
            const body = document.body;
            // Add game background color change immediately
            if (!body.classList.contains('coinflip-failure-game-background')) {
                body.classList.add('coinflip-failure-game-background');
                // Remove game background after 2 seconds
                setTimeout(() => {
                    body.classList.remove('coinflip-failure-game-background');
                }, 2000);
            }
        }

        function showWarcryAchievementPopup(player, options = {}) {
            const { title = 'WARCRY', subtitle = 'Bonus Granted' } = options;
            // Pause the game
            gamePaused = true;
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;

            // Stop timers
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
                gameTimerInterval = null;
            }
            if (turnTimerInterval) {
                clearInterval(turnTimerInterval);
                turnTimerInterval = null;
            }

            // Apply visual effects
            const boardDiv = document.getElementById('board');
            const body = document.body;

            // Add gold glow to board
            if (boardDiv) {
                boardDiv.classList.add('warcry-achievement');
            }

            // Add black background
            if (!body.classList.contains('warcry-achievement-background')) {
                body.classList.add('warcry-achievement-background');
            }

            // Show modal
            const modal = document.getElementById('warcry-achievement-modal');
            if (modal) {
                const titleEl = modal.querySelector('h1');
                const subtitleEl = modal.querySelector('p');
                if (titleEl) titleEl.textContent = title;
                if (subtitleEl) subtitleEl.textContent = subtitle;
                modal.style.display = 'block';
            }

            // Auto-close after 2.6 seconds
            setTimeout(() => {
                closeWarcryAchievementPopup();
            }, 2600);
        }

        function closeWarcryAchievementPopup() {
            // Hide modal
            const modal = document.getElementById('warcry-achievement-modal');
            if (modal) {
                modal.style.display = 'none';
            }

            // Remove visual effects
            const boardDiv = document.getElementById('board');
            const body = document.body;

            if (boardDiv) {
                boardDiv.classList.remove('warcry-achievement');
            }

            if (body) {
                body.classList.remove('warcry-achievement-background');
            }

            // Resume game
            gamePaused = false;
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
        }

        function applyEnergyBlastGlow(options = {}) {
            const variant = options.variant || 'energy';
            if (energyBlastGlowRemovalTimeout) {
                clearTimeout(energyBlastGlowRemovalTimeout);
                energyBlastGlowRemovalTimeout = null;
            }
            const board = document.getElementById('board');
            if (board) {
                board.classList.add('energy-blast-glow');
                if (variant === 'soul-blast') {
                    board.classList.add('soul-blast-glow');
                } else {
                    board.classList.remove('soul-blast-glow');
                }
            }
            const body = document.body;
            if (body) {
                body.classList.add('energy-blast-overlay');
                if (variant === 'soul-blast') {
                    body.classList.add('soul-blast-overlay');
                } else {
                    body.classList.remove('soul-blast-overlay');
                }
            }
            energyBlastGlowVariant = variant;
            energyBlastGlowActive = true;
        }
        function applySoulBlastSlowMo() {
            if (soulBlastSlowMoTimeout) {
                clearTimeout(soulBlastSlowMoTimeout);
                soulBlastSlowMoTimeout = null;
            }
            const body = document.body;
            if (body) {
                body.classList.add('soul-blast-slowmo');
            }
        }

        function removeSoulBlastSlowMo(immediate = false) {
            if (!immediate) {
                if (soulBlastSlowMoTimeout) {
                    clearTimeout(soulBlastSlowMoTimeout);
                }
                soulBlastSlowMoTimeout = setTimeout(() => removeSoulBlastSlowMo(true), 900);
                return;
            }
            const body = document.body;
            if (body) {
                body.classList.remove('soul-blast-slowmo');
            }
            if (soulBlastSlowMoTimeout) {
                clearTimeout(soulBlastSlowMoTimeout);
            }
            soulBlastSlowMoTimeout = null;
        }

        function removeEnergyBlastGlow() {
            if (!energyBlastGlowActive) return;
            if (energyBlastGlowRemovalTimeout) {
                clearTimeout(energyBlastGlowRemovalTimeout);
                energyBlastGlowRemovalTimeout = null;
            }
            const board = document.getElementById('board');
            if (board) {
                board.classList.remove('energy-blast-glow');
                board.classList.remove('soul-blast-glow');
            }
            const body = document.body;
            if (body) {
                body.classList.remove('energy-blast-overlay');
                body.classList.remove('soul-blast-overlay');
            }
            energyBlastGlowVariant = null;
            energyBlastGlowActive = false;
        }

        function showEnergyBlastPopup(callback = () => {}, options = {}) {
            const { title = 'ENERGY BLAST', subtitle = 'Spell Unleashed', keepPaused = false } = options;
            const modal = document.getElementById('energy-blast-popup');
            if (!modal) {
                callback();
                return;
            }
            const titleEl = modal.querySelector('h1');
            const subtitleEl = modal.querySelector('p');
            if (titleEl) titleEl.textContent = title;
            if (subtitleEl) subtitleEl.textContent = subtitle;
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
            modal.style.display = 'block';
            setTimeout(() => {
                modal.style.display = 'none';
                if (!keepPaused) {
                    if (pausedTimers.game && gameTimeRemaining > 0) {
                        startGameTimer();
                    }
                    if (pausedTimers.turn && pausedTimers.turnPlayer) {
                        if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                            startTurnTimer('W', { reset: false });
                        } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                            startTurnTimer('B', { reset: false });
                        }
                    }
                    gamePaused = false;
                }
                pausedTimers = { game: null, turn: null, turnPlayer: null };
                callback();
            }, 2000);
        }

        function pauseGameForEnergyBlastFlips() {
            if (!energyBlastFlipPauseState) {
                energyBlastFlipPauseState = {
                    wasPaused: gamePaused,
                    gameRunning: !!gameTimerInterval,
                    turnRunning: !!turnTimerInterval,
                    turnPlayer: currentTurnTimerPlayer
                };
            }
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
        }

        function resumeGameForEnergyBlastFlips() {
            if (!energyBlastFlipPauseState) return;
            if (!energyBlastFlipPauseState.wasPaused) {
                if (energyBlastFlipPauseState.gameRunning && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (energyBlastFlipPauseState.turnRunning && energyBlastFlipPauseState.turnPlayer) {
                    if (energyBlastFlipPauseState.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (energyBlastFlipPauseState.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                gamePaused = false;
            }
            energyBlastFlipPauseState = null;
        }

        function pauseGameForSoulBlast() {
            if (!soulBlastPauseState) {
                soulBlastPauseState = {
                    wasPaused: gamePaused,
                    gameRunning: !!gameTimerInterval,
                    turnRunning: !!turnTimerInterval,
                    turnPlayer: currentTurnTimerPlayer
                };
            }
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
        }

        function resumeGameAfterSoulBlast() {
            if (!soulBlastPauseState) return;
            const { wasPaused, gameRunning, turnRunning, turnPlayer } = soulBlastPauseState;
            soulBlastPauseState = null;
            if (!wasPaused) {
                gamePaused = false;
                if (gameRunning && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (turnRunning && turnPlayer) {
                    if (turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
            } else {
                gamePaused = true;
            }
        }

        function restoreSoulBlastInteractionState() {
            const overlay = document.getElementById('modal-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            if (gamePaused) {
                gamePaused = false;
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
        }

        function pauseGameForHuntsmanBurst() {
            if (!huntsmanBurstPauseState) {
                huntsmanBurstPauseState = {
                    wasPaused: gamePaused,
                    gameRunning: !!gameTimerInterval,
                    turnRunning: !!turnTimerInterval,
                    turnPlayer: currentTurnTimerPlayer
                };
            }
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
        }

        function resumeGameAfterHuntsmanBurst() {
            if (!huntsmanBurstPauseState) return;
            if (!huntsmanBurstPauseState.wasPaused) {
                if (huntsmanBurstPauseState.gameRunning && gameTimeRemaining > 0) {
                    startGameTimer();
                }
                if (huntsmanBurstPauseState.turnRunning && huntsmanBurstPauseState.turnPlayer) {
                    if (huntsmanBurstPauseState.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (huntsmanBurstPauseState.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                gamePaused = false;
            }
            huntsmanBurstPauseState = null;
        }

        function updateCoinTossEnergyBlastProgress() {
            const progressEl = document.getElementById('coin-toss-progress');
            const continueBtn = document.getElementById('coin-toss-continue');
            if (!progressEl) return;
            if (coinTossEnergyBlastMode && coinTossEnergyBlastMode.type === 'range') {
                const successes = coinTossEnergyBlastMode.successes || 0;
                const total = coinTossEnergyBlastMode.total || ENERGY_BLAST_FLIP_COUNT;
                progressEl.style.display = 'inline-block';
                progressEl.textContent = `Successes: ${successes}/${total}`;
                if (continueBtn) {
                    continueBtn.style.display = 'none';
                }
            } else {
                progressEl.style.display = 'none';
            }
        }

        function addEnergyBlastResidualSquares(squares) {
            if (!squares || !squares.length) return;
            squares.forEach(({ row, col }) => {
                const key = `${row},${col}`;
                energyBlastResidualSquares.set(key, ENERGY_BLAST_RESIDUAL_DURATION);
            });
            refreshEnergyBlastResidualHighlights();
        }

        function decayEnergyBlastResiduals(player) {
            if (!energyBlastResidualSquares.size) return;
            let changed = false;
            const updated = new Map();
            energyBlastResidualSquares.forEach((value, key) => {
                const next = value - 1;
                if (next > 0) {
                    updated.set(key, next);
                    if (next !== value) changed = true;
                } else {
                    changed = true;
                }
            });
            energyBlastResidualSquares = updated;
            if (changed) {
                refreshEnergyBlastResidualHighlights();
            }
        }

        function refreshEnergyBlastResidualHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const key = `${square.dataset.row},${square.dataset.col}`;
                if (energyBlastResidualSquares.has(key)) {
                    square.classList.add('energy-blast-residual');
                } else if (square.classList.contains('energy-blast-residual')) {
                    square.classList.remove('energy-blast-residual');
                }
            });
        }

        function refreshSoulBlastPreviewHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const key = `${square.dataset.row},${square.dataset.col}`;
                if (soulBlastPreviewSquares.has(key)) {
                    square.classList.add('soul-blast-preview');
                } else if (square.classList.contains('soul-blast-preview')) {
                    square.classList.remove('soul-blast-preview');
                }
            });
        }

        function animateEnergyBlastPath(pathSquares, callback, options = {}) {
            if (!pathSquares || !pathSquares.length) {
                callback();
                return;
            }
            const wasPaused = gamePaused;
            const savedTurnPlayer = currentTurnTimerPlayer;
            if (!wasPaused) {
                stopGameTimer();
                stopTurnTimer();
                gamePaused = true;
            }
            const highlighted = [];
            const stepDuration = options.stepDuration || 220;
            const finalDelay = options.finalDelay !== undefined ? options.finalDelay : stepDuration;

            const removeHighlights = () => {
                highlighted.forEach(el => el.classList.remove('energy-blast-path'));
                highlighted.length = 0;
            };

            const finishAnimation = () => {
                removeHighlights();
                if (!wasPaused) {
                    gamePaused = false;
                    if (gameTimeRemaining > 0) {
                        startGameTimer();
                    }
                    if (savedTurnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                        startTurnTimer('W', { reset: false });
                    } else if (savedTurnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                        startTurnTimer('B', { reset: false });
                    }
                }
                callback();
            };

            const highlightStep = (index) => {
                if (index >= pathSquares.length) {
                    setTimeout(() => finishAnimation(), finalDelay);
                    return;
                }
                const { row, col } = pathSquares[index];
                const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                if (square) {
                    square.classList.add('energy-blast-path');
                    highlighted.push(square);
                }
                setTimeout(() => highlightStep(index + 1), stepDuration);
            };

            highlightStep(0);
        }

        function applyWarcryActiveBackground() {
            const body = document.body;
            const boardDiv = document.getElementById('board');
            if (!body.classList.contains('warcry-active-background')) {
                body.classList.add('warcry-active-background');
            }
            if (boardDiv && !boardDiv.classList.contains('warcry-active-border')) {
                boardDiv.classList.add('warcry-active-border');
            }
        }

        function removeWarcryActiveBackground() {
            const body = document.body;
            const boardDiv = document.getElementById('board');
            if (body.classList.contains('warcry-active-background')) {
                body.classList.remove('warcry-active-background');
            }
            if (boardDiv && boardDiv.classList.contains('warcry-active-border')) {
                boardDiv.classList.remove('warcry-active-border');
            }
        }

        function closeGameStats() {
            // Hide modal
            const modal = document.getElementById('game-stats-modal');
            if (modal) {
                modal.style.display = 'none';
            }
            const endgameOverlay = document.getElementById('endgame-overlay');
            if (endgameOverlay) {
                endgameOverlay.style.display = 'none';
            }

            // Return to main menu
            document.getElementById('start-menu').style.display = 'flex';
            document.getElementById('game-container').style.display = 'none';
            document.body.classList.remove('game-loaded');
            const landingHeader = document.getElementById('landing-header');
            if (landingHeader) landingHeader.style.display = 'block';
            const landingFooter = document.getElementById('landing-footer');
            if (landingFooter) landingFooter.style.display = 'block';
            resetVariantSelections();

            // Reset game stats
            gameStats.warcryBonusCount = { 'W': 0, 'B': 0 };
            gameStats.despairPenaltyCount = { 'W': 0, 'B': 0 };
            gameStats.gameStartTime = null;
            gameStats.gameDuration = 0;
            gameStats.capturesThisRound = { 'W': 0, 'B': 0 };
            gameStats.mostCapturesInRound = { 'W': 0, 'B': 0 };
            gameStats.scoreThisRound = { 'W': 0, 'B': 0 };
            gameStats.highestScoreInRound = { 'W': 0, 'B': 0 };
            gameStats.summonCount = { 'W': 0, 'B': 0 };
            gameStats.reinforcementCount = { 'W': 0, 'B': 0 };
        }

        function renderBoard() {
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;
                    if (mercenaryBonusHighlight && mercenaryBonusHighlight.row === r && mercenaryBonusHighlight.col === c) {
                        square.classList.add('mercenary-highlight');
                    }
                    const cell = board[r][c];
                    const squareKey = `${r},${c}`;
                    if (darkVoidSquares.has(squareKey)) {
                        square.classList.add('dark-void');
                    } else if (cell) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.className = `piece ${cell.player === 'W' ? 'white' : 'black'}`;
                        pieceSpan.textContent = pieceIcons[cell.type];
                        pieceSpan.style.color = cell.player === 'W' ? 'black' : 'white';
                        square.appendChild(pieceSpan);
                        if (cell.facing) {
                            const arrow = document.createElement('span');
                            arrow.className = 'piece-arrow';
                            arrow.textContent = facingIcons[cell.facing];
                            arrow.style.color = cell.player === 'W' ? 'white' : 'black';
                            square.appendChild(arrow);
                        }
                    }
                    if (energyBlastResidualSquares.has(squareKey)) {
                        square.classList.add('energy-blast-residual');
                    }
                    if (soulBlastPreviewSquares.has(squareKey)) {
                        square.classList.add('soul-blast-preview');
                    }
                    square.addEventListener('click', () => handleClick(r, c));
                    boardDiv.appendChild(square);
                    if (currentPlayer === 'B' && highlightSquares.some(([hr, hc]) => hr == r && hc == c)) {
                        square.classList.add('ai-move-highlight');
                    }
                }
            }
            updateControlButtons();
            highlightValidMoves();
            updateScoreDisplay();
            updateEndTurnButton();
            refreshEnergyBlastResidualHighlights();
            refreshSoulBlastPreviewHighlights();
            // Apply capture effects after rendering
            capturedSquares.forEach(([r, c]) => addCaptureEffect(r, c));
            capturedSquares = [];
            // Extra safety: ensure AI begins if needed (e.g., 36's edge cases)
            ensureAITurnIfNeeded();
        }

        function opponentHasWizards(player) {
            const opponent = player === 'W' ? 'B' : 'W';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent) {
                        return true;
                    }
                }
            }
            return false;
        }

        function isChampionPresent(player) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'Champion') {
                        return true;
                    }
                }
            }
            return false;
        }

        function updateControlButtons() {
            const turnButton = document.getElementById('turn-button');
            const turnMoveButton = document.getElementById('turn-move-button');
            const turnShootButton = document.getElementById('turn-shoot-button');
            const archerMoveDiagShootButton = document.getElementById('archer-move-diag-shoot-button');
            const archerDiag2ShootButton = document.getElementById('archer-diag2-shoot-button');
            const guardHonourButton = document.getElementById('guard-honour-button');
            const teleportButton = document.getElementById('teleport-button');
            const teleportSwapButton = document.getElementById('teleport-swap-button');
            const chargeButton = document.getElementById('charge-button');
            const ogreRageButton = document.getElementById('ogre-rage-button');
            const infernoButton = document.getElementById('inferno-button'); // Get Inferno button
            const strafeButton = document.getElementById('strafe-button'); // Get Strafe button
            const summonSpectreButton = document.getElementById('summon-spectre-button'); // Get Summon Spectre button
            const energyBlastButton = document.getElementById('energy-blast-button');
            const sacrificeButton = document.getElementById('sacrifice-button');
            const lichSoulBlastButton = document.getElementById('lich-soul-blast-button');
            let darkVoidButton = document.getElementById('dark-void-button');
            const kingSummonPistolierButton = document.getElementById('king-summon-pistolier-button');
            const kingSummonFusilierButton = document.getElementById('king-summon-fusilier-button');
            let huntsmanBurstButton = document.getElementById('huntsman-burst-button');
            // Ballista special buttons
            let ballistaRangeButton = document.getElementById('ballista-range-button');
            let ballistaDoubleButton = document.getElementById('ballista-double-button');
            if (!ballistaRangeButton) {
                ballistaRangeButton = document.createElement('button');
                ballistaRangeButton.id = 'ballista-range-button';
                ballistaRangeButton.textContent = 'Extend Range';
                ballistaRangeButton.style.display = 'none';
                ballistaRangeButton.onclick = () => activateBallistaRange(ballistaRangeButton);
                document.getElementById('controls').insertBefore(ballistaRangeButton, document.getElementById('guard-honour-button'));
            }
            if (!ballistaDoubleButton) {
                ballistaDoubleButton = document.createElement('button');
                ballistaDoubleButton.id = 'ballista-double-button';
                ballistaDoubleButton.textContent = 'Double Time';
                ballistaDoubleButton.style.display = 'none';
                ballistaDoubleButton.onclick = () => activateBallistaDoubleTime(ballistaDoubleButton);
                document.getElementById('controls').insertBefore(ballistaDoubleButton, document.getElementById('guard-honour-button'));
            }
            // Elephantry special buttons
            let elephantryChargeButton = document.getElementById('elephantry-charge-button');
            let elephantryExtendedButton = document.getElementById('elephantry-extended-button');
            let elephantryMoveShootButton = document.getElementById('elephantry-moveshoot-button');
            if (!elephantryChargeButton) {
                elephantryChargeButton = document.createElement('button');
                elephantryChargeButton.id = 'elephantry-charge-button';
                elephantryChargeButton.textContent = 'Charge';
                elephantryChargeButton.style.display = 'none';
                elephantryChargeButton.onclick = () => activateElephantryCharge(elephantryChargeButton);
                document.getElementById('controls').insertBefore(elephantryChargeButton, document.getElementById('guard-honour-button'));
            }
            if (!elephantryExtendedButton) {
                elephantryExtendedButton = document.createElement('button');
                elephantryExtendedButton.id = 'elephantry-extended-button';
                elephantryExtendedButton.textContent = 'Triple Shot';
                elephantryExtendedButton.style.display = 'none';
                elephantryExtendedButton.onclick = () => activateElephantryExtendedRange(elephantryExtendedButton);
                document.getElementById('controls').insertBefore(elephantryExtendedButton, document.getElementById('guard-honour-button'));
            }
            if (!elephantryMoveShootButton) {
                elephantryMoveShootButton = document.createElement('button');
                elephantryMoveShootButton.id = 'elephantry-moveshoot-button';
                elephantryMoveShootButton.textContent = 'Move+Shoot';
                elephantryMoveShootButton.style.display = 'none';
                elephantryMoveShootButton.onclick = () => activateElephantryMoveShoot(elephantryMoveShootButton);
                document.getElementById('controls').insertBefore(elephantryMoveShootButton, document.getElementById('guard-honour-button'));
            }
            // Pistolier special buttons
            let pistolierMoveShootButton = document.getElementById('pistolier-moveshoot-button');
            if (!pistolierMoveShootButton) {
                pistolierMoveShootButton = document.createElement('button');
                pistolierMoveShootButton.id = 'pistolier-moveshoot-button';
                pistolierMoveShootButton.textContent = 'Move+Shoot';
                pistolierMoveShootButton.style.display = 'none';
                pistolierMoveShootButton.onclick = () => activatePistolierMoveShoot(pistolierMoveShootButton);
                document.getElementById('controls').insertBefore(pistolierMoveShootButton, document.getElementById('guard-honour-button'));
            }
            // Fusilier special buttons
            let fusilierCrackShotButton = document.getElementById('fusilier-crackshot-button');
            let fusilierStrafeButton = document.getElementById('fusilier-strafe-button');
            if (!fusilierCrackShotButton) {
                fusilierCrackShotButton = document.createElement('button');
                fusilierCrackShotButton.id = 'fusilier-crackshot-button';
                fusilierCrackShotButton.textContent = 'Crack Shot';
                fusilierCrackShotButton.style.display = 'none';
                fusilierCrackShotButton.onclick = () => activateFusilierCrackShot(fusilierCrackShotButton);
                document.getElementById('controls').insertBefore(fusilierCrackShotButton, document.getElementById('guard-honour-button'));
            }
            if (!fusilierStrafeButton) {
                fusilierStrafeButton = document.createElement('button');
                fusilierStrafeButton.id = 'fusilier-strafe-button';
                fusilierStrafeButton.textContent = 'Strafe';
                fusilierStrafeButton.style.display = 'none';
                fusilierStrafeButton.onclick = () => activateFusilierStrafe(fusilierStrafeButton);
                document.getElementById('controls').insertBefore(fusilierStrafeButton, document.getElementById('guard-honour-button'));
            }
            let moralBoostButton = document.getElementById('moral-boost-button');
            if (!moralBoostButton) {
                moralBoostButton = document.createElement('button');
                moralBoostButton.id = 'moral-boost-button';
                moralBoostButton.textContent = 'Moral Boost (0/3)';
                moralBoostButton.style.display = 'none';
                moralBoostButton.onclick = () => activateMoralBoost(moralBoostButton);
                document.getElementById('controls').insertBefore(moralBoostButton, document.getElementById('guard-honour-button'));
            }
            let kingShotButton = document.getElementById('king-shot-button');
            if (!kingShotButton) {
                kingShotButton = document.createElement('button');
                kingShotButton.id = 'king-shot-button';
                kingShotButton.textContent = 'King Shot';
                kingShotButton.style.display = 'none';
                kingShotButton.onclick = () => activateKingShot(kingShotButton);
                document.getElementById('controls').insertBefore(kingShotButton, document.getElementById('guard-honour-button'));
            }
            let kingEvadeButton = document.getElementById('king-evade-button');
            if (!kingEvadeButton) {
                kingEvadeButton = document.createElement('button');
                kingEvadeButton.id = 'king-evade-button';
                kingEvadeButton.textContent = 'Evade';
                kingEvadeButton.style.display = 'none';
                kingEvadeButton.onclick = () => activateKingEvade(kingEvadeButton);
                document.getElementById('controls').insertBefore(kingEvadeButton, document.getElementById('guard-honour-button'));
            }
            let necromancerZombieButton = document.getElementById('necromancer-summon-zombie-button');
            if (!necromancerZombieButton) {
                necromancerZombieButton = document.createElement('button');
                necromancerZombieButton.id = 'necromancer-summon-zombie-button';
                necromancerZombieButton.textContent = 'Summon Zombie';
                necromancerZombieButton.style.display = 'none';
                necromancerZombieButton.onclick = () => activateNecromancerSummon('zombie', necromancerZombieButton);
                document.getElementById('controls').insertBefore(necromancerZombieButton, document.getElementById('guard-honour-button'));
            }
            let necromancerSpectreButton = document.getElementById('necromancer-summon-spectre-button');
            if (!necromancerSpectreButton) {
                necromancerSpectreButton = document.createElement('button');
                necromancerSpectreButton.id = 'necromancer-summon-spectre-button';
                necromancerSpectreButton.textContent = 'Summon Spectre';
                necromancerSpectreButton.style.display = 'none';
                necromancerSpectreButton.onclick = () => activateNecromancerSummon('spectre', necromancerSpectreButton);
                document.getElementById('controls').insertBefore(necromancerSpectreButton, document.getElementById('guard-honour-button'));
            }
            let necromancerLichButton = document.getElementById('necromancer-summon-lich-button');
            if (!necromancerLichButton) {
                necromancerLichButton = document.createElement('button');
                necromancerLichButton.id = 'necromancer-summon-lich-button';
                necromancerLichButton.textContent = 'Summon Lich';
                necromancerLichButton.style.display = 'none';
                necromancerLichButton.onclick = () => activateNecromancerSummon('lich', necromancerLichButton);
                document.getElementById('controls').insertBefore(necromancerLichButton, document.getElementById('guard-honour-button'));
            }
            let necromancerUndeadButton = document.getElementById('necromancer-summon-undead-button');
            if (!necromancerUndeadButton) {
                necromancerUndeadButton = document.createElement('button');
                necromancerUndeadButton.id = 'necromancer-summon-undead-button';
                necromancerUndeadButton.textContent = 'Summon Undead';
                necromancerUndeadButton.style.display = 'none';
                necromancerUndeadButton.onclick = () => activateNecromancerSummon('undead', necromancerUndeadButton);
                document.getElementById('controls').insertBefore(necromancerUndeadButton, document.getElementById('guard-honour-button'));
            }
            let lichUndeadChampionButton = document.getElementById('lich-summon-undead-champion-button');
            if (!lichUndeadChampionButton) {
                lichUndeadChampionButton = document.createElement('button');
                lichUndeadChampionButton.id = 'lich-summon-undead-champion-button';
                lichUndeadChampionButton.textContent = 'Summon Undead Champion';
                lichUndeadChampionButton.style.display = 'none';
                lichUndeadChampionButton.onclick = () => activateNecromancerSummon('undeadchampion', lichUndeadChampionButton);
                document.getElementById('controls').insertBefore(lichUndeadChampionButton, document.getElementById('guard-honour-button'));
            }
            let necromancerTeleportButton = document.getElementById('necromancer-teleport-button');
            if (!necromancerTeleportButton) {
                necromancerTeleportButton = document.createElement('button');
                necromancerTeleportButton.id = 'necromancer-teleport-button';
                necromancerTeleportButton.textContent = 'Necro Teleport';
                necromancerTeleportButton.style.display = 'none';
                necromancerTeleportButton.onclick = () => activateTeleport(necromancerTeleportButton);
                document.getElementById('controls').insertBefore(necromancerTeleportButton, document.getElementById('guard-honour-button'));
            }
            let undeadChampionTeleportButton = document.getElementById('undead-champion-teleport-button');
            if (!undeadChampionTeleportButton) {
                undeadChampionTeleportButton = document.createElement('button');
                undeadChampionTeleportButton.id = 'undead-champion-teleport-button';
                undeadChampionTeleportButton.textContent = 'UC Teleport';
                undeadChampionTeleportButton.style.display = 'none';
                undeadChampionTeleportButton.onclick = () => activateTeleport(undeadChampionTeleportButton);
                document.getElementById('controls').insertBefore(undeadChampionTeleportButton, document.getElementById('guard-honour-button'));
            }
            let voidBlastButton = document.getElementById('void-blast-button');
            if (!voidBlastButton) {
                voidBlastButton = document.createElement('button');
                voidBlastButton.id = 'void-blast-button';
                voidBlastButton.textContent = 'Void Blast';
                voidBlastButton.style.display = 'none';
                voidBlastButton.onclick = () => activateVoidBlast(voidBlastButton);
                document.getElementById('controls').insertBefore(voidBlastButton, document.getElementById('guard-honour-button'));
            }
            if (!darkVoidButton) {
                darkVoidButton = document.createElement('button');
                darkVoidButton.id = 'dark-void-button';
                darkVoidButton.textContent = 'Dark Void';
                darkVoidButton.style.display = 'none';
                darkVoidButton.onclick = () => activateDarkVoid(darkVoidButton);
                document.getElementById('controls').insertBefore(darkVoidButton, document.getElementById('guard-honour-button'));
            }
            let championSummonNecroButton = document.getElementById('champion-summon-necro-button');
            if (!championSummonNecroButton) {
                championSummonNecroButton = document.createElement('button');
                championSummonNecroButton.id = 'champion-summon-necro-button';
                championSummonNecroButton.textContent = 'Summon Necromancer';
                championSummonNecroButton.style.display = 'none';
                championSummonNecroButton.onclick = () => activateChampionSummon('Necromancer', championSummonNecroButton);
                document.getElementById('controls').insertBefore(championSummonNecroButton, document.getElementById('guard-honour-button'));
            }
            let championSummonHuntsmanButton = document.getElementById('champion-summon-huntsman-button');
            if (!championSummonHuntsmanButton) {
                championSummonHuntsmanButton = document.createElement('button');
                championSummonHuntsmanButton.id = 'champion-summon-huntsman-button';
                championSummonHuntsmanButton.textContent = 'Summon Huntsman';
                championSummonHuntsmanButton.style.display = 'none';
                championSummonHuntsmanButton.onclick = () => activateChampionSummon('Huntsman', championSummonHuntsmanButton);
                document.getElementById('controls').insertBefore(championSummonHuntsmanButton, document.getElementById('guard-honour-button'));
            }
            if (!huntsmanBurstButton) {
                huntsmanBurstButton = document.createElement('button');
                huntsmanBurstButton.id = 'huntsman-burst-button';
                huntsmanBurstButton.textContent = 'Stalking Burst';
                huntsmanBurstButton.style.display = 'none';
                huntsmanBurstButton.onclick = () => activateHuntsmanBurst(huntsmanBurstButton);
                document.getElementById('controls').insertBefore(huntsmanBurstButton, document.getElementById('guard-honour-button'));
            }
            let barrageButton = document.getElementById('barrage-button');
            if (!barrageButton) {
                barrageButton = document.createElement('button');
                barrageButton.id = 'barrage-button';
                barrageButton.textContent = 'Barrage';
                barrageButton.style.display = 'none';
                barrageButton.onclick = () => activateBarrage(barrageButton);
                document.getElementById('controls').insertBefore(barrageButton, document.getElementById('guard-honour-button'));
            }

            turnButton.style.display = 'none';
            turnMoveButton.style.display = 'none';
            turnShootButton.style.display = 'none';
            archerMoveDiagShootButton.style.display = 'none';
            archerDiag2ShootButton.style.display = 'none';
            guardHonourButton.style.display = 'none';
            if (moralBoostButton) moralBoostButton.style.display = 'none';
            if (kingShotButton) kingShotButton.style.display = 'none';
            if (kingEvadeButton) kingEvadeButton.style.display = 'none';
            teleportButton.style.display = 'none';
            teleportSwapButton.style.display = 'none';
            chargeButton.style.display = 'none';
            if (ogreRageButton) {
                ogreRageButton.style.display = 'none';
                ogreRageButton.disabled = true;
            }
            infernoButton.style.display = 'none'; // Hide Inferno button by default
            if (strafeButton) {
                if (turnAndMoveMode) {
                    strafeButton.style.display = 'none';
                    strafeButton.disabled = true;
                } else {
                    strafeButton.style.display = 'none';
                }
            }
            summonSpectreButton.style.display = 'none'; // Hide Summon Spectre button by default
            if (energyBlastButton) {
                energyBlastButton.style.display = 'none';
                energyBlastButton.disabled = true;
            }
            if (sacrificeButton) {
                sacrificeButton.style.display = 'none';
                sacrificeButton.disabled = true;
            }
            if (ballistaRangeButton) ballistaRangeButton.style.display = 'none';
            if (ballistaDoubleButton) ballistaDoubleButton.style.display = 'none';
            if (elephantryChargeButton) elephantryChargeButton.style.display = 'none';
            if (elephantryExtendedButton) elephantryExtendedButton.style.display = 'none';
            if (elephantryMoveShootButton) elephantryMoveShootButton.style.display = 'none';
            if (pistolierMoveShootButton) pistolierMoveShootButton.style.display = 'none';
            if (fusilierCrackShotButton) fusilierCrackShotButton.style.display = 'none';
            if (fusilierStrafeButton) fusilierStrafeButton.style.display = 'none';
            if (kingSummonPistolierButton) kingSummonPistolierButton.style.display = 'none';
            if (kingSummonFusilierButton) kingSummonFusilierButton.style.display = 'none';
            if (necromancerZombieButton) necromancerZombieButton.style.display = 'none';
            if (necromancerSpectreButton) necromancerSpectreButton.style.display = 'none';
            if (necromancerLichButton) necromancerLichButton.style.display = 'none';
            if (necromancerUndeadButton) necromancerUndeadButton.style.display = 'none';
            if (lichUndeadChampionButton) lichUndeadChampionButton.style.display = 'none';
            if (necromancerTeleportButton) necromancerTeleportButton.style.display = 'none';
            if (undeadChampionTeleportButton) undeadChampionTeleportButton.style.display = 'none';
            if (voidBlastButton) voidBlastButton.style.display = 'none';
            if (darkVoidButton) {
                darkVoidButton.style.display = 'none';
                darkVoidButton.disabled = true;
                darkVoidButton.removeAttribute('title');
            }
            if (championSummonNecroButton) championSummonNecroButton.style.display = 'none';
            if (championSummonHuntsmanButton) championSummonHuntsmanButton.style.display = 'none';
            if (huntsmanBurstButton) huntsmanBurstButton.style.display = 'none';
            if (barrageButton) barrageButton.style.display = 'none';
            if (lichSoulBlastButton) {
                lichSoulBlastButton.style.display = 'none';
                lichSoulBlastButton.disabled = true;
                lichSoulBlastButton.removeAttribute('title');
            }

            if (selectedPiece) {
                const piece = board[selectedPiece.row][selectedPiece.col];
                if (piece && piece.player === currentPlayer && !movedPieces.has(`${selectedPiece.row},${selectedPiece.col}`) && !lastAction?.move) {
                    if (turnablePieces.includes(piece.type)) {
                        turnButton.style.display = 'inline';
                        turnButton.disabled = movesLeft < turnCosts[piece.type];
                        if (piece.type === 'Infantry') {
                            turnMoveButton.style.display = 'inline';
                            turnMoveButton.disabled = movesLeft < 2;
                        }
                        if (piece.type === 'Archer') {
                            turnShootButton.style.display = 'inline';
                            turnShootButton.disabled = movesLeft < 2;
                        }
                    }
                    if (piece.type === 'Archer' && movesLeft >= 2) {
                        if (archerMoveDiagShootUsed[currentPlayer] < 2) {
                            archerMoveDiagShootButton.style.display = 'inline';
                            archerMoveDiagShootButton.disabled = false;
                        }
                        if (archerDiag2ShootUsed[currentPlayer] < 2) {
                            archerDiag2ShootButton.style.display = 'inline';
                            archerDiag2ShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'King' && !kingSpecialUsed[currentPlayer] && movesLeft >= 2) {
                        guardHonourButton.style.display = 'inline';
                        guardHonourButton.disabled = false;
                    }
                    if (piece.type === 'King') {
                        const kingPiece = piece;
                        const canUseKingShot = hasKingShotAvailableForPiece(kingPiece);
                        if (moralBoostButton) {
                            updateMoralBoostButtonLabel(currentPlayer);
                            const eligibleBoost = moralBoostSuccesses[currentPlayer] < MORAL_BOOST_SUCCESS_LIMIT && movesLeft === 1;
                            moralBoostButton.style.display = eligibleBoost ? 'inline' : 'none';
                            moralBoostButton.disabled = !eligibleBoost;
                        }
                        if (kingShotButton && canUseKingShot && movesLeft >= 1 && isKingAdjacentToGuard(selectedPiece.row, selectedPiece.col, currentPlayer)) {
                            const targets = getKingShotTargets(selectedPiece.row, selectedPiece.col, currentPlayer);
                            if (targets.length) {
                                kingShotButton.style.display = 'inline';
                                kingShotButton.disabled = false;
                            }
                        }
                        if (kingEvadeButton && !kingEvadeUsed[currentPlayer] && isKingThreatened(currentPlayer)) {
                            kingEvadeButton.style.display = 'inline';
                            kingEvadeButton.disabled = false;
                        }
                    }
                    // Show King summon buttons in Expert-tier modes
                    if (piece.type === 'King' && (gameVariant === '36s-expert' || gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                        const hasSlot = hasBackRowSpawnSlot(currentPlayer);
                        updateKingSummonButtons({ hasBackRowSlot: hasSlot, showButtons: true });
                    }
                    if (piece.type === 'Lich' && lichSoulBlastButton) {
                        const range = getLichSoulBlastRange(currentPlayer);
                        if (range > 0 && movesLeft >= LICH_SOUL_BLAST_COST) {
                            const targets = getLichSoulBlastTargets(selectedPiece.row, selectedPiece.col, range);
                            if (targets.length) {
                                lichSoulBlastButton.style.display = 'inline';
                                lichSoulBlastButton.disabled = false;
                                lichSoulBlastButton.title = `Range ${range} Soul Blast`;
                            } else {
                                lichSoulBlastButton.style.display = 'inline';
                                lichSoulBlastButton.disabled = true;
                                lichSoulBlastButton.title = 'No valid Soul Blast targets.';
                            }
                        }
                    }
                    if (piece.type === 'Champion' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                        const hasSlot = hasBackRowSpawnSlot(currentPlayer);
                        if (championSummonNecroButton) {
                            // Only show Summon Necromancer button if prerequisites are met:
                            // 1. Player has sacrificed their Wizard, OR
                            // 2. 10+ pieces have been captured collectively
                            const canSummonNecro = canChampionSummonNecromancer(currentPlayer) && hasSlot;
                            if (canSummonNecro) {
                                championSummonNecroButton.style.display = 'inline';
                                championSummonNecroButton.disabled = movesLeft < 2;
                            } else {
                                championSummonNecroButton.style.display = 'none';
                            }
                        }
                        if (championSummonHuntsmanButton) {
                            const canSummonHuntsman = canChampionSummonHuntsman(currentPlayer) && hasSlot;
                            if (canSummonHuntsman) {
                                championSummonHuntsmanButton.style.display = 'inline';
                                championSummonHuntsmanButton.disabled = movesLeft < 2;
                            } else {
                                championSummonHuntsmanButton.style.display = 'none';
                            }
                        }
                    }
                    if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                        const pieceKey = board[selectedPiece.row][selectedPiece.col];
                        const teleportsUsed = getNecromancerTeleportCount(pieceKey);
                        if (movesLeft >= 2) {
                            const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                            const availableBackRow = Array.from({ length: COLS }, (_, c) => c).some(c => !board[backRow][c]);
                            const maxZombies = getMaxZombies(currentPlayer);
                            if (zombiesSummoned[currentPlayer] < maxZombies && availableBackRow) {
                                necromancerZombieButton.style.display = 'inline';
                                necromancerZombieButton.disabled = false;
                            }
                            if (spectresSummoned[currentPlayer] < 2 && availableBackRow) {
                                necromancerSpectreButton.style.display = 'inline';
                                necromancerSpectreButton.disabled = false;
                            }
                            if (necromancerLichButton) {
                                const souls = (capturedPieces[currentPlayer] || []).length;
                                let reason = '';
                                if (!availableBackRow) {
                                    reason = 'No open squares on the back row.';
                                } else if (lichesSummoned[currentPlayer] >= LICH_SUMMON_LIMIT) {
                                    reason = 'Lich already conjured.';
                                } else if (souls < LICH_SUMMON_SOUL_THRESHOLD) {
                                    const needed = LICH_SUMMON_SOUL_THRESHOLD - souls;
                                    const captureLabel = needed === 1 ? 'one more captured enemy' : `${needed} more captured enemies`;
                                    reason = `Need ${captureLabel}.`;
                                }
                                necromancerLichButton.style.display = 'inline';
                                if (reason) {
                                    necromancerLichButton.disabled = true;
                                    necromancerLichButton.title = reason;
                                } else {
                                    necromancerLichButton.disabled = false;
                                    necromancerLichButton.removeAttribute('title');
                                }
                            }
                            if (teleportsUsed < 2) {
                                necromancerTeleportButton.style.display = 'inline';
                                necromancerTeleportButton.disabled = false;
                            }
                        }
                    }
                    if (piece.type === 'UndeadChampion') {
                        const pieceObj = board[selectedPiece.row][selectedPiece.col];
                        // Show teleport button
                        if (undeadChampionTeleportButton && !undeadChampionTeleportUsed.has(pieceObj) && movesLeft >= 2) {
                            undeadChampionTeleportButton.style.display = 'inline';
                            undeadChampionTeleportButton.disabled = false;
                        }
                        // Show Void Blast button
                        if (voidBlastButton) {
                            const cooldown = undeadChampionRangedCooldown.get(pieceObj) || 0;
                            voidBlastButton.style.display = 'inline';
                            if (movesLeft >= 2 && cooldown === 0) {
                                voidBlastButton.disabled = false;
                                voidBlastButton.removeAttribute('title');
                            } else {
                                voidBlastButton.disabled = true;
                                if (cooldown > 0) {
                                    voidBlastButton.title = `Cooldown: ${cooldown} round${cooldown > 1 ? 's' : ''}`;
                                } else {
                                    voidBlastButton.title = 'Not enough move points';
                                }
                            }
                        }
                    }
                    if ((piece.type === 'Necromancer' || piece.type === 'Lich') && darkVoidButton) {
                        const darkVoidTargets = getDarkVoidTargets(selectedPiece.row, selectedPiece.col);
                        darkVoidButton.style.display = 'inline';
                        if (darkVoidUses[currentPlayer] >= DARK_VOID_USE_LIMIT) {
                            darkVoidButton.disabled = true;
                            darkVoidButton.title = `Limit ${DARK_VOID_USE_LIMIT} reached`;
                        } else if (movesLeft >= DARK_VOID_COST && darkVoidTargets.length) {
                            darkVoidButton.disabled = false;
                            darkVoidButton.removeAttribute('title');
                        } else {
                            darkVoidButton.disabled = true;
                            darkVoidButton.title = movesLeft < DARK_VOID_COST ? 'Not enough move points' : 'No adjacent squares available';
                        }
                    }
                    if (necromancerUndeadButton && (piece.type === 'Necromancer' || piece.type === 'Lich')) {
                        const undeadTargets = getUndeadSummonTargets();
                        const limitReached = undeadSummoned[currentPlayer] >= UNDEAD_SUMMON_LIMIT;
                        let reason = '';
                        if (limitReached) {
                            reason = `Limit ${UNDEAD_SUMMON_LIMIT} reached.`;
                        } else if (!undeadTargets.length) {
                            reason = 'Need an empty square adjacent to Dark Void.';
                        } else if (movesLeft < UNDEAD_SUMMON_COST) {
                            reason = `Need ${UNDEAD_SUMMON_COST} move points.`;
                        }
                        necromancerUndeadButton.style.display = 'inline';
                        if (reason) {
                            necromancerUndeadButton.disabled = true;
                            necromancerUndeadButton.title = reason;
                        } else {
                            necromancerUndeadButton.disabled = false;
                            necromancerUndeadButton.removeAttribute('title');
                        }
                    }
                    if (lichUndeadChampionButton && piece.type === 'Lich') {
                        const undeadTargets = getUndeadSummonTargets();
                        const limitReached = (undeadChampionsSummoned[currentPlayer] || 0) >= UNDEAD_CHAMPION_SUMMON_LIMIT;
                        let reason = '';
                        if (limitReached) {
                            reason = `Undead Champion already summoned.`;
                        } else if (!undeadTargets.length) {
                            reason = 'Need an empty square adjacent to Dark Void.';
                        } else if (movesLeft < UNDEAD_SUMMON_COST) {
                            reason = `Need ${UNDEAD_SUMMON_COST} move points.`;
                        }
                        lichUndeadChampionButton.style.display = 'inline';
                        if (reason) {
                            lichUndeadChampionButton.disabled = true;
                            lichUndeadChampionButton.title = reason;
                        } else {
                            lichUndeadChampionButton.disabled = false;
                            lichUndeadChampionButton.removeAttribute('title');
                        }
                    }
                    if (piece.type === 'Wizard' && wizardTeleportUsed[currentPlayer] < 2 && movesLeft >= 2) {
                        teleportButton.style.display = 'inline';
                        teleportButton.disabled = false;
                    }
                    if (piece.type === 'Wizard' && !wizardTeleportSwapUsed[currentPlayer] && movesLeft >= 2 && opponentHasWizards(currentPlayer)) {
                        teleportSwapButton.style.display = 'inline';
                        teleportSwapButton.disabled = false;
                    }
                    if (piece.type === 'Cavalry' && !cavalryChargeUsed[currentPlayer] && movesLeft >= 2) {
                        chargeButton.style.display = 'inline';
                        chargeButton.disabled = false;
                    }
                    if (ogreRageButton && piece.type === 'Ogre' && !ogreRageUsed[currentPlayer] && movesLeft >= 2) {
                        ogreRageButton.style.display = 'inline';
                        ogreRageButton.disabled = false;
                    }
                    // Show Inferno button
                    if (piece.type === 'Dragon' && !dragonInfernoUsed[currentPlayer] && movesLeft >= 2) {
                        infernoButton.style.display = 'inline';
                        infernoButton.disabled = false;
                    }
                    // Show Strafe button for Wizard or Dragon
                    if (!turnAndMoveMode && ((piece.type === 'Wizard' && wizardStrafeUsed[currentPlayer] < 2 && movesLeft >= 2) ||
                        (piece.type === 'Dragon' && dragonStrafeUsed[currentPlayer] < 2 && movesLeft >= 2))) {
                        strafeButton.style.display = 'inline';
                        strafeButton.disabled = false;
                    }
                    // Show Summon Spectre button for Wizard
                    if (piece.type === 'Wizard' && movesLeft >= 2 && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer]) {
                        const totalCaptured = getTotalCapturedCount();
                        if (totalCaptured >= 5) {
                            summonSpectreButton.style.display = 'inline';
                            summonSpectreButton.disabled = false;
                        }
                    }
                    if (isSpellVariant() && isSpellCasterPiece(piece)) {
                        if (energyBlastButton) {
                            const totalUses = energyBlastUses[currentPlayer] || 0;
                            const uses = energyBlastUsage.get(piece) || 0;
                            if (totalUses < 2 && uses < 2) {
                                const blastCost = uses === 0 ? 2 : 3;
                                energyBlastButton.style.display = 'inline';
                                energyBlastButton.disabled = movesLeft < blastCost;
                            } else {
                                energyBlastButton.style.display = 'none';
                                energyBlastButton.disabled = true;
                            }
                        }
                        if (sacrificeButton) {
                            sacrificeButton.style.display = 'inline';
                            sacrificeButton.disabled = movesLeft < 3 || sacrificeAttemptedPieces.has(piece);
                        }
                    }
                    if (huntsmanBurstButton && piece.type === 'Huntsman' && gameVariant === '36s-supreme') {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col}`;
                        huntsmanBurstButton.style.display = 'inline';
                        huntsmanBurstButton.disabled = movesLeft < 2 || pendingHuntsmanBurst !== null || movedPieces.has(pieceKey);
                    }
                    if (barrageButton && (piece.type === 'King' || piece.type === 'Champion') && gameVariant === '36s-supreme') {
                        const hasBoosts = moralBoostSuccesses[currentPlayer] >= BARRAGE_REQUIRED_MORAL_BOOSTS;
                        const championAlive = isChampionPresent(currentPlayer);
                        const underLimit = canUseBarrage(currentPlayer);
                        const canUseBarrageButton = hasBoosts && championAlive && movesLeft >= BARRAGE_COST && underLimit;
                        barrageButton.style.display = canUseBarrageButton ? 'inline' : 'none';
                        barrageButton.disabled = !canUseBarrageButton;
                    }
                    if (piece.type === 'Ballista' && movesLeft >= 2) {
                        if (!ballistaRangeBoostUsedThisTurn[currentPlayer]) {
                            ballistaRangeButton.style.display = 'inline';
                            ballistaRangeButton.disabled = false;
                        }
                        if (ballistaDoubleTimeUsed[currentPlayer] < 2) {
                            ballistaDoubleButton.style.display = 'inline';
                            ballistaDoubleButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Elephantry' && movesLeft >= 2) {
                        if (!elephantryChargeUsed.has(piece)) {
                            elephantryChargeButton.style.display = 'inline';
                            elephantryChargeButton.disabled = false;
                        }
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                        // Initialize shots remaining if not set
                        if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                            elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
                        }
                        const tripleShotMoves = getElephantryExtendedRangeMoves(selectedPiece.row, selectedPiece.col);
                        if (elephantryExtendedRangeShotsRemaining[pieceKey] > 0 && tripleShotMoves.length > 0) {
                            elephantryExtendedButton.style.display = 'inline';
                            elephantryExtendedButton.disabled = false;
                            elephantryExtendedButton.textContent = `Triple Shot (${elephantryExtendedRangeShotsRemaining[pieceKey]})`;
                        } else {
                            elephantryExtendedButton.style.display = 'none';
                        }
                        // Show Move+Shoot button if there are valid move+shoot positions
                        const moveShootMoves = validMoves.filter(m => m.special === 'elephantryMoveShoot');
                        if (moveShootMoves.length > 0) {
                            elephantryMoveShootButton.style.display = 'inline';
                            elephantryMoveShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Pistolier' && movesLeft >= 2) {
                        // Show Move+Shoot button if there are valid move+shoot positions
                        const moveShootMoves = validMoves.filter(m => m.special === 'pistolierMoveShoot');
                        if (moveShootMoves.length > 0) {
                            pistolierMoveShootButton.style.display = 'inline';
                            pistolierMoveShootButton.disabled = false;
                        }
                    }
                    if (piece.type === 'Fusilier' && movesLeft >= 2) {
                        const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
                        // Initialize counts if not set
                        if (!(pieceKey in fusilierCrackShotCount)) {
                            fusilierCrackShotCount[pieceKey] = 3;
                        }
                        if (!(pieceKey in fusilierStrafeCount)) {
                            fusilierStrafeCount[pieceKey] = 2;
                        }
                        const fusilierPiece = piece;
                        const fusilierOnCooldown = fusilierShotLastTurn[currentPlayer].has(fusilierPiece) ||
                            fusilierShotThisTurn[currentPlayer].has(fusilierPiece);
                        // Show Crack Shot button if uses remaining and not on cooldown
                        if (fusilierCrackShotCount[pieceKey] > 0 && !fusilierOnCooldown) {
                            fusilierCrackShotButton.style.display = 'inline';
                            fusilierCrackShotButton.disabled = false;
                            fusilierCrackShotButton.textContent = `Crack Shot (${fusilierCrackShotCount[pieceKey]})`;
                        } else {
                            fusilierCrackShotButton.style.display = 'none';
                        }
                        // Show Strafe button if uses remaining
                        if (!turnAndMoveMode && fusilierStrafeCount[pieceKey] > 0) {
                            fusilierStrafeButton.style.display = 'inline';
                            fusilierStrafeButton.disabled = false;
                            fusilierStrafeButton.textContent = `Strafe (${fusilierStrafeCount[pieceKey]})`;
                        }
                    }
                }
            }
        }

        function updateScoreDisplay() {
            const playerScoreEl = document.getElementById('player-score-value');
            const aiScoreEl = document.getElementById('ai-score-value');
            const aiNameEl = document.getElementById('ai-name-label');
            if (playerScoreEl) {
                playerScoreEl.textContent = `Score: ${scores['W']}`;
            }
            if (aiScoreEl) {
                aiScoreEl.textContent = `Score: ${scores['B']}`;
            }
            if (aiNameEl) {
                aiNameEl.textContent = getOpponentDisplayName();
            }
        }

        function showPieceInfo(piece, player) {
            const infoBox = document.getElementById('info-box');
            if (!piece) {
                infoBox.style.display = 'none';
                infoBox.innerHTML = '';
                return;
            }
            const info = pieceInfo[piece.type];
            const lifeCount = piece.lives || 0;
            const lifeSymbols = lifeCount > 0 ? Array(lifeCount).fill('').join(' ') : '';
            const livesHtml = lifeSymbols ? `<div class="piece-lives">${lifeSymbols}</div>` : '';
            infoBox.style.display = 'block';
            infoBox.innerHTML = `
                <strong>${player === 'W' ? 'White' : 'Black'} ${piece.type}</strong><br>
                ${livesHtml}
                <strong>Move Points:</strong> ${info.points}<br>
                <strong>Score Value:</strong> ${pieceValues[piece.type]} points<br>
                <strong>Extra Info:</strong> ${info.extra}${piece.facing ? `<br><strong>Facing:</strong> ${piece.facing} (${facingIcons[piece.facing]})` : ''}
            `;
            constrainElementToBoardBounds(infoBox, getBoardAnchorRect());
        }

        function updateGameLog() {
            const logDiv = document.getElementById('game-log');
            logDiv.innerHTML = gameLog.join('<br>');
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function getValidTurnDirections(currentFacing) {
            const validDirections = {
                'U': ['L', 'R'],
                'D': ['L', 'R'],
                'L': ['U', 'D'],
                'R': ['U', 'D']
            };
            return validDirections[currentFacing] || [];
        }

        function isSpellVariant() {
            return gameVariant === '36s-supreme';
        }

        function isSpellCasterPiece(piece) {
            return !!piece && (piece.type === 'Wizard' || piece.type === 'Necromancer');
        }

        function getSpellDirectionOptions(player) {
            const forwardStep = player === 'W' ? -1 : 1;
            return [
                { id: 'forward', label: 'Forward', dr: forwardStep, dc: 0 },
                { id: 'diagLeft', label: 'Forward-Left', dr: forwardStep, dc: player === 'W' ? -1 : 1 },
                { id: 'diagRight', label: 'Forward-Right', dr: forwardStep, dc: player === 'W' ? 1 : -1 }
            ];
        }

        function openSpellDirectionModal(action) {
            const modal = document.getElementById('spell-direction-modal');
            const select = document.getElementById('spell-direction-select');
            if (!modal || !select) return;
            const piece = board[action.row]?.[action.col];
            if (!piece) return;
            const options = getSpellDirectionOptions(piece.player);
            if (!options.length) return;
            select.innerHTML = options.map(opt => `<option value="${opt.id}">${opt.label}</option>`).join('');
            document.getElementById('spell-direction-title').textContent = action.type === 'energyBlast'
                ? 'Select Energy Blast Direction'
                : 'Select Direction';
            pendingSpellAction = { ...action, directions: options, player: piece.player };
            modal.style.display = 'block';
        }

        function closeSpellDirectionModal(options = {}) {
            const { keepGlow = false } = options;
            const modal = document.getElementById('spell-direction-modal');
            if (modal) {
                modal.style.display = 'none';
            }
            pendingSpellAction = null;
            if (!keepGlow) {
                activeEnergyBlastCost = null;
                removeEnergyBlastGlow();
            }
        }

        function confirmSpellDirection() {
            if (!pendingSpellAction) {
                closeSpellDirectionModal();
                return;
            }
            const select = document.getElementById('spell-direction-select');
            const directionId = select ? select.value : null;
            const direction = pendingSpellAction.directions.find(opt => opt.id === directionId) || pendingSpellAction.directions[0];
            const action = { ...pendingSpellAction };
            closeSpellDirectionModal({ keepGlow: true });
            if (action.type === 'energyBlast' && direction) {
                performEnergyBlast(action.row, action.col, direction);
            }
        }

        function startEnergyBlastFlipSequence(context) {
            energyBlastFlipContext = {
                context,
                flips: [],
                successes: 0
            };
            pauseGameForEnergyBlastFlips();
            runNextEnergyBlastFlip();
        }

        function runNextEnergyBlastFlip() {
            const ctx = energyBlastFlipContext;
            if (!ctx) return;
            if (ctx.flips.length >= ENERGY_BLAST_FLIP_COUNT) {
                coinTossEnergyBlastMode = null;
                updateCoinTossEnergyBlastProgress();
                energyBlastFlipContext = null;
                resumeGameForEnergyBlastFlips();
                completeEnergyBlastAfterRange(ctx.context, ctx.successes, ctx.flips);
                return;
            }
            const flipNumber = ctx.flips.length + 1;
            coinTossEnergyBlastMode = { successes: ctx.successes, total: ENERGY_BLAST_FLIP_COUNT };
            updateCoinTossEnergyBlastProgress();
            pauseGameForEnergyBlastFlips();
            performCoinToss(
                'Energy Blast',
                `Flip ${flipNumber} of ${ENERGY_BLAST_FLIP_COUNT}`,
                (result) => {
                    if (!energyBlastFlipContext) {
                        return;
                    }
                    ctx.flips.push(result);
                    if (result) ctx.successes++;
                    if (coinTossEnergyBlastMode) {
                        coinTossEnergyBlastMode.successes = ctx.successes;
                        updateCoinTossEnergyBlastProgress();
                    }
                    pauseGameForEnergyBlastFlips();
                    runNextEnergyBlastFlip();
                },
                true,
                false
            );
        }

        function evaluateEnergyBlastDirection(row, col, direction, piece) {
            if (!direction) return 0;
            let expected = 0;
            let targetRow = row;
            let targetCol = col;
            for (let step = 1; step <= ENERGY_BLAST_FLIP_COUNT; step++) {
                targetRow += direction.dr;
                targetCol += direction.dc;
                if (!isValid(targetRow, targetCol)) break;
                const occupant = board[targetRow][targetCol];
                if (!occupant || occupant.player === piece.player) continue;
                const baseValue = aiPieceValues[occupant.type] !== undefined
                    ? aiPieceValues[occupant.type]
                    : (pieceValues[occupant.type] || 0);
                let value = baseValue;
                if (occupant.type === 'King') {
                    value += baseValue * 50;
                } else if (occupant.type === 'Champion') {
                    value += 6;
                }
                expected += value * (ENERGY_BLAST_STEP_PROBABILITIES[step] || 0);
            }
            return expected;
        }

        function findAiEnergyBlastOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || !isSpellVariant() || availableMoves < 2) return null;
            if ((energyBlastUses[player] || 0) >= 2) return null;
            const opportunities = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player) continue;
                    if (!isSpellCasterPiece(piece)) continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    const uses = energyBlastUsage.get(piece) || 0;
                    if (uses >= 2) continue;
                    const cost = uses === 0 ? 2 : 3;
                    if (availableMoves < cost) continue;
                    const directions = getSpellDirectionOptions(player);
                    for (const direction of directions) {
                        const expected = evaluateEnergyBlastDirection(r, c, direction, piece);
                        if (expected <= 0) continue;
                        // Encourage Energy Blast usage with 1.5x multiplier, reduce cost penalty
                        const score = expected * 1.5 - cost * 1.0;
                        opportunities.push({ score, from: [r, c], direction, cost });
                    }
                }
            }
            if (!opportunities.length) return null;
            opportunities.sort((a, b) => b.score - a.score);
            const best = opportunities[0];
            if (best.score < ENERGY_BLAST_AI_THRESHOLD) return null;
            return {
                type: 'energyBlast',
                from: best.from,
                direction: best.direction,
                cost: best.cost,
                prepaid: Math.min(2, best.cost)
            };
        }

        function listSacrificeTargets(row, col, player) {
            const enemy = getOpponent(player);
            const targets = [];
            const orthogonal = [[1, 0], [-1, 0], [0, 1], [0, -1]];
            for (const [dr, dc] of orthogonal) {
                for (let step = 1; step <= 2; step++) {
                    const targetRow = row + dr * step;
                    const targetCol = col + dc * step;
                    if (!isValid(targetRow, targetCol)) break;
                    const occupant = board[targetRow]?.[targetCol];
                    if (occupant && occupant.player === enemy) {
                        targets.push({ row: targetRow, col: targetCol, piece: occupant });
                    }
                }
            }
            const diagonals = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of diagonals) {
                const targetRow = row + dr;
                const targetCol = col + dc;
                if (!isValid(targetRow, targetCol)) continue;
                const occupant = board[targetRow]?.[targetCol];
                if (occupant && occupant.player === enemy) {
                    targets.push({ row: targetRow, col: targetCol, piece: occupant });
                }
            }
            return targets;
        }

        function evaluateSacrificeTargets(player, piece, targets) {
            if (!targets.length) return -Infinity;
            let captureValue = 0;
            let kingBonus = 0;
            for (const target of targets) {
                const value = aiPieceValues[target.piece.type] !== undefined
                    ? aiPieceValues[target.piece.type]
                    : (pieceValues[target.piece.type] || 0);
                captureValue += value;
                if (target.piece.type === 'King') {
                    kingBonus = Math.max(kingBonus, value * 80);
                } else if (target.piece.type === 'Champion') {
                    captureValue += 6;
                }
            }
            const expectedCapture = captureValue * SACRIFICE_SUCCESS_PROBABILITY + kingBonus;
            const selfValue = (aiPieceValues[piece.type] || pieceValues[piece.type] || 0) * SACRIFICE_SUCCESS_PROBABILITY;
            const movePenalty = 3 * 0.8; // Reduced penalty to encourage usage
            // Add 1.4x multiplier to encourage Sacrifice usage
            return (expectedCapture - selfValue - movePenalty) * 1.4;
        }

        function findAiSacrificeOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || !isSpellVariant() || availableMoves < 3) return null;
            let best = null;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player) continue;
                    if (!isSpellCasterPiece(piece)) continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    if (sacrificeAttemptedPieces.has(piece)) continue;
                    const targets = listSacrificeTargets(r, c, player);
                    if (!targets.length) continue;
                    const score = evaluateSacrificeTargets(player, piece, targets);
                    if (!best || score > best.score) {
                        best = { score, from: [r, c] };
                    }
                }
            }
            if (best && best.score > SACRIFICE_AI_THRESHOLD) {
                return { type: 'sacrifice', from: best.from, cost: 3 };
            }
            return null;
        }

        function findAiZombieSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return null;
            const maxZombies = getMaxZombies(player);
            if ((zombiesSummoned[player] || 0) >= maxZombies) return null;
            const candidates = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Necromancer') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    candidates.push({ row: r, col: c });
                }
            }
            if (!candidates.length || !hasBackRowSpawnSlot(player)) return null;
            const spawnCol = findBackRowSpawnColumn(player);
            if (spawnCol === null) return null;
            const chosen = candidates[Math.floor(Math.random() * candidates.length)];
            return {
                type: 'summon',
                special: 'summonZombie',
                from: [chosen.row, chosen.col],
                pos: [getBackRow(player), spawnCol],
                cost: 2
            };
        }

        function findAiUndeadSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < UNDEAD_SUMMON_COST) return null;
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return null;
            if ((undeadSummoned[player] || 0) >= UNDEAD_SUMMON_LIMIT) return null;
            const candidates = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player) continue;
                    if (piece.type !== 'Necromancer' && piece.type !== 'Lich') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    candidates.push({ row: r, col: c });
                }
            }
            if (!candidates.length) return null;
            const undeadTargets = getUndeadSummonTargets();
            if (!undeadTargets.length) return null;
            const chosen = candidates[Math.floor(Math.random() * candidates.length)];
            const target = undeadTargets[Math.floor(Math.random() * undeadTargets.length)];
            return {
                type: 'summon',
                special: 'summonNecromancerUndead',
                from: [chosen.row, chosen.col],
                pos: target,
                cost: UNDEAD_SUMMON_COST
            };
        }

        function findAiChampionSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return null;
            if (!hasBackRowSpawnSlot(player)) return null;
            const canSummonNecro = canChampionSummonNecromancer(player);
            const canSummonHuntsman = canChampionSummonHuntsman(player);
            if (!canSummonNecro && !canSummonHuntsman) return null;
            let champion = null;
            for (let r = 0; r < ROWS && !champion; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Champion') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    champion = { row: r, col: c };
                    break;
                }
            }
            if (!champion) return null;
            const spawnCol = findBackRowSpawnColumn(player);
            if (spawnCol === null) return null;
            let summonType = 'Necromancer';
            if (!canSummonNecro && canSummonHuntsman) {
                summonType = 'Huntsman';
            } else if (canSummonNecro && canSummonHuntsman) {
                summonType = necromancersSummoned[player] < 2 ? 'Necromancer' : 'Huntsman';
            } else if (!canSummonNecro) {
                return null;
            }
            return {
                type: 'summon',
                special: 'championSummon',
                from: [champion.row, champion.col],
                pos: [getBackRow(player), spawnCol],
                cost: 2,
                summonType
            };
        }

        function findKingSummonOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            if (!['36s-expert', '36s-elite', '36s-supreme'].includes(gameVariant)) return null;
            if (!hasBackRowSpawnSlot(player)) return null;
            let king = null;
            for (let r = 0; r < ROWS && !king; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'King' && !movedSet.has(`${r},${c}`)) {
                        king = { row: r, col: c };
                        break;
                    }
                }
            }
            if (!king) return null;
            const spawnCol = findBackRowSpawnColumn(player);
            if (spawnCol === null) return null;
            const options = [];
            if ((pistoliersSummoned[player] || 0) < 2) {
                const value = (aiPieceValues['Pistolier'] || pieceValues['Pistolier'] || 3) + 6;
                options.push({ summonType: 'Pistolier', score: value });
            }
            if ((fusiliersSummoned[player] || 0) < 2) {
                const value = (aiPieceValues['Fusilier'] || pieceValues['Fusilier'] || 4) + 5;
                options.push({ summonType: 'Fusilier', score: value });
            }
            if (!options.length) return null;
            options.sort((a, b) => b.score - a.score);
            const best = options[0];
            if (best.score < KING_SUMMON_AI_THRESHOLD) return null;
            return {
                type: 'summon',
                special: 'kingSummon',
                from: [king.row, king.col],
                pos: [getBackRow(player), spawnCol],
                cost: 2,
                summonType: best.summonType
            };
        }

        function findAiHuntsmanBurstOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || !isSpellVariant() || availableMoves < 2) return null;
            let best = null;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Huntsman') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    const targets = getHuntsmanBurstReach(r, c, HUNTSMAN_BURST_FLIP_COUNT + 1);
                    if (!targets.length) continue;
                    let bestLocal = -Infinity;
                    for (const target of targets) {
                        const successesRequired = Math.max(0, target.steps - 1);
                        const prob = HUNTSMAN_BURST_SUCCESS_PROBS[successesRequired] || 0;
                        if (prob <= 0) continue;
                        const value = evaluateHuntsmanDestinationValue(target.row, target.col, player, target.occupant);
                        const score = prob * value - 2;
                        if (score > bestLocal) {
                            bestLocal = score;
                        }
                    }
                    if (bestLocal > HUNTSMAN_BURST_AI_THRESHOLD) {
                        if (!best || bestLocal > best.score) {
                            best = { score: bestLocal, from: [r, c] };
                        }
                    }
                }
            }
            if (best) {
                return { type: 'huntsmanBurst', from: best.from, cost: 2 };
            }
            return null;
        }

        function findAiBarrageOpportunity(player, availableMoves, movedSet) {
            if (gameVariant !== '36s-supreme') return null; // Barrage only available in Supreme variant
            if (player !== 'B' || availableMoves < BARRAGE_COST) return null;
            if (lastAction?.move) return null;
            if (!canUseBarrage(player)) return null;
            if (moralBoostSuccesses[player] < BARRAGE_REQUIRED_MORAL_BOOSTS) return null;
            if (!isChampionPresent(player)) return null;
            if (reinforcementPending) return null;

            let enemyPieces = 0;
            let championFrom = null;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece) continue;
                    if (piece.player !== player) {
                        enemyPieces++;
                        continue;
                    }
                    if (!championFrom && piece.type === 'Champion') {
                        championFrom = [r, c];
                    }
                }
            }

            if (!enemyPieces || !championFrom) return null;

            // Highly encourage barrage usage after achieving 3 moral boosts
            let targetValue = Math.min(enemyPieces, BARRAGE_TARGET_COUNT) * 6.0; // Increased from 3.0 to 6.0
            if (aiDifficulty === 'Hard') targetValue *= 1.5; // Increased from 1.25 to 1.5
            else if (aiDifficulty === 'Medium') targetValue *= 1.3; // Increased from 1.15 to 1.3

            return {
                type: 'barrage',
                from: championFrom,
                cost: BARRAGE_COST,
                special: 'barrage',
                targetValue
            };
        }

        function selectAiElephantryMoveShootTarget(row, col) {
            const piece = board[row]?.[col];
            if (!piece) return null;
            const player = piece.player;
            const directions = [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];
            let bestTarget = null;
            let bestValue = -Infinity;
            for (const [dr, dc] of directions) {
                const nr = row + dr;
                const nc = col + dc;
                if (!isValid(nr, nc)) continue;
                const occupant = board[nr]?.[nc];
                if (!occupant || occupant.player === player || occupant.type === 'Spectre') continue;
                const value = aiPieceValues[occupant.type] !== undefined
                    ? aiPieceValues[occupant.type]
                    : (pieceValues[occupant.type] || 0);
                if (value > bestValue) {
                    bestValue = value;
                    bestTarget = [nr, nc];
                }
            }
            return bestTarget;
        }

        function findAiElephantryTripleShotOpportunity(player, availableMoves, movedSet) {
            if (player !== 'B' || availableMoves < 2) return null;
            let best = null;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || piece.type !== 'Elephantry') continue;
                    if (movedSet.has(`${r},${c}`)) continue;
                    const pieceKey = `${r},${c},${player}`;
                    const remainingUses = typeof elephantryExtendedRangeShotsRemaining[pieceKey] === 'number'
                        ? elephantryExtendedRangeShotsRemaining[pieceKey]
                        : 3;
                    if (remainingUses <= 0) continue;
                    const targets = getElephantryExtendedRangeMoves(r, c);
                    if (!targets.length) continue;
                    const values = targets.map(move => {
                        const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                        if (!targetPiece) return 0;
                        return aiPieceValues[targetPiece.type] !== undefined
                            ? aiPieceValues[targetPiece.type]
                            : (pieceValues[targetPiece.type] || 0);
                    }).sort((a, b) => b - a);
                    if (!values.length || values[0] <= 0) continue;
                    const score = values.slice(0, 3).reduce((sum, val) => sum + val, 0) + targets.length * 0.6;
                    if (!best || score > best.score) {
                        best = { row: r, col: c, score };
                    }
                }
            }
            if (!best) return null;
            return {
                type: 'elephantryTripleShot',
                from: [best.row, best.col],
                pos: [best.row, best.col],
                cost: 2,
                special: 'elephantryTripleShot',
                targetValue: best.score
            };
        }

        function findKingPosition(player) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && piece.type === 'King') {
                        return { row: r, col: c };
                    }
                }
            }
            return null;
        }

        function isSpectreShootImmuneTarget(row, col, attackerPlayer) {
            const target = board[row]?.[col];
            return !!(target && target.player !== attackerPlayer && target.type === 'Spectre');
        }

        function filterShootMovesForPlayer(options, player) {
            return options.filter(option => option.type !== 'shoot' || !isSpectreShootImmuneTarget(option.pos[0], option.pos[1], player));
        }

        function hasKingShotAvailableForPiece(piece) {
            return piece && piece.type === 'King' && !piece.kingShotFired && !kingShotUsed[piece.player];
        }

        function markKingShotUsed(piece) {
            if (!piece || piece.type !== 'King') return;
            piece.kingShotFired = true;
            kingShotUsed[piece.player] = true;
            if (piece.player === 'W') {
                const kingShotButton = document.getElementById('king-shot-button');
                if (kingShotButton) {
                    kingShotButton.style.display = 'none';
                    kingShotButton.disabled = true;
                }
            }
        }

        function resetKingShotFlags() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r]?.[c];
                    if (piece && piece.type === 'King' && piece.kingShotFired) {
                        delete piece.kingShotFired;
                    }
                }
            }
            const kingShotButton = document.getElementById('king-shot-button');
            if (kingShotButton) {
                kingShotButton.disabled = false;
                kingShotButton.style.display = 'none';
            }
        }

        function teleportOntoSquare(fromRow, fromCol, toRow, toCol, player, abilityLabel) {
            const teleportPiece = board[fromRow]?.[fromCol];
            if (!teleportPiece || teleportPiece.player !== player) return { success: false };
            const targetPiece = board[toRow]?.[toCol];
            if (targetPiece) {
                if (targetPiece.player === player || targetPiece.type !== 'Spectre') {
                    if (player === 'W') {
                        gameLog.push(`${abilityLabel} can only target empty squares or enemy Spectres.`);
                        updateGameLog();
                    }
                    return { success: false };
                }
            }
            let capturedPieceType = null;
            if (targetPiece) {
                capturedPieceType = targetPiece.type;
                const actorLabel = player === 'W' ? 'Player' : getOpponentDisplayName();
                const logMessage = `${actorLabel} used ${abilityLabel} to capture ${targetPiece.type} at ${formatBoardCoordinates(toRow,toCol)}.`;
                if (!applySpellCapture(player, toRow, toCol, { logMessage, ability: abilityLabel, attackerType: teleportPiece.type })) {
                    return { success: false };
                }
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateGameLog();
            }
            board[toRow][toCol] = teleportPiece;
            board[fromRow][fromCol] = null;
            checkSupremacy(player);
            return { success: true, capturedPieceType };
        }

        function isKingAdjacentToGuard(row, col, player) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = row + dr;
                    const nc = col + dc;
                    if (!isValid(nr, nc)) continue;
                    const occupant = board[nr]?.[nc];
                    if (occupant && occupant.player === player && occupant.type === 'Guard') {
                        return true;
                    }
                }
            }
            return false;
        }

        function getKingShotTargets(row, col, player) {
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const targets = [];
            for (const [dr, dc] of directions) {
                for (let dist = 1; dist <= KING_SHOT_RANGE; dist++) {
                    const nr = row + dr * dist;
                    const nc = col + dc * dist;
                    if (!isValid(nr, nc)) break;
                    const occupant = board[nr][nc];
                    if (!occupant) {
                        continue;
                    }
                    if (occupant.player === player) {
                        break;
                    }
                    if (occupant.type !== 'Spectre') {
                        targets.push([nr, nc]);
                    }
                    break;
                }
            }
            return targets;
        }

        function getKingEvadeMoves(row, col, player) {
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const visited = new Set([`${row},${col}`]);
            const queue = [{ row, col, steps: 0 }];
            const moves = [];

            while (queue.length) {
                const current = queue.shift();
                if (current.steps >= KING_EVADE_RANGE) continue;
                for (const [dr, dc] of directions) {
                    const nr = current.row + dr;
                    const nc = current.col + dc;
                    if (!isValid(nr, nc)) continue;
                    const key = `${nr},${nc}`;
                    if (visited.has(key)) continue;
                    visited.add(key);
                    const occupant = board[nr]?.[nc];
                    if (!occupant) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'kingEvade' });
                        queue.push({ row: nr, col: nc, steps: current.steps + 1 });
                    } else if (occupant.player !== player) {
                        moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'kingEvade' });
                        // Cannot move past enemies
                    } else {
                        // Can phase through friendly pieces but cannot end on them
                        queue.push({ row: nr, col: nc, steps: current.steps + 1 });
                    }
                }
            }
            return moves;
        }

        function isKingEvadeDestinationSafe(player, fromRow, fromCol, toRow, toCol) {
            const kingPiece = board[fromRow]?.[fromCol];
            if (!kingPiece || kingPiece.type !== 'King') return false;
            const capturedPiece = board[toRow][toCol];
            board[toRow][toCol] = kingPiece;
            board[fromRow][fromCol] = null;
            const safe = !isKingThreatened(player);
            board[fromRow][fromCol] = kingPiece;
            board[toRow][toCol] = capturedPiece;
            return safe;
        }

        function getBestKingEvadePlan(player, movedSet) {
            if (kingEvadeUsed[player] || !isKingThreatened(player)) return null;
            const kingPos = findKingPosition(player);
            if (!kingPos) return null;
            if (movedSet.has(`${kingPos.row},${kingPos.col}`)) return null;
            const moves = getKingEvadeMoves(kingPos.row, kingPos.col, player);
            let best = null;
            for (const move of moves) {
                const [nr, nc] = move.pos;
                if (!isKingEvadeDestinationSafe(player, kingPos.row, kingPos.col, nr, nc)) continue;
                const occupant = board[nr]?.[nc];
                let score = 0;
                if (occupant && occupant.player !== player) {
                    score += (aiPieceValues[occupant.type] || pieceValues[occupant.type] || 0) * KING_EVADE_CAPTURE_BONUS;
                }
                const distance = Math.abs(nr - kingPos.row) + Math.abs(nc - kingPos.col);
                score += distance * KING_EVADE_DISTANCE_BONUS;
                if (!best || score > best.score) {
                    best = { pos: [nr, nc], score };
                }
            }
            return best ? { from: [kingPos.row, kingPos.col], to: best.pos } : null;
        }

        function getBestKingShotPlan(player, movedSet, availableMoves) {
            if (kingShotUsed[player] || availableMoves < 1 || reinforcementPending) return null;
            const kingPos = findKingPosition(player);
            if (!kingPos) return null;
            if (movedSet.has(`${kingPos.row},${kingPos.col}`)) return null;
            const kingPiece = board[kingPos.row]?.[kingPos.col];
            if (!hasKingShotAvailableForPiece(kingPiece)) return null;
            if (!isKingAdjacentToGuard(kingPos.row, kingPos.col, player)) return null;
            const targets = getKingShotTargets(kingPos.row, kingPos.col, player);
            let best = null;
            for (const [tr, tc] of targets) {
                const targetPiece = board[tr]?.[tc];
                if (!targetPiece || targetPiece.player === player) continue;
                let value = aiPieceValues[targetPiece.type] ?? pieceValues[targetPiece.type] ?? 0;
                if (targetPiece.type === 'King') value += 100;
                if (targetPiece.type === 'Champion') value += 25;
                if (!best || value > best.value) {
                    best = { pos: [tr, tc], value };
                }
            }
            if (!best || best.value < KING_SHOT_AI_THRESHOLD) return null;
            return { from: [kingPos.row, kingPos.col], target: best.pos };
        }

        function getAiMoralBoostTarget(player, movedSet, availableMoves) {
            if (moralBoostSuccesses[player] >= MORAL_BOOST_SUCCESS_LIMIT) return null;
            if (availableMoves !== 1 || reinforcementPending) return null;
            const kingPos = findKingPosition(player);
            if (!kingPos) return null;
            if (movedSet.has(`${kingPos.row},${kingPos.col}`)) return null;
            return [kingPos.row, kingPos.col];
        }

        function isKingThreatened(player) {
            const kingPos = findKingPosition(player);
            if (!kingPos) return false;
            const opponent = getOpponent(player);
            const savedCurrentPlayer = currentPlayer;
            const savedMovesLeft = movesLeft;
            let threatened = false;
            currentPlayer = opponent;
            movesLeft = Math.max(savedMovesLeft, 4);
            outer:
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== opponent) continue;
                    const moves = getValidMoves(r, c);
                    for (const move of moves) {
                        if (move.pos[0] === kingPos.row && move.pos[1] === kingPos.col && (move.type === 'move' || move.type === 'shoot')) {
                            threatened = true;
                            break outer;
                        }
                    }
                }
            }
            currentPlayer = savedCurrentPlayer;
            movesLeft = savedMovesLeft;
            return threatened;
        }

        function getProtectionCandidates(player) {
            const types = new Set(['Wizard', 'Necromancer', 'Champion']);
            const candidates = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player && types.has(piece.type)) {
                        candidates.push({ row: r, col: c, piece });
                    }
                }
            }
            return candidates;
        }

        function chooseAiProtectionCandidate(candidates) {
            if (!candidates.length) return null;
            const sorted = candidates.slice().sort((a, b) => {
                const valueDiff = (pieceValues[a.piece.type] || 0) - (pieceValues[b.piece.type] || 0);
                if (valueDiff !== 0) return valueDiff;
                return (a.row + a.col) - (b.row + b.col);
            });
            return sorted[0];
        }

        function applyProtectionSacrifice(player, row, col) {
            const piece = board[row]?.[col];
            if (!piece) return null;
            registerPieceLoss(player, piece.type);
            if (piece.type === 'Champion') {
                championCaptured[player] = true;
                championsOnBackRow[player] = championsOnBackRow[player].filter(([r, c]) => !(r === row && c === col));
            }
            cleanupNecromancerTracking(piece);
            board[row][col] = null;
            return piece;
        }

        function requestSpellProtection({ attacker, defender, targetRow, targetCol, ability, logMessage, onResolve }) {
            if (!isSpellVariant() || !ability) {
                onResolve(true);
                return 'resolved';
            }
            if (ability === 'Soul Blast') {
                onResolve(true);
                return 'resolved';
            }
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece || targetPiece.type !== 'King') {
                onResolve(true);
                return 'resolved';
            }
            if (protectionUsed[defender]) {
                onResolve(true);
                return 'resolved';
            }
            const candidates = getProtectionCandidates(defender);
            const defenderIsAi = isAiPlayer(defender);
            if (!candidates.length) {
                if (defenderIsAi) {
                    gameLog.push(`${getOpponentDisplayName()} could not activate Protection against ${ability}; no Wizards, Necromancers, or Champions remain.`);
                    updateGameLog();
                }
                onResolve(true);
                return 'resolved';
            }
            if (defenderIsAi) {
                const choice = chooseAiProtectionCandidate(candidates);
                if (!choice) {
                    onResolve(true);
                    return 'resolved';
                }
                applyProtectionSacrifice(defender, choice.row, choice.col);
                protectionUsed[defender] = true;
                nextRoundModifier[defender] = (nextRoundModifier[defender] || 0) - 2;
                gameLog.push(`${getOpponentDisplayName()} activated Protection against ${ability}, sacrificing ${choice.piece.type} at ${formatBoardCoordinates(choice.row,choice.col)}. They will start their next round with 2 fewer move points.`);
                renderBoard();
                updateScoreDisplay();
                updateGameLog();
                onResolve(false);
                return 'resolved';
            }
            openProtectionModal({ attacker, defender, targetRow, targetCol, ability, candidates, logMessage, onResolve });
            return 'pending';
        }

        function openProtectionModal(context) {
            const modal = document.getElementById('protection-modal');
            const select = document.getElementById('protection-select');
            const message = document.getElementById('protection-message');
            if (!modal || !select || !message) {
                context.onResolve(true);
                return;
            }
            pendingProtection = context;
            message.textContent = `Your King is targeted by ${context.ability}. Sacrifice a spellcaster or Champion to activate Protection? (Costs 2 move points at the start of your next round)`;
            select.innerHTML = context.candidates.map(candidate => {
                return `<option value="${candidate.row},${candidate.col}">${candidate.piece.type} at ${formatBoardCoordinates(candidate.row,candidate.col)}</option>`;
            }).join('');
            pausedTimers.game = gameTimerInterval;
            pausedTimers.turn = turnTimerInterval;
            pausedTimers.turnPlayer = currentTurnTimerPlayer;
            stopGameTimer();
            stopTurnTimer();
            gamePaused = true;
            modal.style.display = 'block';
        }

        function finalizeProtectionModal() {
            const modal = document.getElementById('protection-modal');
            if (modal) modal.style.display = 'none';
            if (pausedTimers.game && gameTimeRemaining > 0) {
                startGameTimer();
            }
            if (pausedTimers.turn && pausedTimers.turnPlayer) {
                if (pausedTimers.turnPlayer === 'W' && playerTurnTimeRemaining > 0) {
                    startTurnTimer('W', { reset: false });
                } else if (pausedTimers.turnPlayer === 'B' && aiTurnTimeRemaining > 0) {
                    startTurnTimer('B', { reset: false });
                }
            }
            pausedTimers = { game: null, turn: null, turnPlayer: null };
            gamePaused = false;
        }

        function confirmProtection() {
            if (!pendingProtection) {
                finalizeProtectionModal();
                return;
            }
            const select = document.getElementById('protection-select');
            let value = select ? select.value : '';
            if (!value && pendingProtection.candidates.length) {
                value = `${pendingProtection.candidates[0].row},${pendingProtection.candidates[0].col}`;
            }
            if (!value) {
                finalizeProtectionModal();
                pendingProtection.onResolve(true);
                pendingProtection = null;
                return;
            }
            const [rowStr, colStr] = value.split(',');
            const row = parseInt(rowStr, 10);
            const col = parseInt(colStr, 10);
            const sacrificed = applyProtectionSacrifice(pendingProtection.defender, row, col);
            protectionUsed[pendingProtection.defender] = true;
            nextRoundModifier[pendingProtection.defender] = (nextRoundModifier[pendingProtection.defender] || 0) - 2;
            const sacrificedName = sacrificed ? sacrificed.type : 'a unit';
            gameLog.push(`Player activated Protection against ${pendingProtection.ability}, sacrificing ${sacrificedName} at ${formatBoardCoordinates(row,col)}. They will start their next round with 2 fewer move points.`);
            renderBoard();
            updateScoreDisplay();
            updateGameLog();
            finalizeProtectionModal();
            pendingProtection.onResolve(false);
            pendingProtection = null;
        }

        function declineProtection() {
            if (!pendingProtection) {
                finalizeProtectionModal();
                return;
            }
            gameLog.push(`Player declined Protection against ${pendingProtection.ability}.`);
            updateGameLog();
            finalizeProtectionModal();
            pendingProtection.onResolve(true);
            pendingProtection = null;
        }

        function resolveSpellTargetsSequentially(targets, attackerPlayer, ability, onComplete) {
            let captureCount = 0;
            const processNext = (index) => {
                if (index >= targets.length) {
                    onComplete(captureCount);
                    return;
                }
                const target = targets[index];
                const occupant = board[target.row]?.[target.col];
                if (!occupant || occupant.player !== target.defender) {
                    processNext(index + 1);
                    return;
                }
                const logMessage = target.logMessage;
                const result = requestSpellProtection({
                    attacker: attackerPlayer,
                    defender: occupant.player,
                    targetRow: target.row,
                    targetCol: target.col,
                    ability,
                    logMessage,
                    onResolve: (shouldCapture) => {
                        if (shouldCapture) {
                            const captured = applySpellCapture(attackerPlayer, target.row, target.col, { logMessage, ability, attackerType: target.attackerType || null });
                            if (captured) captureCount++;
                        }
                        processNext(index + 1);
                    }
                });
                if (result === 'pending') {
                    return;
                }
            };
            processNext(0);
        }

        function activateGuardOfHonour(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'King' && !kingSpecialUsed[currentPlayer]) {
                guardOfHonourMode = true;
                setActiveControlButton(button || document.getElementById('guard-honour-button'));
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        async function activateBarrage(button = null) {
            if (gameVariant !== '36s-supreme') return; // Barrage only available in Supreme variant
            if (!selectedPiece || reinforcementPending || lastAction?.move || movesLeft < BARRAGE_COST) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || (piece.type !== 'King' && piece.type !== 'Champion')) return;
            if (!isChampionPresent(currentPlayer)) {
                gameLog.push('Barrage requires your Champion to remain on the board.');
                updateGameLog();
                return;
            }
            if (moralBoostSuccesses[currentPlayer] < BARRAGE_REQUIRED_MORAL_BOOSTS) {
                gameLog.push(`Barrage requires at least ${BARRAGE_REQUIRED_MORAL_BOOSTS} successful Moral Boosts.`);
                updateGameLog();
                return;
            }
            if (!canUseBarrage(currentPlayer)) {
                gameLog.push(`Barrage limit reached (${BARRAGE_USE_LIMIT}).`);
                updateGameLog();
                return;
            }
            const controlButton = button || document.getElementById('barrage-button');
            setActiveControlButton(controlButton);
            movesLeft -= BARRAGE_COST;
            updateStatus();
            updateEndTurnButton();
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            lastAction = { special: 'barrage' };
            registerBarrageUse(currentPlayer);
            beginBlockingAction('barrage');
            const targets = getRandomBarrageTargets(BARRAGE_TARGET_COUNT);
            performBarrageShots(piece, targets, controlButton);
        }

        function activateVoidBlast(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'UndeadChampion') return;
            const cooldown = undeadChampionRangedCooldown.get(piece) || 0;
            if (cooldown > 0) return;

            setActiveControlButton(button || document.getElementById('void-blast-button'));
            voidBlastMode = true;

            // Generate Void Blast shoot targets
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const allDirs = [[1,1], [1,-1], [-1,1], [-1,-1], [0,1], [0,-1], [1,0], [-1,0]];
            let shootMoves = [];
            for (let [dr, dc] of allDirs) {
                const nr = row + dr * 2;
                const nc = col + dc * 2;
                if (!isValid(nr, nc)) continue;
                const target = board[nr][nc];
                if (target && target.player !== piece.player) {
                    shootMoves.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'voidBlast' });
                }
            }
            validMoves = shootMoves;
            renderBoard();
        }

        function activateTeleport(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece) return;
            let canTeleport = false;
            if (piece.type === 'Wizard' && wizardTeleportUsed[currentPlayer] < 2) {
                canTeleport = true;
            } else if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme')) {
                if (getNecromancerTeleportCount(piece) < 2) {
                    canTeleport = true;
                }
            } else if (piece.type === 'UndeadChampion') {
                if (!undeadChampionTeleportUsed.has(piece)) {
                    canTeleport = true;
                }
            }
            if (canTeleport) {
                setActiveControlButton(button || document.getElementById('teleport-button'));
                teleportMode = true;
                // Generate teleport moves
                const row = selectedPiece.row;
                const col = selectedPiece.col;
                let teleportMoves = [];

                if (piece.type === 'UndeadChampion') {
                    // UndeadChampion can only teleport to same color squares within 3 squares
                    const currentColor = (row + col) % 2;
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (r === row && c === col) continue;
                            if ((r + c) % 2 !== currentColor) continue;
                            const distance = Math.max(Math.abs(r - row), Math.abs(c - col));
                            if (distance > UNDEAD_CHAMPION_TELEPORT_RANGE) continue;
                            if (isDarkVoidSquare(r, c)) continue;
                            const occupant = board[r][c];
                            if (occupant && (occupant.player === piece.player || occupant.type !== 'Spectre')) continue;
                            teleportMoves.push({ type: 'teleport', pos: [r, c], cost: 2 });
                        }
                    }
                    validMoves = teleportMoves;
                } else {
                    validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                }
                renderBoard();
            }
        }

        function activateTeleportSwap(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || wizardTeleportSwapUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Wizard' && opponentHasWizards(currentPlayer)) {
                setActiveControlButton(button || document.getElementById('teleport-swap-button'));
                teleportSwapMode = true;
                validMoves = getValidTeleportSwapMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateCharge(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || cavalryChargeUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Cavalry') {
                setActiveControlButton(button || document.getElementById('charge-button'));
                chargeMode = true;
                validMoves = getValidChargeMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateOgreRage(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ogreRageUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ogre') {
                setActiveControlButton(button || document.getElementById('ogre-rage-button'));
                ogreRageMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col).filter(m => m.special === 'rage');
                renderBoard();
            }
        }

        function activateInferno(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || dragonInfernoUsed[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Dragon') {
                setActiveControlButton(button || document.getElementById('inferno-button'));
                infernoMode = true;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col); // This will now get Inferno moves
                renderBoard();
            }
        }

        function activateElephantryCharge(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Elephantry' && !elephantryChargeUsed.has(piece)) {
                setActiveControlButton(button || document.getElementById('elephantry-charge-button'));
                elephantryChargeMode = true;
                validMoves = getElephantryChargeMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
            }
        }

        function activateElephantryExtendedRange(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Elephantry') {
                if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                    elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
                }
                const tripleShotMoves = getElephantryExtendedRangeMoves(selectedPiece.row, selectedPiece.col);
                if (elephantryExtendedRangeShotsRemaining[pieceKey] <= 0 || !tripleShotMoves.length) {
                    gameLog.push('No valid targets for Elephantry Triple Shot.');
                    updateGameLog();
                    return;
                }
                // Block turn transition during entire triple shot sequence
                beginBlockingAction('elephantryTripleShot');
                setActiveControlButton(button || document.getElementById('elephantry-extended-button'));
                movesLeft -= 2;
                lastAction = { move: true };
                movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                elephantryExtendedRangeActive = true;
                elephantryTripleShotAwaitingTargets = false;
                elephantryTripleShotFlipResults = [];
                elephantryTripleShotNextShot = 0;
                elephantryTripleShotPieceKey = pieceKey;
                validMoves = [];
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                const elephantryRow = selectedPiece.row;
                const elephantryCol = selectedPiece.col;

                // Perform instant coin flips for all 3 shots
                const allFlips = [];
                for (let i = 0; i < 3; i++) {
                    const success = randomCoinFlip();
                    allFlips.push(success);
                }

                const successCount = allFlips.filter(r => r).length;
                gameLog.push(`Elephantry Triple Shot: ${successCount} of 3 coin flips successful.`);

                // Only store successful flips - failed flips don't result in shots
                elephantryTripleShotFlipResults = allFlips.filter(r => r);

                elephantryTripleShotAwaitingTargets = true;
                const nextMoves = getElephantryExtendedRangeMoves(elephantryRow, elephantryCol);
                if (!nextMoves.length || successCount === 0) {
                    gameLog.push('No valid targets for Elephantry Triple Shot.');
                    updateGameLog();
                    finishElephantryTripleShot();
                    return;
                }
                validMoves = nextMoves;
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
            }
        }

        function activateElephantryMoveShoot(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Elephantry') {
                // Filter valid moves to only show move+shoot positions
                setActiveControlButton(button || document.getElementById('elephantry-moveshoot-button'));
                validMoves = validMoves.filter(m => m.special === 'elephantryMoveShoot');
                renderBoard();
            }
        }

        function activatePistolierMoveShoot(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Pistolier') {
                // Filter valid moves to only show move+shoot positions
                setActiveControlButton(button || document.getElementById('pistolier-moveshoot-button'));
                validMoves = validMoves.filter(m => m.special === 'pistolierMoveShoot');
                renderBoard();
            }
        }

        function activateFusilierCrackShot(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Fusilier' && fusilierCrackShotCount[pieceKey] > 0) {
                // Deduct points and usage
                movesLeft -= 2;
                fusilierCrackShotCount[pieceKey]--;
                lastAction = { move: true };
                movedPieces.add(pieceKey);
                setActiveControlButton(button || document.getElementById('fusilier-crackshot-button'));

                // Activate extended range shooting (temporarily increase range by +1)
                fusilierCrackShotActive = piece;
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);

                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier activated Crack Shot (+1 range)`);
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                renderBoard();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function activateFusilierStrafe(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const pieceKey = `${selectedPiece.row},${selectedPiece.col},${currentPlayer}`;
            if (piece.type === 'Fusilier' && fusilierStrafeCount[pieceKey] > 0) {
                // Deduct points and usage
                movesLeft -= 2;
                fusilierStrafeCount[pieceKey]--;
                lastAction = { move: true };
                movedPieces.add(pieceKey);
                setActiveControlButton(button || document.getElementById('fusilier-strafe-button'));

                // Show strafe move options (1 square orthogonal, no capture)
                fusilierStrafeActive = true;
                validMoves = getFusilierStrafeMoves(selectedPiece.row, selectedPiece.col);

                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier activated Strafe`);
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                renderBoard();
            }
        }

        function getFusilierStrafeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            // Move 1 square orthogonally without capturing
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc) && !board[nr][nc]) {
                    moves.push({ type: 'move', pos: [nr, nc], cost: 0, special: 'fusilierStrafe' });
                }
            }
            return moves;
        }

        function activateEnergyBlast(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            if (!isSpellVariant()) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!isSpellCasterPiece(piece)) return;
            if ((energyBlastUses[currentPlayer] || 0) >= 2) {
                gameLog.push('Energy Blast has already been used twice this game.');
                updateGameLog();
                const btn = document.getElementById('energy-blast-button');
                if (btn) {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
                return;
            }
            const uses = energyBlastUsage.get(piece) || 0;
            if (uses >= 2) {
                gameLog.push('Energy Blast already used twice by this spellcaster.');
                updateGameLog();
                return;
            }
            const cost = uses === 0 ? 2 : 3;
            if (movesLeft < cost) {
                gameLog.push('Not enough move points to cast Energy Blast.');
                updateGameLog();
                return;
            }
            if (pendingEnergyBlast) return;
            // Block turn transition during entire energy blast sequence
            beginBlockingAction('energyBlast');
            const prepaid = Math.min(2, cost);
            pendingEnergyBlast = { row, col, prepaid, cost };
            const controlButton = button || document.getElementById('energy-blast-button');
            setActiveControlButton(controlButton);
            movesLeft -= prepaid;
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Channeling Energy Blast (2 move points spent to attempt spellcasting).');
            updateGameLog();
            coinTossSpecialEffect = 'energy-blast';
            performCoinToss(
                'Energy Blast',
                'Attempting to channel spell energy...',
                (success) => {
                    if (!pendingEnergyBlast || pendingEnergyBlast.row !== row || pendingEnergyBlast.col !== col) {
                        endBlockingAction('energyBlast');
                        return;
                    }
                    const attemptData = pendingEnergyBlast;
                    pendingEnergyBlast = null;
                    if (!success) {
                        gameLog.push('Energy Blast: Coin flip failed - spellcasting unsuccessful.');
                        updateGameLog();
                        removeEnergyBlastGlow();
                        clearActiveControlButton(controlButton);
                        endBlockingAction('energyBlast');
                        ensureAITurnIfNeeded();
                        return;
                    }
                    const currentPiece = board[row]?.[col];
                    if (!currentPiece || currentPiece.player !== currentPlayer) {
                        removeEnergyBlastGlow();
                        clearActiveControlButton(controlButton);
                        endBlockingAction('energyBlast');
                        ensureAITurnIfNeeded();
                        return;
                    }
                    selectedPiece = { row, col };
                    validMoves = getValidMoves(row, col);
                    showPieceInfo(currentPiece, currentPlayer);
                    updateEndTurnButton();
                    activeEnergyBlastCost = { row, col, prepaid: attemptData.prepaid, cost: attemptData.cost };
                    applyEnergyBlastGlow();
                    gameLog.push('Energy Blast: Coin flip successful - spell activated! Select target squares.');
                    updateGameLog();
                    // Wait for coin flip popup to close before showing energy blast popup (800ms display + 300ms fade = 1100ms)
                    setTimeout(() => {
                        showEnergyBlastPopup(() => {
                            openSpellDirectionModal({ type: 'energyBlast', row, col });
                        });
                    }, 1100);
                },
                false,
                false
            );
        }

        function performEnergyBlast(row, col, direction) {
            const piece = board[row]?.[col];
            const energyBlastButton = document.getElementById('energy-blast-button');
            if (!piece || !isSpellCasterPiece(piece) || !isSpellVariant()) {
                removeEnergyBlastGlow();
                clearActiveControlButton(energyBlastButton);
                return;
            }
            if ((energyBlastUses[piece.player] || 0) >= 2) {
                if (piece.player === 'W') {
                    gameLog.push('Energy Blast has already been used twice this game.');
                    updateGameLog();
                }
                removeEnergyBlastGlow();
                clearActiveControlButton(energyBlastButton);
                return;
            }
            const uses = energyBlastUsage.get(piece) || 0;
            if (uses >= 2) {
                gameLog.push('Energy Blast already used twice by this spellcaster.');
                updateGameLog();
                clearActiveControlButton(energyBlastButton);
                return;
            }
            const cost = uses === 0 ? 2 : 3;
            let prepaid = 0;
            if (activeEnergyBlastCost && activeEnergyBlastCost.row === row && activeEnergyBlastCost.col === col) {
                prepaid = activeEnergyBlastCost.prepaid || 0;
                activeEnergyBlastCost = null;
            }
            const additionalCost = Math.max(0, cost - prepaid);
            if (movesLeft < additionalCost) {
                gameLog.push('Not enough move points to sustain Energy Blast after spellcasting.');
                updateGameLog();
                removeEnergyBlastGlow();
                clearActiveControlButton(energyBlastButton);
                return;
            }
            if (additionalCost > 0) {
                movesLeft -= additionalCost;
                updateStatus();
                updateEndTurnButton();
            }
            const prevUses = energyBlastUses[piece.player] || 0;
            energyBlastUses[piece.player] = Math.min(2, prevUses + 1);
            if (piece.player === 'W' && energyBlastUses['W'] >= 2) {
                const btn = document.getElementById('energy-blast-button');
                if (btn) {
                    btn.style.display = 'none';
                    btn.disabled = true;
                }
            }
            energyBlastUsage.set(piece, uses + 1);
            lastAction = { move: true };
            movedPieces.add(`${row},${col}`);
            const context = { piece, row, col, direction };
            // Perform instant coin flips for both player and AI
            const flips = [];
            let successes = 0;
            for (let i = 0; i < ENERGY_BLAST_FLIP_COUNT; i++) {
                const success = randomCoinFlip();
                flips.push(success);
                if (success) successes++;
            }
            completeEnergyBlastAfterRange(context, successes, flips);
        }

        function completeEnergyBlastAfterRange(context, successes, flips) {
            const { piece, row, col, direction } = context;
            if (!piece) {
                endBlockingAction('energyBlast');
                return;
            }
            const playerLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
            const flipSummary = flips.map(result => result ? 'Hit' : 'Miss').join(' ');
            gameLog.push(`${playerLabel} cast Energy Blast (${successes} range) [${flipSummary}]`);

            const finishEnergyBlast = () => {
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
                renderBoard();
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                removeEnergyBlastGlow();
                clearActiveControlButton(document.getElementById('energy-blast-button'));
                endBlockingAction('energyBlast');
                // Add delay before turn transition to ensure blast is visually complete
                if (movesLeft === 0 && !reinforcementPending) {
                    setTimeout(() => {
                        triggerAiTurn();
                    }, 800);
                } else {
                    ensureAITurnIfNeeded();
                }
            };
            if (successes === 0) {
                gameLog.push('The blast fizzled before leaving the caster.');
                finishEnergyBlast();
                return;
            }

            const targets = [];
            const pathSquares = [];
            let targetRow = row;
            let targetCol = col;
            for (let step = 1; step <= successes; step++) {
                targetRow += direction.dr;
                targetCol += direction.dc;
                if (!isValid(targetRow, targetCol)) {
                    break;
                }
                pathSquares.push({ row: targetRow, col: targetCol });
                const occupant = board[targetRow][targetCol];
                if (!occupant || occupant.player === piece.player) {
                    continue;
                }
                targets.push({
                    row: targetRow,
                    col: targetCol,
                    defender: occupant.player,
                    logMessage: `${playerLabel} vaporized ${occupant.type} with Energy Blast at ${formatBoardCoordinates(targetRow,targetCol)}`,
                    attackerType: piece.type
                });
            }

            const processTargets = () => {
                if (!targets.length) {
                    gameLog.push('Energy Blast hit no enemy pieces along its path.');
                    addEnergyBlastResidualSquares(pathSquares);
                    finishEnergyBlast();
                    return;
                }
                resolveSpellTargetsSequentially(targets, piece.player, 'Energy Blast', (capturesHit) => {
                    if (capturesHit === 0) {
                        gameLog.push('Energy Blast was negated or all targets were protected.');
                    }
                    addEnergyBlastResidualSquares(pathSquares);
                    finishEnergyBlast();
                });
            };

            animateEnergyBlastPath(pathSquares, processTargets);
        }

        function activateSacrifice(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            if (!isSpellVariant()) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!isSpellCasterPiece(piece)) return;
            if (movesLeft < 3) {
                gameLog.push('Not enough move points to perform Sacrifice.');
                updateGameLog();
                return;
            }
            if (sacrificeAttemptedPieces.has(piece)) {
                gameLog.push('This spellcaster has already attempted Sacrifice.');
                updateGameLog();
                return;
            }
            sacrificeAttemptedPieces.add(piece);
            const controlButton = button || document.getElementById('sacrifice-button');
            setActiveControlButton(controlButton);
            const playerLabel = 'Player';
            performCoinToss('Sacrifice', 'Attempting Sacrifice...', (success) => {
                if (!success) {
                    gameLog.push(`${playerLabel} failed the Sacrifice coin flip.`);
                    updateGameLog();
                    clearActiveControlButton(controlButton);
                    return;
                }
                if (movesLeft < 3) {
                    gameLog.push('Not enough move points remaining to complete Sacrifice.');
                    updateGameLog();
                    clearActiveControlButton(controlButton);
                    return;
                }
                executeSacrifice(row, col, { controlButton });
            }, false, false);
        }

        function executeSacrifice(row, col, options = {}) {
            const piece = board[row]?.[col];
            const controlButton = options.controlButton || document.getElementById('sacrifice-button');
            if (!piece || !isSpellCasterPiece(piece) || !isSpellVariant()) {
                clearActiveControlButton(controlButton);
                return;
            }
            if (movesLeft < 3) {
                gameLog.push('Not enough move points to perform Sacrifice.');
                updateGameLog();
                clearActiveControlButton(controlButton);
                return;
            }
            const player = piece.player;
            const playerLabel = player === 'W' ? 'Player' : getOpponentDisplayName();
            movesLeft -= 3;
            lastAction = { move: true };
            movedPieces.add(`${row},${col}`);
            registerPieceLoss(player, piece.type);

            if (piece.type === 'Champion') {
                championCaptured[player] = true;
                championsOnBackRow[player] = championsOnBackRow[player].filter(([r, c]) => !(r === row && c === col));
            }

            // Track wizard sacrifice for necromancer summoning exception
            if (piece.type === 'Wizard') {
                wizardSacrificedByPlayer[player] = true;
            }

            cleanupNecromancerTracking(piece);
            board[row][col] = null;

            const enemy = getOpponent(player);
            const targetInfo = listSacrificeTargets(row, col, player);
            const targets = targetInfo.map(({ row: targetRow, col: targetCol, piece: occupant }) => ({
                row: targetRow,
                col: targetCol,
                defender: occupant.player,
                logMessage: `${playerLabel}'s Sacrifice blast engulfed ${occupant.type} at ${formatBoardCoordinates(targetRow,targetCol)}`,
                attackerType: piece.type
            }));

            const finishSacrifice = (capturesHit) => {
                gameLog.push(`${playerLabel} performed Sacrifice, removing their ${piece.type} and striking ${capturesHit} target${capturesHit === 1 ? '' : 's'}.`);
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
                renderBoard();
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                } else {
                    ensureAITurnIfNeeded();
                }
                if (typeof options.onComplete === 'function') {
                    options.onComplete(capturesHit);
                }
                clearActiveControlButton(controlButton);
            };

            resolveSpellTargetsSequentially(targets, player, 'Sacrifice', (capturesHit) => {
                finishSacrifice(capturesHit);
            });
        }

        function beginHuntsmanBurstSequence(row, col, player, options = {}) {
            pendingHuntsmanBurst = {
                row,
                col,
                player,
                successes: 0,
                flips: 0,
                automated: !!options.automated,
                onComplete: typeof options.onComplete === 'function' ? options.onComplete : null,
                controlButton: options.controlButton || null
            };
            pauseGameForHuntsmanBurst();
            runHuntsmanBurstFlip();
        }

        function activateHuntsmanBurst(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!piece || piece.type !== 'Huntsman' || gameVariant !== '36s-supreme') return;
            if (movedPieces.has(`${row},${col}`)) {
                gameLog.push('This Huntsman has already acted this round.');
                updateGameLog();
                return;
            }
            if (movesLeft < 2 || pendingHuntsmanBurst) {
                if (movesLeft < 2) {
                    gameLog.push('Not enough move points to activate Stalking Burst.');
                    updateGameLog();
                }
                return;
            }
            movesLeft -= 2;
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Player Huntsman is attempting a Stalking Burst (2 move points spent).');
            updateGameLog();
            const controlButton = button || document.getElementById('huntsman-burst-button');
            setActiveControlButton(controlButton);
            beginHuntsmanBurstSequence(row, col, currentPlayer, { controlButton });
        }

        function runHuntsmanBurstFlip() {
            if (!pendingHuntsmanBurst) return;
            if (pendingHuntsmanBurst.flips >= HUNTSMAN_BURST_FLIP_COUNT) {
                finalizeHuntsmanBurst();
                return;
            }
            const flipNumber = pendingHuntsmanBurst.flips + 1;
            const successesSoFar = pendingHuntsmanBurst.successes;
            pauseGameForHuntsmanBurst();
            performCoinToss(
                'Stalking Burst',
                `Flip ${flipNumber} of ${HUNTSMAN_BURST_FLIP_COUNT} (successes: ${successesSoFar})`,
                (success) => {
                    if (!pendingHuntsmanBurst) {
                        resumeGameAfterHuntsmanBurst();
                        return;
                    }
                    if (success) pendingHuntsmanBurst.successes++;
                    pendingHuntsmanBurst.flips++;
                    pauseGameForHuntsmanBurst();
                    runHuntsmanBurstFlip();
                },
                true,
                true
            );
        }

        function finalizeHuntsmanBurst() {
            const ctx = pendingHuntsmanBurst;
            pendingHuntsmanBurst = null;
            const controlButton = ctx?.controlButton || document.getElementById('huntsman-burst-button');
            const clearBurstButton = () => clearActiveControlButton(controlButton);
            if (!ctx) {
                resumeGameAfterHuntsmanBurst();
                clearBurstButton();
                return;
            }
            const finish = () => {
                resumeGameAfterHuntsmanBurst();
                if (typeof ctx.onComplete === 'function') ctx.onComplete();
            };
            const piece = board[ctx.row]?.[ctx.col];
            if (!piece || piece.type !== 'Huntsman' || piece.player !== ctx.player) {
                gameLog.push('Huntsman Burst fizzled because the piece is no longer available.');
                updateGameLog();
                finish();
                clearBurstButton();
                return;
            }
            const totalSteps = Math.max(1, ctx.successes + 1);
            if (ctx.player === 'B' && ctx.automated) {
                const destination = chooseBestHuntsmanBurstDestination(ctx.row, ctx.col, totalSteps, ctx.player);
                if (destination) {
                    movePiece(ctx.row, ctx.col, destination.row, destination.col);
                    lastAction = { move: true };
                    movedPieces.add(`${destination.row},${destination.col}`);
                    gameLog.push(`${getOpponentDisplayName()} Huntsman blitzed to ${formatBoardCoordinates(destination.row,destination.col)} after a successful Stalking Burst.`);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                } else {
                    gameLog.push(`${getOpponentDisplayName()} Huntsman could not find a viable burst destination.`);
                    updateGameLog();
                    lastAction = { move: true };
                    movedPieces.add(`${ctx.row},${ctx.col}`);
                }
                finish();
                clearBurstButton();
                return;
            }
            huntsmanBurstMode = { row: ctx.row, col: ctx.col, steps: totalSteps, player: ctx.player, onComplete: ctx.onComplete, controlButton };
            const playerLabel = ctx.player === 'W' ? 'Player' : getOpponentDisplayName();
            const burstText = ctx.successes === 1 ? 'burst step' : 'burst steps';
            gameLog.push(`${playerLabel} Huntsman may move ${totalSteps} square${totalSteps === 1 ? '' : 's'} this turn (1 base + ${ctx.successes} ${burstText}). Select a destination.`);
            updateGameLog();
            selectedPiece = { row: ctx.row, col: ctx.col };
            validMoves = getHuntsmanBurstMoves(ctx.row, ctx.col, huntsmanBurstMode.steps);
            if (!validMoves.length) {
                huntsmanBurstMode = null;
                lastAction = { move: true };
                movedPieces.add(`${ctx.row},${ctx.col}`);
                selectedPiece = null;
                showPieceInfo(null);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
                finish();
                clearBurstButton();
                return;
            }
            showPieceInfo(piece, ctx.player);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
        }

        function getHuntsmanBurstReach(row, col, steps) {
            const originPiece = board[row]?.[col];
            if (!originPiece || originPiece.type !== 'Huntsman') return [];
            const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(Infinity));
            const queue = [{ row, col, used: 0 }];
            visited[row][col] = 0;
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const targets = [];
            while (queue.length) {
                const current = queue.shift();
                for (const [dr, dc] of directions) {
                    const nr = current.row + dr;
                    const nc = current.col + dc;
                    const nextUsed = current.used + 1;
                    if (!isValid(nr, nc) || nextUsed > steps) continue;
                    if (visited[nr][nc] <= nextUsed) continue;
                    const occupant = board[nr]?.[nc];
                    const isFriendly = occupant && occupant.player === originPiece.player;
                    visited[nr][nc] = nextUsed;
                    if (!isFriendly) {
                        targets.push({ row: nr, col: nc, steps: nextUsed, occupant });
                    }
                    if (!occupant || isFriendly) {
                        queue.push({ row: nr, col: nc, used: nextUsed });
                    }
                }
            }
            return targets;
        }

        function getHuntsmanBurstMoves(row, col, steps) {
            const targets = getHuntsmanBurstReach(row, col, steps);
            return targets.map(target => ({
                type: 'move',
                pos: [target.row, target.col],
                cost: 0,
                special: 'huntsmanBurst'
            }));
        }

        function evaluateHuntsmanDestinationValue(row, col, player, occupant = board[row]?.[col]) {
            if (occupant && occupant.player !== player) {
                let value = aiPieceValues[occupant.type] !== undefined ? aiPieceValues[occupant.type] : (pieceValues[occupant.type] || 0);
                if (occupant.type === 'King') {
                    value += 500;
                } else if (occupant.type === 'Champion') {
                    value += 6;
                } else if (occupant.type === 'Necromancer' || occupant.type === 'Wizard') {
                    value += 4;
                }
                return value + 2;
            }
            const opponentBackRow = getOpponentBackRow(player);
            const advancement = Math.max(0, 4 - Math.abs(row - opponentBackRow));
            return 1 + advancement * 0.75;
        }

        function chooseBestHuntsmanBurstDestination(row, col, steps, player) {
            if (steps <= 0) return null;
            const targets = getHuntsmanBurstReach(row, col, steps);
            let best = null;
            for (const target of targets) {
                if (target.steps > steps) continue;
                const score = evaluateHuntsmanDestinationValue(target.row, target.col, player, target.occupant);
                if (!best || score > best.score) {
                    best = { row: target.row, col: target.col, score };
                }
            }
            return best;
        }

        function getValidTeleportSwapMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const opponent = player === 'W' ? 'B' : 'W';
            const color = (row + col) % 2;
            let moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent && (r + c) % 2 === color) {
                        moves.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                    }
                }
            }
            return moves;
        }

        function getValidChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let r = row, c = col;
                while (true) {
                    r += d[0];
                    c += d[1];
                    if (!isValid(r, c)) break;
                    if (board[r][c]) {
                        if (board[r][c].player !== player) {
                            moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                }
            }
            return moves;
        }

        function getElephantryChargeMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            const player = piece.player;
            const facing = piece.facing;
            let moves = [];

            if (elephantryChargeUsed.has(piece)) return moves;

            // Determine forward directions based on facing
            let directions = [];
            if (facing === 'U') {
                directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
            } else if (facing === 'D') {
                directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
            } else if (facing === 'L') {
                directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
            } else if (facing === 'R') {
                directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
            }

            for (let d of directions) {
                let capturesInPath = [];
                let canCharge = true;
                let finalPos = null;

                // Check all 3 squares in this direction
                for (let dist = 1; dist <= 3; dist++) {
                    let r = row + d[0] * dist;
                    let c = col + d[1] * dist;

                    if (!isValid(r, c)) {
                        canCharge = false;
                        break;
                    }

                    const target = board[r][c];
                    if (target) {
                        // Cannot charge through Spectre or Zombies
                        if (target.type === 'Spectre') {
                            canCharge = false;
                            break;
                        }

                        // Can capture enemy pieces
                        if (target.player !== player) {
                            capturesInPath.push([r, c, target.type]);
                            // Stop on Elephantry, Ogre, Troll, or Dragon (but still capture them)
                            if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                finalPos = [r, c];
                                break;
                            }
                        } else {
                            // Cannot charge through own pieces
                            canCharge = false;
                            break;
                        }
                    }

                    // If we've gone 3 squares without stopping, this is the final position
                    if (dist === 3) {
                        finalPos = [r, c];
                    }
                }

                if (canCharge && finalPos) {
                    moves.push({
                        type: 'move',
                        pos: finalPos,
                        cost: 2,
                        special: 'elephantryCharge',
                        captures: capturesInPath
                    });
                }
            }

            return moves;
        }

        function getElephantryExtendedRangeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            // Initialize if not set
            if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
            }

            if (elephantryExtendedRangeShotsRemaining[pieceKey] <= 0) return moves;

            // Only forward-facing lines (head-on + forward-left/right diagonals) should be considered
            const directions = getElephantryTripleShotDirections(piece.facing);
            const shotsRemaining = elephantryExtendedRangeShotsRemaining[pieceKey];
            for (let d of directions) {
                for (let dist = 1; dist <= 2; dist++) {
                    let nr = row + d[0] * dist;
                    let nc = col + d[1] * dist;
                    if (!isValid(nr, nc)) break;
                    const target = board[nr][nc];
                    if (!target) continue;
                    if (target.player !== player && target.type !== 'Spectre') {
                        moves.push({
                            type: 'shoot',
                            pos: [nr, nc],
                            cost: 0, // No additional cost per shot - already paid 2 points on activation
                            special: 'elephantryExtendedRange',
                            shotsRemaining
                        });
                    }
                    break;
                }
            }

            return filterShootMovesForPlayer(moves, player);
        }

        function finalizePostMoveState() {
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
        }

        function executeStandardMove(move, row, col, { costAlreadyDeducted = false } = {}) {
            const moveResult = movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
            if (move.special === 'charge') {
                cavalryChargeUsed[currentPlayer] = true;
            }
            if (move.special === 'ballistaDoubleTime') {
                if (board[row][col]?.type === 'Ballista') {
                    // after moving, board[row][col] is the piece moved
                }
                ballistaDoubleTimeUsed[currentPlayer]++;
                clearActiveControlButton();
            }
            if (move.special === 'rage') {
                ogreRageUsed[currentPlayer] = true;
                performOgreRageCapture(move.captureArea, currentPlayer);
            }
            // UndeadChampion ranged attack is now handled as 'voidBlast' shoot type, not as a move

            if (moveResult?.mercenaryFlipNeeded) {
                const mercPiece = moveResult.mercenaryPiece;
                const mercPos = moveResult.mercenaryPos;

                handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                    finalizePostMoveState();
                    if (bonusTurnGranted) {
                        return;
                    }
                    if (mercenaryBonusTurnActive) {
                        deactivateMercenaryBonusTurn();
                    }
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                });
                return;
            }

            if (!mercenaryBonusTurnActive && !costAlreadyDeducted) {
                movesLeft -= move.cost;
            }
            lastAction = { move: true };
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            if (move.type === 'move' || move.type === 'teleport') {
                movedPieces.add(`${row},${col}`);
            }
            finalizePostMoveState();
            if (mercenaryBonusTurnActive) {
                deactivateMercenaryBonusTurn();
            }
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function processNecromancerSummonMove(move, summonContext) {
            if (!move || !summonContext) return false;
            const source = summonContext.source || selectedPiece;
            if (!source) return false;
            const fromRow = source.row;
            const fromCol = source.col;
            const necromancer = board[fromRow]?.[fromCol];
            const validNecro = necromancer && necromancer.type === 'Necromancer';
            const validLich = necromancer && necromancer.type === 'Lich';
            const requiresNecro = move.summonType !== 'undead' && move.summonType !== 'undeadchampion';
            necromancerSummonMode = null;
            if (!necromancer || (requiresNecro && !validNecro) || (!requiresNecro && !(validNecro || validLich))) {
                validMoves = [];
                selectedPiece = null;
                renderBoard();
                return false;
            }
            const necromancerOwner = necromancer.player;
            if ((summonContext.player && necromancerOwner !== summonContext.player) || necromancerOwner !== currentPlayer) {
                validMoves = [];
                selectedPiece = null;
                renderBoard();
                return false;
            }
            movesLeft = Math.max(0, movesLeft - move.cost);
            updateStatus();
            updateEndTurnButton();
            const targetRow = move.pos[0];
            const targetCol = move.pos[1];
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            const playerLabel = necromancerOwner === 'W' ? 'Player' : getOpponentDisplayName();
            const label = move.summonType === 'spectre'
                ? 'Spectre'
                : (move.summonType === 'lich'
                    ? 'Lich'
                    : (move.summonType === 'undead'
                        ? 'Undead'
                        : (move.summonType === 'undeadchampion'
                            ? 'Undead Champion'
                            : 'Zombie')));
            const isLichSummoningUndead = move.summonType === 'undead' && summonContext?.summonerType === 'Lich';
            const isLichSummoningUndeadChampion = move.summonType === 'undeadchampion' && summonContext?.summonerType === 'Lich';

            const completeSummon = (success) => {
                if (success) {
                    if (!board[targetRow][targetCol]) {
                        if (move.summonType === 'spectre') {
                            board[targetRow][targetCol] = { type: 'Spectre', player: necromancerOwner };
                            spectresSummoned[necromancerOwner]++;
                        } else if (move.summonType === 'lich') {
                            board[targetRow][targetCol] = { type: 'Lich', player: necromancerOwner };
                            lichesSummoned[necromancerOwner]++;
                        } else if (move.summonType === 'undeadchampion') {
                            const summonerType = summonContext?.summonerType || 'Lich';
                            const undeadChampionPiece = createUndeadChampionPiece(necromancerOwner, summonerType);
                            board[targetRow][targetCol] = undeadChampionPiece;
                            undeadChampionsSummoned[necromancerOwner] = (undeadChampionsSummoned[necromancerOwner] || 0) + 1;
                        } else {
                            if (move.summonType === 'undead') {
                                const summonerType = summonContext?.summonerType || 'Necromancer';
                                const undeadLives = UNDEAD_LIVES_BY_SUMMONER[summonerType] || UNDEAD_LIVES_BY_SUMMONER['Necromancer'];
                                const undeadPiece = createUndeadPiece(necromancerOwner, undeadLives, summonerType);
                                board[targetRow][targetCol] = undeadPiece;
                                undeadSummoned[necromancerOwner] = (undeadSummoned[necromancerOwner] || 0) + 1;
                            } else {
                                const zombiePiece = createZombiePiece(necromancerOwner);
                                board[targetRow][targetCol] = zombiePiece;
                                zombiesSummoned[necromancerOwner] = (zombiesSummoned[necromancerOwner] || 0) + 1;
                            }
                        }
                        gameStats.summonCount[necromancerOwner]++;
                        gameLog.push(`${playerLabel} summoned a ${label} at ${formatBoardCoordinates(targetRow,targetCol)} - Coin flip successful!`);
                    } else {
                        gameLog.push(`${playerLabel}'s ${label} summon succeeded but the chosen square was occupied.`);
                    }
                } else {
                    gameLog.push(`${playerLabel} failed to summon a ${label} - Coin flip failed.`);
                }
                lastAction = { move: true };
                movedPieces.add(`${fromRow},${fromCol}`);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending && currentPlayer === 'W') {
                    triggerAiTurn();
                }
            };

            if (isLichSummoningUndead) {
                performCoinToss(
                    `Summon ${label} - Flip 1/2`,
                    `${playerLabel} attempts first coin flip to summon ${label}...`,
                    (firstSuccess) => {
                        if (firstSuccess) {
                            completeSummon(true);
                        } else {
                            performCoinToss(
                                `Summon ${label} - Flip 2/2`,
                                `${playerLabel} attempts second coin flip to summon ${label}...`,
                                (secondSuccess) => {
                                    completeSummon(secondSuccess);
                                },
                                false,
                                false
                            );
                        }
                    },
                    false,
                    false
                );
            } else if (isLichSummoningUndeadChampion) {
                performCoinToss(
                    `Summon ${label}`,
                    `${playerLabel} attempts to summon ${label}...`,
                    (success) => {
                        completeSummon(success);
                    },
                    false,
                    false
                );
            } else {
                performCoinToss(
                    `Summon ${label}`,
                    `${playerLabel} attempts to summon a ${label}...`,
                    (success) => {
                        completeSummon(success);
                    },
                    false,
                    false
                );
            }

            return true;
        }

        function handleClick(row, col) {
            const huntsmanSelectionActive = !!(huntsmanBurstMode && selectedPiece && selectedPiece.row === huntsmanBurstMode.row && selectedPiece.col === huntsmanBurstMode.col);
            if (gameOver || currentPlayer !== 'W' || reinforcementPending || zombieAutoAdvanceInProgress) return;
            if ((gamePaused || lichSoulBlastResolving) && !huntsmanSelectionActive && !lichSoulBlastMode) return;
            const piece = board[row][col];

            if (isAnySpecialModeActive() && !huntsmanSelectionActive) {
                // Soul blast targeting is mandatory - prevent canceling
                if (lichSoulBlastMode) {
                    // Don't allow clicking anywhere to cancel
                    // Player must select a valid target - only valid targets will work below
                    // Fall through to lichSoulBlastMode handler
                } else {
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        cancelSpecialModes({ resetSelection: false });
                        return;
                    }
                    if (!selectedPiece) {
                        cancelSpecialModes();
                        return;
                    }
                    // Don't auto-cancel when clicking different squares - let mode handlers decide
                    // if (selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                    //     cancelSpecialModes();
                    // }
                }
            }

            // Handle Inferno Mode
            if (infernoMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'inferno');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const toRow = move.pos[0];
                    const toCol = move.pos[1];

                    // 1. Perform the initial 1-square move (handles landing capture)
                    movePiece(fromRow, fromCol, toRow, toCol, null);
                    
                    // 2. Perform the adjacent Inferno captures
                    performInfernoCapture(toRow, toCol, currentPlayer);

                    // 3. Update state
                    dragonInfernoUsed[currentPlayer] = true;
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${toRow},${toCol}`);
                    
                    selectedPiece = null;
                    validMoves = [];
                    infernoMode = false;
                    
                    // 4. Re-render and check game state
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            
            // Handle Archer Turn+Shoot mode (after confirming turn)
            if (turnAndShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndShootMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Move + Diagonal (1) Shoot special
            if (archerMoveDiagMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= 1) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    // Perform the 1-point move first
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    movesLeft -= 1;
                    // Prepare diagonal 1-square shoot options from new position
                    selectedPiece = { row, col };
                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                    let options = [];
                    for (let d of dirs) {
                        const nr = row + d[0], nc = col + d[1];
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                            options.push({ type: 'shoot', pos: [nr, nc], cost: 1, special: 'archerDiag1' });
                        }
                    }
                    options = filterShootMovesForPlayer(options, currentPlayer);
                    if (!options.length) {
                        archerMoveDiagMode = false;
                        archerDiagShootSelectMode = false;
                        selectedPiece = null;
                        validMoves = [];
                        clearActiveControlButton();
                        showPieceInfo(null);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        gameLog.push('No valid targets for Archer diagonal shot.');
                        updateGameLog();
                        return;
                    }
                    validMoves = options;
                    // Switch to the second phase: select diagonal shot
                    archerMoveDiagMode = false;
                    archerDiagShootSelectMode = true;
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle second phase of Archer Move + Diagonal (1) Shoot
            if (archerDiagShootSelectMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const currentRow = selectedPiece.row;
                    const currentCol = selectedPiece.col;
                    shootPiece(currentRow, currentCol, row, col, 'Skirmish');
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    // Mark both original and current squares as moved if we have the original
                    if (archerMoveDiagStart) {
                        movedPieces.add(`${archerMoveDiagStart.row},${archerMoveDiagStart.col}`);
                    }
                    movedPieces.add(`${currentRow},${currentCol}`);
                    archerMoveDiagShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiagShootSelectMode = false;
                    archerMoveDiagStart = null;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Diagonal 2-square Shot special
            if (archerDiag2ShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col, 'Longshot');
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    archerDiag2ShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiag2ShootMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Strafe special move
            if (summonSpectreMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonSpectre');
                if (move && movesLeft >= move.cost) {
                    const wizardRow = selectedPiece.row;
                    const wizardCol = selectedPiece.col;
                    const wizardPiece = board[wizardRow][wizardCol];

                    // Store placement info for callback
                    const summonRow = row;
                    const summonCol = col;

                    // Deduct points immediately
                    movesLeft -= move.cost; // cost 2

                    // Trigger coin toss
                    performCoinToss(
                        'Summon Spectre',
                        'Attempting to summon a Spectre...',
                        (success) => {
                            if (success) {
                                // Place Spectre at selected location
                                board[summonRow][summonCol] = { type: 'Spectre', player: currentPlayer };
                                spectresSummoned[currentPlayer]++;
                                wizardSummonedThisTurn[currentPlayer] = true;

                                // Mark wizard as unable to move next turn
                                wizardCannotMoveNextTurn[currentPlayer].add(`${wizardRow},${wizardCol}`);

                                // Award 3 bonus points for successful summoning
                                scores[currentPlayer] += 3;
                                registerScoreGain(currentPlayer, 3);
                                updateScoreDisplay();

                                gameStats.summonCount[currentPlayer]++; // Track summon for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} summoned a Spectre! (+3 bonus points)`);
                            } else {
                                // Failed summoning
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon a Spectre.`);
                            }

                            selectedPiece = null;
                            validMoves = [];
                            summonSpectreMode = false;
                            clearActiveControlButton();
                            showPieceInfo(null);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false, // automated
                        false  // showOverlay
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (darkVoidMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonDarkVoid');
                if (move && movesLeft >= move.cost) {
                    const targetRow = row;
                    const targetCol = col;
                    const occupant = board[targetRow][targetCol];
                    if (occupant) {
                        capturePieceForZombie(currentPlayer, targetRow, targetCol, occupant);
                        updateCapturedPiecesDisplay();
                        updateScoreDisplay();
                    }
                    board[targetRow][targetCol] = { type: 'DarkVoid' };
                    darkVoidSquares.add(darkVoidKey(targetRow, targetCol));
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    darkVoidUses[currentPlayer] = (darkVoidUses[currentPlayer] || 0) + 1;
                    movesLeft -= move.cost;
                    lastAction = { special: 'darkVoid' };
                    selectedPiece = null;
                    validMoves = [];
                    darkVoidMode = null;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    showDarkVoidPopup();
                    const coordLabel = formatBoardCoordinates(targetRow, targetCol);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} unleashed Dark Void at ${coordLabel}.`);
                    updateGameLog();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (strafeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'strafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const piece = board[fromRow][fromCol];

                    // Perform the move
                    movePiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`); // Mark destination as moved so piece can't move again

                    // Increment usage counter based on piece type
                    if (piece.type === 'Wizard') {
                        wizardStrafeUsed[currentPlayer]++;
                    } else if (piece.type === 'Dragon') {
                        dragonStrafeUsed[currentPlayer]++;
                    }

                    selectedPiece = null;
                    validMoves = [];
                    strafeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Fusilier Strafe special move
            if (fusilierStrafeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'fusilierStrafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Perform the move (no capture)
                    board[row][col] = board[fromRow][fromCol];
                    board[fromRow][fromCol] = null;

                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier strafed to ${formatBoardCoordinates(row,col)}`);

                    selectedPiece = null;
                    validMoves = [];
                    fusilierStrafeActive = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (turnAndMoveMode && selectedPiece && board[selectedPiece.row][selectedPiece.col]?.type === 'Infantry') {
                const infantryFacing = board[selectedPiece.row][selectedPiece.col]?.facing;
                const forwardMoves = filterInfantryForwardMoves(validMoves, infantryFacing, selectedPiece.row, selectedPiece.col);
                validMoves = forwardMoves;
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && move.type === 'move' && movesLeft >= 1) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    movesLeft -= 1;
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndMoveMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (guardOfHonourMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'swap');
                if (move && movesLeft >= move.cost) {
                    const guardRow = move.pos[0];
                    const guardCol = move.pos[1];
                    const guard = board[guardRow][guardCol];
                    board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                    board[selectedPiece.row][selectedPiece.col] = guard;
                    kingSpecialUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} and ${formatBoardCoordinates(guardRow,guardCol)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${guardRow},${guardCol}`);
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    guardOfHonourMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    checkSupremacy(currentPlayer);
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleport');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const teleportPiece = board[fromRow][fromCol];
                    board[move.pos[0]][move.pos[1]] = teleportPiece;
                    board[fromRow][fromCol] = null;
                    if (teleportPiece.type === 'Wizard') {
                        wizardTeleportUsed[currentPlayer]++;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    } else if (teleportPiece.type === 'Necromancer') {
                        incrementNecromancerTeleportCount(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    } else if (teleportPiece.type === 'UndeadChampion') {
                        undeadChampionTeleportUsed.add(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Undead Champion from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    }
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportSwapMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleportSwap');
                if (move && movesLeft >= move.cost) {
                    const opponentWizardRow = move.pos[0];
                    const opponentWizardCol = move.pos[1];
                    const playerWizard = board[selectedPiece.row][selectedPiece.col];
                    const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                    board[opponentWizardRow][opponentWizardCol] = playerWizard;
                    board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                    wizardTeleportSwapUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} with opponent's Wizard at ${formatBoardCoordinates(opponentWizardRow,opponentWizardCol)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportSwapMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (chargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= move.cost) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    cavalryChargeUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Charge to move Cavalry from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(row,col)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    chargeMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (ogreRageMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'rage');
                if (move && movesLeft >= move.cost) {
                    executeStandardMove(move, row, col);
                    ogreRageMode = false;
                    clearActiveControlButton();
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Charge
            if (elephantryChargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryCharge');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Process all captures along the path
                    if (move.captures && move.captures.length > 0) {
                        for (let [captureRow, captureCol, captureType] of move.captures) {
                            const capturedPiece = board[captureRow][captureCol];
                            if (capturedPiece) {
                                capturedSquares.push([captureRow, captureCol]);
                                recordGraveyardCapture(currentPlayer, capturedPiece);
                                const captureValue = pieceValues[capturedPiece.type];
                                scores[currentPlayer] += captureValue;
                                registerScoreGain(currentPlayer, captureValue, true);
                                registerPieceLoss(capturedPiece.player, capturedPiece.type);
                                trackCapture(currentPlayer); // Track capture for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry charged and captured ${capturedPiece.type} (+${captureValue} points) at ${formatBoardCoordinates(captureRow,captureCol)}`);

                                if (capturedPiece.type === 'Champion') {
                                    championCaptured[capturedPiece.player] = true;
                                }
                                if (capturedPiece.type === 'King') {
                                    endGame(currentPlayer);
                                    return;
                                }
                                board[captureRow][captureCol] = null;
                            }
                        }
                    }

                    // Move the Elephantry to final position
                    movePiece(fromRow, fromCol, row, col, null);
                    const chargedPiece = board[row][col];
                    if (chargedPiece) {
                        elephantryChargeUsed.add(chargedPiece);
                    }
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Elephantry Charge from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(row,col)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    elephantryChargeMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    updateCapturedPiecesDisplay();
                    updateScoreDisplay();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Pistolier move+shoot final shot selection
            if (pistolierMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'pistolierMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col, 'Move and Shot');

                    // Clean up
                    pistolierMoveShootMode = false;
                    pistolierMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry move+shoot final shot selection
            if (elephantryMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col, 'Move and Shot');

                    // Clean up
                    elephantryMoveShootMode = false;
                    elephantryMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Triple Shot
            if (elephantryExtendedRangeActive && selectedPiece) {
                if (!elephantryTripleShotAwaitingTargets) {
                    return;
                }
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryExtendedRange');
                if (move) {
                    const targetRow = row;
                    const targetCol = col;
                    const elephantryRow = selectedPiece.row;
                    const elephantryCol = selectedPiece.col;
                    const shotIndex = elephantryTripleShotNextShot;

                    // Only successful flips are in the array, so check bounds
                    if (shotIndex >= elephantryTripleShotFlipResults.length) {
                        return;
                    }

                    const shotsRemainingAfter = Math.max(0, elephantryTripleShotFlipResults.length - (shotIndex + 1));
                    if (elephantryTripleShotPieceKey) {
                        elephantryExtendedRangeShotsRemaining[elephantryTripleShotPieceKey] = shotsRemainingAfter;
                    }
                    elephantryTripleShotNextShot++;

                    // All flips in array are successful, so process as hit
                    const targetPiece = board[targetRow][targetCol];
                    if (targetPiece && targetPiece.type === 'Spectre') {
                        gameLog.push('Elephantry triple shot cannot target Spectres.');
                    } else if (targetPiece && targetPiece.player !== currentPlayer && (isUndeadType(targetPiece) || isUndeadChampionType(targetPiece))) {
                        // Handle undead pieces - deduct 1 life per hit
                        const actorLabel = currentPlayer === 'W' ? 'Player' : 'AI';
                        const undeadName = isUndeadChampionType(targetPiece) ? 'Undead Champion' : 'Undead';
                        const currentLives = typeof targetPiece.lives === 'number' ? targetPiece.lives : (targetPiece.maxLives || 1);
                        targetPiece.lives = currentLives - 1;

                        if (targetPiece.lives <= 0) {
                            // Undead destroyed
                            capturedSquares.push([targetRow, targetCol]);
                            recordGraveyardCapture(currentPlayer, targetPiece);
                            const captureValue = pieceValues[targetPiece.type];
                            scores[currentPlayer] += captureValue;
                            registerScoreGain(currentPlayer, captureValue, true);
                            registerPieceLoss(targetPiece.player, targetPiece.type);
                            trackCapture(currentPlayer);
                            gameLog.push(`${actorLabel} Elephantry triple shot shattered the ${undeadName}! (+${captureValue} points)`);
                            cleanupNecromancerTracking(targetPiece);
                            board[targetRow][targetCol] = null;
                            updateCapturedPiecesDisplay();
                            updateScoreDisplay();
                            checkSupremacy(currentPlayer);
                        } else {
                            // Undead damaged but alive
                            const livesText = targetPiece.lives === 1 ? '1 life' : `${targetPiece.lives} lives`;
                            gameLog.push(`${actorLabel} Elephantry triple shot hit the ${undeadName}! (${livesText} remaining)`);
                        }
                    } else if (targetPiece && targetPiece.player !== currentPlayer) {
                        capturedSquares.push([targetRow, targetCol]);
                        recordGraveyardCapture(currentPlayer, targetPiece);
                        const captureValue = pieceValues[targetPiece.type];
                        scores[currentPlayer] += captureValue;
                        registerScoreGain(currentPlayer, captureValue, true);
                        registerPieceLoss(targetPiece.player, targetPiece.type);
                        trackCapture(currentPlayer); // Track capture for statistics
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot hit! Captured ${targetPiece.type} (+${captureValue} points)`);

                        if (targetPiece.type === 'Champion') {
                            championCaptured[targetPiece.player] = true;
                        }
                        if (targetPiece.type === 'King') {
                            endGame(currentPlayer);
                            return;
                        }
                        board[targetRow][targetCol] = null;
                        updateCapturedPiecesDisplay();
                        updateScoreDisplay();
                        checkSupremacy(currentPlayer);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot missed at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                    }

                    updateGameLog();
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();

                    if (shotsRemainingAfter > 0) {
                        const nextMoves = getElephantryExtendedRangeMoves(elephantryRow, elephantryCol);
                        if (!nextMoves.length) {
                            gameLog.push('No remaining targets for Elephantry Triple Shot.');
                            finishElephantryTripleShot();
                            return;
                        }
                        validMoves = nextMoves;
                        renderBoard();
                    } else {
                        finishElephantryTripleShot();
                        return;
                    }

                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Huntsman burst destination selection
            if (huntsmanBurstMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'huntsmanBurst');
                if (move) {
                    const context = huntsmanBurstMode;
                    const fromRow = context.row;
                    const fromCol = context.col;
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    lastAction = { move: true };
                    movedPieces.add(`${row},${col}`);
                    huntsmanBurstMode = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    clearActiveControlButton(context?.controlButton || document.getElementById('huntsman-burst-button'));
                    resumeGameAfterHuntsmanBurst();
                    if (context && typeof context.onComplete === 'function') {
                        context.onComplete();
                    }
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle King Shot targeting
            if (lichSoulBlastMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'lichSoulBlast');
                if (move) {
                    fireLichSoulBlastTarget(move.pos[0], move.pos[1]);
                }
                // Don't allow canceling - player must select a valid target
                // If invalid square clicked, do nothing (already prevented earlier)
                return;
            }

            if (kingShotMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'kingShot');
                if (move) {
                    const source = kingShotMode;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const kingPiece = board[fromRow]?.[fromCol];
                    kingShotMode = null;
                    if (!kingPiece || kingPiece.type !== 'King' || kingPiece.player !== currentPlayer) {
                        validMoves = [];
                        renderBoard();
                        return;
                    }
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    markKingShotUsed(kingPiece);
                    shootPiece(fromRow, fromCol, move.pos[0], move.pos[1]);
                    lastAction = { shoot: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                    gameLog.push(`${actorLabel} executed King Shot.`);
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle King Evade destination
            if (kingEvadeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'kingEvade');
                if (move) {
                    const context = kingEvadeMode;
                    const fromRow = context.row;
                    const fromCol = context.col;
                    const kingPiece = board[fromRow]?.[fromCol];
                    kingEvadeMode = null;
                    if (!kingPiece || kingPiece.type !== 'King' || kingPiece.player !== currentPlayer) {
                        validMoves = [];
                        renderBoard();
                        return;
                    }
                    movePiece(fromRow, fromCol, move.pos[0], move.pos[1]);
                    kingEvadeUsed[currentPlayer] = true;
                    nextRoundModifier[currentPlayer] -= 2;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                    gameLog.push(`${actorLabel} used King Evade (-2 moves next round).`);
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

            // Handle Champion summon targeting
            if (championSummonMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'championSummon');
                if (move) {
                    const summonType = move.summonType;
                    const source = championSummonMode.source || selectedPiece;
                    const expectedOwner = championSummonMode.player || null;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const champion = board[fromRow]?.[fromCol];
                    championSummonMode = null;
                    if (!champion || champion.type !== 'Champion') {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    const championOwner = champion.player;
                    if ((expectedOwner && championOwner !== expectedOwner) || championOwner !== currentPlayer) {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                    movesLeft = Math.max(0, movesLeft - move.cost);
                    updateStatus();
                    updateEndTurnButton();
                    const targetRow = move.pos[0];
                    const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    const playerLabel = championOwner === 'W' ? 'Player' : getOpponentDisplayName();
                    const attemptLabel = summonType === 'Huntsman' ? 'Summon Huntsman' : 'Summon Necromancer';
                    const attemptMessage = `${playerLabel} attempts to summon a ${summonType}...`;
                    performCoinToss(
                        attemptLabel,
                        attemptMessage,
                        (success) => {
                            if (success) {
                                if (!board[targetRow][targetCol]) {
                                    if (summonType === 'Huntsman') {
                                        board[targetRow][targetCol] = { type: 'Huntsman', player: championOwner };
                                        recordHuntsmanSpawn(championOwner);
                                    } else {
                                        const necromancerPiece = { type: 'Necromancer', player: championOwner, facing: null };
                                        board[targetRow][targetCol] = necromancerPiece;
                                        necromancersSummoned[championOwner] = (necromancersSummoned[championOwner] || 0) + 1;
                                        necromancerTeleportCounts.set(necromancerPiece, 0);
                                        setNecromancerShotCooldown(necromancerPiece, 0);
                                    }
                                    gameStats.summonCount[championOwner]++;
                                    gameLog.push(`${playerLabel} summoned a ${summonType} at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                                } else {
                                    gameLog.push(`${playerLabel}'s ${summonType} summon succeeded but the chosen square was occupied.`);
                                }
                            } else {
                                gameLog.push(`${playerLabel} failed to summon a ${summonType}.`);
                            }
                            lastAction = { move: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false,
                        false
                    );
                }
                return;
            }

            // Handle Necromancer summon targeting
            if (necromancerSummonMode && selectedPiece) {
                let move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'necromancerSummon');
                if (!move && necromancerSummonMode && (necromancerSummonMode.type === 'undead' || necromancerSummonMode.type === 'undeadchampion') && board[row]?.[col]?.type === 'DarkVoid') {
                    move = createDarkVoidUndeadMove(row, col, necromancerSummonMode.type);
                }
                if (move) {
                    processNecromancerSummonMove(move, necromancerSummonMode);
                }
                return;
            }

            // Handle King summon placement
            if (kingSummonMode) {
                if (row === kingSummonMode.backRow && kingSummonMode.emptySquares.includes(col)) {
                    completeKingSummonPlacement(row, col);
                }
                return;
            }

            if (!selectedPiece && piece && piece.player === 'W' && !movedPieces.has(`${row},${col}`)) {
                // During mercenary bonus turn, only allow selecting the specific mercenary
                if (mercenaryBonusTurnActive &&
                    (row !== mercenaryBonusTurnPiece.row || col !== mercenaryBonusTurnPiece.col)) {
                    // Clicked on wrong piece during mercenary bonus turn
                    return;
                }
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                showPieceInfo(piece, piece.player);
                lastAction = null;
                renderBoard();
                updateEndTurnButton();
            } else if (selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && movesLeft >= move.cost) {
                    if (move.type === 'move') {
                        // Handle Pistolier capturing by landing - requires coin flip
                        if (move.special === 'pistolierCapture') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss for capture
                            performCoinToss(
                                'Pistolier Capture',
                                `Attempting to capture at ${formatBoardCoordinates(toRow,toCol)}...`,
                                (success) => {
                                    if (success) {
                                        // Successfully captured
                                        movePiece(fromRow, fromCol, toRow, toCol, null);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier successfully captured by landing!`);
                                    } else {
                                        // Failed to capture - still move but don't capture
                                        const targetPiece = board[toRow][toCol];
                                        board[toRow][toCol] = board[fromRow][fromCol];
                                        board[fromRow][fromCol] = null;
                                        // Piece stays in place, no capture
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier failed to capture - move blocked.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    movedPieces.add(`${toRow},${toCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        }

                        // Handle Pistolier move+shoot combination - enter shoot selection mode
                        if (move.special === 'pistolierMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            pistolierMoveShootMode = true;
                            pistolierMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position (1 square diagonal only)
                            validMoves = [];
                            for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'pistolierMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                            pistolierMoveShootMode = false;
                            pistolierMoveShootPosition = null;
                            selectedPiece = null;
                            clearActiveControlButton();
                            showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid pistolier targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier moved to ${formatBoardCoordinates(row,col)}, select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Handle Elephantry move+shoot combination - enter shoot selection mode
                        if (move.special === 'elephantryMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            elephantryMoveShootMode = true;
                            elephantryMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position
                            validMoves = [];
                            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'elephantryMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                            elephantryMoveShootMode = false;
                            elephantryMoveShootPosition = null;
                            selectedPiece = null;
                            clearActiveControlButton();
                            showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid elephantry targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry moved to ${formatBoardCoordinates(row,col)}, select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Check if capturing a Spectre or engaging Undead - requires coin toss
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const isTargetUndead = targetPiece && (isUndeadType(targetPiece) || isUndeadChampionType(targetPiece)) && targetPiece.player !== attackingPiece.player;
                        const isAttackingUndead = attackingPiece && (isUndeadType(attackingPiece) || isUndeadChampionType(attackingPiece)) && targetPiece && targetPiece.player !== attackingPiece.player;

                        // Check if attacker auto-captures undead (undead vs undead, or magic pieces vs undead)
                        const isUndeadVsUndead = isTargetUndead && isAttackingUndead;
                        const isMagicVsUndead = isTargetUndead && (attackingPiece.type === 'Necromancer' || attackingPiece.type === 'Lich' || attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre');
                        const autoCaptures = isUndeadVsUndead || isMagicVsUndead;

                        if ((isTargetUndead || isAttackingUndead) && move.type === 'move' && !autoCaptures) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            movesLeft -= move.cost;
                            updateStatus();
                            updateEndTurnButton();
                            const finalizeUndeadFlip = () => {
                                lastAction = { move: true };
                                movedPieces.add(`${fromRow},${fromCol}`);
                                selectedPiece = null;
                                validMoves = [];
                                showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                updateGameLog();
                                checkGameOver();
                                if (movesLeft === 0 && !reinforcementPending) {
                                    triggerAiTurn();
                                }
                            };
                            const coinTitle = isTargetUndead ? 'Undead Defense' : 'Undead Capture';
                            const coinMessage = isTargetUndead
                                ? 'Attempting to capture the Undead...'
                                : `Attempting to capture ${targetPiece.type} with Undead...`;
                            performCoinToss(
                                coinTitle,
                                coinMessage,
                                (success) => {
                                    if (isTargetUndead) {
                                        const defenseResult = handleUndeadDefense(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, success);
                                        if (!success || defenseResult?.attackerRemoved || defenseResult?.undeadDamaged) {
                                            finalizeUndeadFlip();
                                            return;
                                        }
                                        executeStandardMove(move, row, col, { costAlreadyDeducted: true });
                                        return;
                                    }
                                    if (!success) {
                                        attemptUndeadCapture(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, false);
                                        finalizeUndeadFlip();
                                        return;
                                    }
                                    attemptUndeadCapture(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, true);
                                    executeStandardMove(move, row, col, { costAlreadyDeducted: true });
                                },
                                false,
                                false
                            );
                            return;
                        }

                        if (isCapturingSpectre && !captureExempt) {
                            // Store move info for callback
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            const jump = move.jump;
                            const special = move.special;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss
                            performCoinToss(
                                'Capture Spectre',
                                'Attempting to capture the Spectre...',
                                (success) => {
                                    let moveResult = null;
                                    if (success) {
                                        // Successfully captured Spectre
                                        moveResult = movePiece(fromRow, fromCol, toRow, toCol, jump);
                                        if (special === 'charge') {
                                            cavalryChargeUsed[currentPlayer] = true;
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed[currentPlayer]++;
                                        }
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully captured the Spectre!`);
                                    } else {
                                        // Failed to capture Spectre - move not executed
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to capture the Spectre.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);

                                    // Check if mercenary coin flip is needed
                                    if (success && moveResult?.mercenaryFlipNeeded) {
                                        const mercPiece = moveResult.mercenaryPiece;
                                        const mercPos = moveResult.mercenaryPos;

                                        handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                            selectedPiece = null;
                                            validMoves = [];
                                            showPieceInfo(null);
                                            renderBoard();
                                            updateStatus();
                                            updateEndTurnButton();
                                            updateGameLog();
                                            checkGameOver();

                                            if (bonusTurnGranted) {
                                                return; // Player continues their turn
                                            }

                                            if (mercenaryBonusTurnActive) {
                                                deactivateMercenaryBonusTurn();
                                            }
                                            if (movesLeft === 0 && !reinforcementPending) {
                                                triggerAiTurn();
                                            }
                                        });
                                        return;
                                    }

                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();

                                    // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                                    if (mercenaryBonusTurnActive) {
                                        deactivateMercenaryBonusTurn();
                                    }
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else {
                            if (move.special === 'infantryStrafe') {
                                const targetPiece = board[row][col];
                                if (targetPiece && targetPiece.player !== currentPlayer) {
                                    const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                                    if (!mercenaryBonusTurnActive) {
                                        movesLeft -= move.cost;
                                    }
                                    performCoinToss(
                                        'Infantry Strafe Capture',
                                        `Attempting to strafe capture ${targetPiece.type} at ${formatBoardCoordinates(row,col)}...`,
                                        (success) => {
                                            if (!success) {
                                                gameLog.push(`${actorLabel} failed to strafe capture ${targetPiece.type} at ${formatBoardCoordinates(row,col)}.`);
                                                updateGameLog();
                                                finalizePostMoveState();
                                                if (movesLeft === 0 && !reinforcementPending) {
                                                    triggerAiTurn();
                                                }
                                                return;
                                            }
                                            gameLog.push(`${actorLabel} successfully strafed ${targetPiece.type} at ${formatBoardCoordinates(row,col)}.`);
                                            updateGameLog();
                                            executeStandardMove(move, row, col, { costAlreadyDeducted: true });
                                        }
                                    );
                                    return;
                                }
                            }
                            executeStandardMove(move, row, col);
                            return;
                        }
                    } else if (move.type === 'shoot') {
                        // Check if shooting a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = move.special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && move.special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            gameLog.push('Spectres are immune to standard shooting attacks.');
                            updateGameLog();
                            return;
                        } else if (autoCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const pieceKey = `${fromRow},${fromCol},${currentPlayer}`;

                            movesLeft -= move.cost;

                            if (!(pieceKey in fusilierCrackShotCount)) {
                                fusilierCrackShotCount[pieceKey] = 3;
                            }
                            if (fusilierCrackShotCount[pieceKey] > 0) {
                                fusilierCrackShotCount[pieceKey]--;
                            }

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    clearActiveControlButton();
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else if (usingCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    // Mark the shot attempt for cooldown regardless of outcome
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    fusilierCrackShotActive = null;

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    clearActiveControlButton();
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else if (move.special === 'voidBlast') {
                            // Void Blast - ranged attack for Undead Champion
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            shootPiece(fromRow, fromCol, row, col);
                            setUndeadChampionRangedCooldown(attackingPiece, 1);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Undead Champion used Void Blast!`);
                            voidBlastMode = false;
                        } else {
                            // Normal shoot
                            shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                            if (move.special === 'archerDiag2') {
                                archerDiag2ShootUsed[currentPlayer]++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        }
                    } else if (move.type === 'swap') {
                        const guardRow = move.pos[0];
                        const guardCol = move.pos[1];
                        const guard = board[guardRow][guardCol];
                        board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                        board[selectedPiece.row][selectedPiece.col] = guard;
                        kingSpecialUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} and ${formatBoardCoordinates(guardRow,guardCol)}`);
                        checkSupremacy(currentPlayer);
                        movedPieces.add(`${guardRow},${guardCol}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    } else if (move.type === 'teleport') {
                        const teleportPiece = board[selectedPiece.row][selectedPiece.col];
                        const abilityLabel = `${teleportPiece.type} Teleport`;
                        const result = teleportOntoSquare(selectedPiece.row, selectedPiece.col, move.pos[0], move.pos[1], currentPlayer, abilityLabel);
                        if (!result.success) {
                            cancelSpecialModes({ resetSelection: false });
                            return;
                        }
                        if (teleportPiece.type === 'Wizard') {
                            wizardTeleportUsed[currentPlayer]++;
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                        } else if (teleportPiece.type === 'Necromancer') {
                            incrementNecromancerTeleportCount(teleportPiece);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                        }
                        movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    } else if (move.type === 'teleportSwap') {
                        const opponentWizardRow = row;
                        const opponentWizardCol = col;
                        const playerWizard = board[selectedPiece.row][selectedPiece.col];
                        const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                        board[opponentWizardRow][opponentWizardCol] = playerWizard;
                        board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                        wizardTeleportSwapUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} with opponent's Wizard at ${formatBoardCoordinates(opponentWizardRow,opponentWizardCol)}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                        movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    }
                    // Only deduct move cost if not in mercenary bonus turn mode
                    if (!mercenaryBonusTurnActive) {
                        movesLeft -= move.cost;
                    }
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    if (move.type === 'move' || move.type === 'teleport') {
                        movedPieces.add(`${row},${col}`);
                    }
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    // Clear mercenary bonus turn state after move completes
                    if (mercenaryBonusTurnActive) {
                        deactivateMercenaryBonusTurn();
                    }
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes();
                }
            }
        }

        function openTurnModal(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                setActiveControlButton(button || document.getElementById('turn-button'));
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-modal').style.display = 'block';
            }
        }

        function activateBallistaRange(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaRangeBoostUsedThisTurn[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                const controlButton = button || document.getElementById('ballista-range-button');
                setActiveControlButton(controlButton);
                ballistaRangeBoostActive[currentPlayer] = true;
                ballistaRangeBoostUsedThisTurn[currentPlayer] = true;
                movesLeft -= 2;
                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} activated Ballista Extend Range (+1 range this round)`);
                // Keep the piece selected and recalculate valid moves with extended range
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                clearActiveControlButton(controlButton);
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function getBallistaDoubleTimeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                const r1 = row + d[0], c1 = col + d[1];
                const r2 = row + d[0]*2, c2 = col + d[1]*2;
                if (!isValid(r1, c1) || board[r1][c1]) continue; // path blocked on first
                if (isValid(r2, c2) && !board[r2][c2]) {
                    // Ballista can only move to empty squares - cannot capture by landing
                    moves.push({ type: 'move', pos: [r2, c2], cost: 2, special: 'ballistaDoubleTime' });
                }
            }
            return filterShootMovesForPlayer(moves, player);
        }

        function activateBallistaDoubleTime(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaDoubleTimeUsed[currentPlayer] >= 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                setActiveControlButton(button || document.getElementById('ballista-double-button'));
                const options = getBallistaDoubleTimeMoves(selectedPiece.row, selectedPiece.col);
                validMoves = options;
                renderBoard();
            }
        }
        function activateArcherMoveDiagShoot(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerMoveDiagMode || archerDiagShootSelectMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerMoveDiagShootUsed[currentPlayer] < 2) {
                setActiveControlButton(button || document.getElementById('archer-move-diag-shoot-button'));
                archerMoveDiagMode = true;
                archerMoveDiagStart = { row: selectedPiece.row, col: selectedPiece.col };
                // Only allow the Archer's basic 1-square orthogonal moves for the first step
                const moves = pieceTypes['Archer'].move(selectedPiece.row, selectedPiece.col, board, currentPlayer, null, piece.facing) || [];
                validMoves = moves.filter(m => m.type === 'move' && m.cost === 1);
                renderBoard();
            }
        }

        function activateArcherDiag2Shoot(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerDiag2ShootMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerDiag2ShootUsed[currentPlayer] < 2) {
                setActiveControlButton(button || document.getElementById('archer-diag2-shoot-button'));
                archerDiag2ShootMode = true;
                // Compute diagonal 2-square shoot targets
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                        options.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
                options = filterShootMovesForPlayer(options, currentPlayer);
                if (!options.length) {
                    archerDiag2ShootMode = false;
                    selectedPiece = null;
                    validMoves = [];
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    gameLog.push('No valid targets for Archer diagonal double shot.');
                    updateGameLog();
                    return;
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateStrafe(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (turnAndMoveMode) return;
            if (strafeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const usedCount = piece.type === 'Wizard' ? wizardStrafeUsed[currentPlayer] : dragonStrafeUsed[currentPlayer];

            if ((piece.type === 'Wizard' || piece.type === 'Dragon') && usedCount < 2) {
                strafeMode = true;
                setActiveControlButton(button || document.getElementById('strafe-button'));
                // Compute orthogonal 1-square moves to empty squares only
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'strafe' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateSummonSpectre(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (summonSpectreMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const totalCaptured = getTotalCapturedCount();

            if (piece.type === 'Wizard' && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer] && totalCaptured >= 5) {
                setActiveControlButton(button || document.getElementById('summon-spectre-button'));
                summonSpectreMode = true;
                // Compute adjacent squares (8 directions) for Spectre placement
                const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'summonSpectre' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function showDarkVoidPopup() {
            const boardDiv = document.getElementById('board');
            const body = document.body;
            if (boardDiv) {
                boardDiv.classList.add('dark-void-active');
            }
            if (!body.classList.contains('dark-void-background')) {
                body.classList.add('dark-void-background');
            }
            const modal = document.getElementById('dark-void-modal');
            if (modal) {
                modal.style.display = 'block';
            }
            if (darkVoidPopupTimeout) {
                clearTimeout(darkVoidPopupTimeout);
            }
            darkVoidPopupTimeout = setTimeout(() => {
                closeDarkVoidPopup();
            }, 2600);
        }

        function closeDarkVoidPopup() {
            const boardDiv = document.getElementById('board');
            if (boardDiv) {
                boardDiv.classList.remove('dark-void-active');
            }
            const modal = document.getElementById('dark-void-modal');
            if (modal) {
                modal.style.display = 'none';
            }
            document.body.classList.remove('dark-void-background');
            if (darkVoidPopupTimeout) {
                clearTimeout(darkVoidPopupTimeout);
                darkVoidPopupTimeout = null;
            }
        }

        function getDarkVoidTargets(row, col) {
            const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            const targets = [];
            for (const [dr, dc] of dirs) {
                const nr = row + dr;
                const nc = col + dc;
                if (!isValid(nr, nc)) continue;
                if (isDarkVoidSquare(nr, nc) || (darkVoidSquares.size && isAdjacentToDarkVoid(nr, nc))) continue;
                const occupant = board[nr]?.[nc];
                if (occupant && occupant.player === currentPlayer) continue;
                targets.push([nr, nc]);
            }
            return targets;
        }

        function activateDarkVoid(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < DARK_VOID_COST) return;
            if (darkVoidUses[currentPlayer] >= DARK_VOID_USE_LIMIT) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || (piece.type !== 'Necromancer' && piece.type !== 'Lich')) return;
            const targets = getDarkVoidTargets(selectedPiece.row, selectedPiece.col);
            if (!targets.length) return;
            const controlButton = button || document.getElementById('dark-void-button');
            setActiveControlButton(controlButton);
            darkVoidMode = {
                row: selectedPiece.row,
                col: selectedPiece.col,
                button: controlButton
            };
            validMoves = targets.map(pos => ({ type: 'summon', pos, cost: DARK_VOID_COST, special: 'summonDarkVoid' }));
            renderBoard();
        }

        function activateChampionSummon(type, button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (championSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Champion' || (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme')) return;
            const owner = piece.player;
            if (type === 'Necromancer') {
                if (!canChampionSummonNecromancer(owner)) {
                    gameLog.push('No Necromancer summons remaining.');
                    updateGameLog();
                    return;
                }
            } else if (type === 'Huntsman') {
                if (!canChampionSummonHuntsman(owner)) {
                    gameLog.push('No Huntsman summons remaining.');
                    updateGameLog();
                    return;
                }
            } else {
                return;
            }
            if (!hasBackRowSpawnSlot(owner)) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            const backRow = getBackRow(owner);
            const options = [];
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'championSummon', summonType: type });
                }
            }
            if (!options.length) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            championSummonMode = { type, player: owner, source: { row: selectedPiece.row, col: selectedPiece.col } };
            const fallbackId = type === 'Huntsman' ? 'champion-summon-huntsman-button' : 'champion-summon-necro-button';
            setActiveControlButton(button || document.getElementById(fallbackId));
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push(`Select a back row square to summon a ${type}.`);
            updateGameLog();
        }

        function activateNecromancerSummon(type, button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (necromancerSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const isUndeadSummon = type === 'undead';
            const isUndeadChampionSummon = type === 'undeadchampion';
            if (!piece) return;
            const isNecromancerPiece = piece.type === 'Necromancer';
            const isLichPiece = piece.type === 'Lich';
            if ((isUndeadSummon && !(isNecromancerPiece || isLichPiece)) || (isUndeadChampionSummon && !isLichPiece) || (!isUndeadSummon && !isUndeadChampionSummon && !isNecromancerPiece)) return;
            if (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme') return;
            const owner = piece.player;
            const summonerType = piece.type;
            const isZombieSummon = type === 'zombie';
            const isSpectreSummon = type === 'spectre';
            const isLichSummon = type === 'lich';
            if (!isZombieSummon && !isSpectreSummon && !isLichSummon && !isUndeadSummon && !isUndeadChampionSummon) return;
            if (isZombieSummon) {
                const maxZombies = getMaxZombies(owner);
                if ((zombiesSummoned[owner] || 0) >= maxZombies) {
                    gameLog.push('Zombie limit reached. Cannot summon more.');
                    updateGameLog();
                    return;
                }
            } else if (isSpectreSummon && spectresSummoned[owner] >= 2) {
                gameLog.push('Spectre limit reached. Cannot summon more.');
                updateGameLog();
                return;
            } else if (isLichSummon) {
                if (lichesSummoned[owner] >= LICH_SUMMON_LIMIT) {
                    gameLog.push('Lich already conjured.');
                    updateGameLog();
                    return;
                }
                const souls = (capturedPieces[owner] || []).length;
                if (souls < LICH_SUMMON_SOUL_THRESHOLD) {
                    const needed = LICH_SUMMON_SOUL_THRESHOLD - souls;
                    const captureLabel = needed === 1 ? 'one more captured enemy piece' : `${needed} more captured enemy pieces`;
                    gameLog.push(`Capture ${captureLabel} before summoning a Lich.`);
                    updateGameLog();
                    return;
                }
            }
            let options = [];
            if (isSpectreSummon) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = selectedPiece.row + dr;
                        const nc = selectedPiece.col + dc;
                        if (!isValid(nr, nc)) continue;
                        if (!board[nr][nc]) {
                            options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'necromancerSummon', summonType: type });
                        }
                    }
                }
                if (!options.length) {
                    gameLog.push('No adjacent squares available next to the Necromancer to summon a Spectre.');
                    updateGameLog();
                    return;
                }
            } else if (isUndeadSummon) {
                if ((undeadSummoned[owner] || 0) >= UNDEAD_SUMMON_LIMIT) {
                    gameLog.push('Undead limit reached. Cannot summon more.');
                    updateGameLog();
                    return;
                }
                const undeadTargets = getUndeadSummonTargets();
                if (!undeadTargets.length) {
                    gameLog.push('No open squares adjacent to a Dark Void to summon Undead.');
                    updateGameLog();
                    return;
                }
                options = undeadTargets.map(pos => ({ type: 'summon', pos, cost: UNDEAD_SUMMON_COST, special: 'necromancerSummon', summonType: type }));
            } else if (isUndeadChampionSummon) {
                if ((undeadChampionsSummoned[owner] || 0) >= UNDEAD_CHAMPION_SUMMON_LIMIT) {
                    gameLog.push('Undead Champion already summoned. Cannot summon more.');
                    updateGameLog();
                    return;
                }
                const undeadTargets = getUndeadSummonTargets();
                if (!undeadTargets.length) {
                    gameLog.push('No open squares adjacent to a Dark Void to summon Undead Champion.');
                    updateGameLog();
                    return;
                }
                options = undeadTargets.map(pos => ({ type: 'summon', pos, cost: UNDEAD_SUMMON_COST, special: 'necromancerSummon', summonType: type }));
            } else if (isLichSummon) {
                // Lich can be summoned on back row OR next to dark voids
                const backRow = getBackRow(owner);
                const undeadTargets = getUndeadSummonTargets();

                // Add back row positions
                for (let c = 0; c < COLS; c++) {
                    if (!board[backRow][c]) {
                        options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'necromancerSummon', summonType: type });
                    }
                }

                // Add dark void adjacent positions
                for (const pos of undeadTargets) {
                    // Avoid duplicates (in case a dark void is on back row)
                    const isDuplicate = options.some(opt => opt.pos[0] === pos[0] && opt.pos[1] === pos[1]);
                    if (!isDuplicate) {
                        options.push({ type: 'summon', pos, cost: 2, special: 'necromancerSummon', summonType: type });
                    }
                }

                if (!options.length) {
                    gameLog.push('No open squares on the back row or adjacent to a Dark Void to summon Lich.');
                    updateGameLog();
                    return;
                }
            } else {
                // Zombie and other summons - back row only
                if (!hasBackRowSpawnSlot(owner)) {
                    gameLog.push('No open squares on the back row to place a summon.');
                    updateGameLog();
                    return;
                }
                const backRow = getBackRow(owner);
                for (let c = 0; c < COLS; c++) {
                    if (!board[backRow][c]) {
                        options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'necromancerSummon', summonType: type });
                    }
                }
                if (!options.length) {
                    gameLog.push('No open squares on the back row to place a summon.');
                    updateGameLog();
                    return;
                }
            }
            necromancerSummonMode = { type, player: owner, source: { row: selectedPiece.row, col: selectedPiece.col }, summonerType };
            const fallbackId = isSpectreSummon
                ? 'necromancer-summon-spectre-button'
                : isLichSummon
                    ? 'necromancer-summon-lich-button'
                    : isUndeadSummon
                        ? 'necromancer-summon-undead-button'
                        : isUndeadChampionSummon
                            ? 'lich-summon-undead-champion-button'
                            : 'necromancer-summon-zombie-button';
            setActiveControlButton(button || document.getElementById(fallbackId));
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            const label = isSpectreSummon ? 'Spectre' : (isLichSummon ? 'Lich' : (isUndeadSummon ? 'Undead' : (isUndeadChampionSummon ? 'Undead Champion' : 'Zombie')));
            const placementLabel = isSpectreSummon ? 'an adjacent square' : ((isUndeadSummon || isUndeadChampionSummon) ? 'a square next to a Dark Void' : 'a back row square');
            gameLog.push(`Select ${placementLabel} to summon a ${label}.`);
            updateGameLog();
        }

        function activateMoralBoost(button = null) {
            if (!selectedPiece || reinforcementPending || movesLeft !== 1 || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'King') return;
            if (moralBoostSuccesses[currentPlayer] >= MORAL_BOOST_SUCCESS_LIMIT) {
                gameLog.push(`Moral Boost already succeeded ${MORAL_BOOST_SUCCESS_LIMIT} times this game.`);
                updateGameLog();
                return;
            }
            const boostPlayer = currentPlayer;
            moralBoostUses[boostPlayer]++;
            movesLeft = Math.max(0, movesLeft - 1);
            updateStatus();
            updateEndTurnButton();
            const fromRow = selectedPiece.row;
            const fromCol = selectedPiece.col;
            const controlButton = button || document.getElementById('moral-boost-button');
            const actorLabel = boostPlayer === 'W' ? 'Player' : getOpponentDisplayName();
            setActiveControlButton(controlButton);
            performCoinToss(
                'Moral Boost',
                'Attempting to rally the troops...',
                (success) => {
                    if (success) {
                        nextRoundModifier[boostPlayer] += MORAL_BOOST_BONUS;
                        moralBoostSuccesses[boostPlayer]++;
                        const justUnlockedBarrage = moralBoostSuccesses[boostPlayer] === BARRAGE_REQUIRED_MORAL_BOOSTS;
                        gameLog.push(`${actorLabel} succeeded with Moral Boost! +2 moves next round.`);
                        // Wait for coin flip popup to close before showing morale boost popup (1500ms display + 300ms fade = 1800ms)
                        setTimeout(() => {
                            showWarcryAchievementPopup(boostPlayer, { title: 'MORAL BOOST', subtitle: '+2 Next Round' });
                            // If this was the 3rd moral boost, show BARRAGE READY popup after moral boost popup
                            if (justUnlockedBarrage) {
                                setTimeout(() => {
                                    showWarcryAchievementPopup(boostPlayer, { title: 'BARRAGE READY', subtitle: 'Artillery Unlocked' });
                                }, 2800); // Show after moral boost popup closes (2600ms) + small delay
                            }
                        }, 1800);
                    } else {
                        gameLog.push(`${actorLabel} failed to inspire a Moral Boost.`);
                    }
                    updateMoralBoostButtonLabel(boostPlayer);
                    if (controlButton && moralBoostSuccesses[boostPlayer] >= MORAL_BOOST_SUCCESS_LIMIT) {
                        controlButton.style.display = 'none';
                        controlButton.disabled = true;
                    }
                    lastAction = { special: 'moralBoost' };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    clearActiveControlButton(controlButton);
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                },
                false,
                false
            );
        }

        function activateKingShot(button = null) {
            if (!selectedPiece || reinforcementPending || lastAction?.move || movesLeft < 1) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!hasKingShotAvailableForPiece(piece)) return;
            if (kingShotMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (!isKingAdjacentToGuard(selectedPiece.row, selectedPiece.col, currentPlayer)) {
                gameLog.push('King Shot requires the King to be adjacent to a friendly Guard.');
                updateGameLog();
                return;
            }
            const targets = getKingShotTargets(selectedPiece.row, selectedPiece.col, currentPlayer);
            if (!targets.length) {
                gameLog.push('No valid targets for King Shot within range.');
                updateGameLog();
                return;
            }
            kingShotMode = { row: selectedPiece.row, col: selectedPiece.col };
            setActiveControlButton(button || document.getElementById('king-shot-button'));
            validMoves = targets.map(([r, c]) => ({ type: 'shoot', pos: [r, c], cost: 1, special: 'kingShot' }));
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Select a target for King Shot (range 3, excludes Spectres).');
            updateGameLog();
        }

        function activateKingEvade(button = null) {
            if (!selectedPiece || reinforcementPending) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'King' || kingEvadeUsed[currentPlayer]) return;
            if (kingEvadeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (!isKingThreatened(currentPlayer)) {
                gameLog.push('King Evade is only available while the King is in danger.');
                updateGameLog();
                return;
            }
            const moves = getKingEvadeMoves(selectedPiece.row, selectedPiece.col, currentPlayer);
            if (!moves.length) {
                gameLog.push('No available escape route for King Evade.');
                updateGameLog();
                return;
            }
            kingEvadeMode = { row: selectedPiece.row, col: selectedPiece.col, player: currentPlayer };
            setActiveControlButton(button || document.getElementById('king-evade-button'));
            validMoves = moves;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Select a destination for Evade (costs 2 moves next round).');
            updateGameLog();
        }

        function confirmTurn() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-modal').style.display = 'none';
            clearActiveControlButton(document.getElementById('turn-button'));
            movesLeft -= turnCosts[piece.type];
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function openTurnAndMoveModal(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Infantry' && movesLeft >= 2) {
                setActiveControlButton(button || document.getElementById('turn-move-button'));
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-move-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-move-modal').style.display = 'block';
            }
        }

        function confirmTurnAndMove() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-move-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-move-modal').style.display = 'none';
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndMoveMode = true;
            const allMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
            validMoves = filterInfantryForwardMoves(allMoves, newFacing, selectedPiece.row, selectedPiece.col);
            if (!validMoves.length) {
                gameLog.push('No forward moves available after turning.');
                updateGameLog();
                turnAndMoveMode = false;
                clearActiveControlButton();
                return;
            }
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function closeTurnModal() {
            const modal = document.getElementById('turn-modal');
            if (modal) modal.style.display = 'none';
            clearActiveControlButton(document.getElementById('turn-button'));
        }

        function getKingSummonOptionConfig(player) {
            return [
                { type: 'Pistolier', used: pistoliersSummoned[player], limit: 2, requirementMet: true, requirementHint: '' },
                { type: 'Fusilier', used: fusiliersSummoned[player], limit: 2, requirementMet: true, requirementHint: '' }
            ];
        }

        function updateKingSummonButtons({ hasBackRowSlot = true, showButtons = false } = {}) {
            const config = getKingSummonOptionConfig(currentPlayer);
            let anyEnabled = false;
            config.forEach(({ type, used, limit, requirementMet, requirementHint }) => {
                const button = document.getElementById(`king-summon-${type.toLowerCase()}-button`);
                if (!button) return;
                const remaining = limit - used;
                let reason = '';
                if (!hasBackRowSlot) {
                    reason = 'No open squares on the back row.';
                } else if (remaining <= 0) {
                    reason = `${type} limit reached.`;
                } else if (!requirementMet && requirementHint) {
                    reason = requirementHint;
                } else if (movesLeft < 2) {
                    reason = 'Need at least 2 move points.';
                }
                const canSummon = !reason;
                button.textContent = `Summon ${type} (${used}/${limit})`;
                if (showButtons) {
                    button.style.display = 'inline';
                } else {
                    button.style.display = 'none';
                }
                button.disabled = !canSummon;
                if (reason) {
                    button.title = reason;
                } else {
                    button.removeAttribute('title');
                    if (showButtons) {
                        anyEnabled = true;
                    }
                }
            });
            return anyEnabled;
        }

        function getKingSummonAvailability(unitType) {
            if (!selectedPiece || currentPlayer !== 'W') return { allowed: false };
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'King') return { allowed: false };
            if (reinforcementPending) {
                return { allowed: false, message: 'Resolve reinforcements before summoning.' };
            }
            if (lastAction?.move) {
                return { allowed: false, message: 'Finish your current action before summoning.' };
            }
            if (movesLeft < 2) {
                return { allowed: false, message: 'Need at least 2 move points to summon.' };
            }
            if (!hasBackRowSpawnSlot(currentPlayer)) {
                return { allowed: false, message: 'No open squares on the back row to place the summon.' };
            }
            if (unitType === 'Pistolier') {
                if (pistoliersSummoned[currentPlayer] >= 2) {
                    return { allowed: false, message: 'Pistolier limit reached.' };
                }
            } else if (unitType === 'Fusilier') {
                if (fusiliersSummoned[currentPlayer] >= 2) {
                    return { allowed: false, message: 'Fusilier limit reached.' };
                }
            }
            return { allowed: true };
        }

        function requestKingSummon(unitType) {
            const availability = getKingSummonAvailability(unitType);
            if (!availability.allowed) {
                if (availability.message) {
                    gameLog.push(availability.message);
                    updateGameLog();
                }
                return;
            }
            confirmKingSummon(unitType);
        }

        function confirmKingSummon(unitType) {
            if (!selectedPiece || currentPlayer !== 'W' || !unitType) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type !== 'King') return;

            // Deduct points immediately
            movesLeft -= 2;

            // Perform coin toss for summon
            performCoinToss(
                'Summon Unit',
                `Attempting to summon ${unitType}...`,
                (success) => {
                    if (success) {
                        // Find empty squares in back row
                        const backRow = currentPlayer === 'W' ? ROWS - 1 : 0;
                        let emptySquares = [];
                        for (let c = 0; c < COLS; c++) {
                            if (!board[backRow][c]) {
                                emptySquares.push(c);
                            }
                        }

                        if (emptySquares.length > 0) {
                            // Enter placement selection mode
                            kingSummonMode = {
                                unitType: unitType,
                                emptySquares: emptySquares,
                                backRow: backRow
                            };
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully summoned ${unitType}! Select a square on the back row to place it.`);
                            validMoves = emptySquares.map(col => ({ row: backRow, col: col }));
                            renderBoard();
                            updateGameLog();
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} succeeded summon but no empty squares in back row!`);
                            lastAction = { move: true };
                            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                            selectedPiece = null;
                            validMoves = [];
                            showPieceInfo(null);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        }
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon ${unitType}.`);
                        lastAction = { move: true };
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                        selectedPiece = null;
                        validMoves = [];
                        showPieceInfo(null);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        updateGameLog();
                        checkGameOver();
                        if (movesLeft === 0 && !reinforcementPending) {
                            triggerAiTurn();
                        }
                    }
                },
                false, // automated
                false  // showOverlay
            );
        }

        function completeKingSummonPlacement(row, col) {
            if (!kingSummonMode) return;

            const { unitType, backRow } = kingSummonMode;
            const needsFacing = turnablePieces.includes(unitType);
            const facing = needsFacing ? (currentPlayer === 'W' ? 'U' : 'D') : null;

            // Place the unit at the selected position
            board[backRow][col] = { type: unitType, player: currentPlayer, facing };

            // Update summon counter
            if (unitType === 'Pistolier') {
                pistoliersSummoned[currentPlayer]++;
            } else if (unitType === 'Fusilier') {
                fusiliersSummoned[currentPlayer]++;
            }

            gameStats.summonCount[currentPlayer]++; // Track summon for statistics
            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} placed ${unitType} at ${formatBoardCoordinates(backRow, col)}!`);

            // Clean up and complete action
            kingSummonMode = null;
            lastAction = { move: true };
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function getLichSoulBlastRange(player) {
            const souls = (capturedPieces[player] || []).length;
            if (souls < LICH_SOUL_BLAST_SOULS_PER_RANGE) return 0;
            return Math.min(
                LICH_SOUL_BLAST_MAX_RANGE,
                Math.floor(souls / LICH_SOUL_BLAST_SOULS_PER_RANGE)
            );
        }

        function getLichSoulBlastTargets(row, col, rangeOverride = null) {
            const piece = board[row]?.[col];
            if (!piece || piece.type !== 'Lich') return [];
            const player = piece.player;
            const range = Math.min(
                LICH_SOUL_BLAST_MAX_RANGE,
                rangeOverride ?? getLichSoulBlastRange(player)
            );
            if (range < 1) return [];
            const moves = [];
            const directions = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (const [dr, dc] of directions) {
                let r = row;
                let c = col;
                for (let step = 1; step <= range; step++) {
                    r += dr;
                    c += dc;
                    if (!isValid(r, c)) break;
                    const occupant = board[r]?.[c];
                    if (occupant) {
                        if (occupant.player !== player) {
                            moves.push({ type: 'shoot', pos: [r, c], cost: 0, special: 'lichSoulBlast' });
                        }
                        break;
                    }
                }
            }
            return moves;
        }

        function getSoulBlastPath(fromRow, fromCol, toRow, toCol) {
            const dr = Math.sign(toRow - fromRow);
            const dc = Math.sign(toCol - fromCol);
            if (dr === 0 && dc === 0) return [];
            const path = [];
            let currentRow = fromRow + dr;
            let currentCol = fromCol + dc;
            while (isValid(currentRow, currentCol)) {
                path.push({ row: currentRow, col: currentCol });
                if (currentRow === toRow && currentCol === toCol) {
                    break;
                }
                currentRow += dr;
                currentCol += dc;
            }
            return path;
        }

        function updateSoulBlastPreview(originRow, originCol, targetMoves = []) {
            soulBlastPreviewSquares.clear();
            if (!Number.isInteger(originRow) || !Number.isInteger(originCol) || !targetMoves?.length) {
                refreshSoulBlastPreviewHighlights();
                return;
            }
            targetMoves.forEach(move => {
                if (!move || move.special !== 'lichSoulBlast' || !move.pos) return;
                const [targetRow, targetCol] = move.pos;
                const path = getSoulBlastPath(originRow, originCol, targetRow, targetCol);
                path.forEach(({ row, col }) => {
                    soulBlastPreviewSquares.add(`${row},${col}`);
                });
            });
            refreshSoulBlastPreviewHighlights();
        }

        function clearSoulBlastPreview() {
            if (!soulBlastPreviewSquares.size) return;
            soulBlastPreviewSquares.clear();
            refreshSoulBlastPreviewHighlights();
        }

        function lockSoulBlastPreviewToPath(pathSquares = []) {
            soulBlastPreviewSquares.clear();
            if (!pathSquares || !pathSquares.length) {
                refreshSoulBlastPreviewHighlights();
                return;
            }
            pathSquares.forEach(({ row, col }) => {
                soulBlastPreviewSquares.add(`${row},${col}`);
            });
            refreshSoulBlastPreviewHighlights();
        }

        function activateLichSoulBlast(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            if (isAnySpecialModeActive()) return;
            if (pendingLichSoulBlast || lichSoulBlastMode) return;
            const row = selectedPiece.row;
            const col = selectedPiece.col;
            const piece = board[row]?.[col];
            if (!piece || piece.type !== 'Lich') return;
            const range = getLichSoulBlastRange(piece.player);
            if (range < 1) {
                gameLog.push('Soul Blast requires at least 3 captured enemy souls per range tier.');
                updateGameLog();
                return;
            }
            if (movesLeft < LICH_SOUL_BLAST_COST) {
                gameLog.push('Not enough move points to channel Soul Blast.');
                updateGameLog();
                return;
            }
            const targets = getLichSoulBlastTargets(row, col, range);
            if (!targets.length) {
                gameLog.push('No valid Soul Blast targets are in range.');
                updateGameLog();
                return;
            }
            const controlButton = button || document.getElementById('lich-soul-blast-button');
            pendingLichSoulBlast = { row, col, range, button: controlButton };
            movesLeft -= LICH_SOUL_BLAST_COST;
            updateStatus();
            updateEndTurnButton();
            gameLog.push('Channeling Soul Blast (2 move points spent).');
            updateGameLog();
            coinTossSpecialEffect = 'lich-soul-blast';

            // Set lichSoulBlastResolving = true at the START to block AI during entire sequence
            lichSoulBlastResolving = true;
            pauseGameForSoulBlast();
            coinTossSoulBlastHold = true;
            performCoinToss(
                'Soul Blast',
                'Attempting to channel captured souls...',
                (success) => {
                    const context = pendingLichSoulBlast;
                    pendingLichSoulBlast = null;
                    if (!context) {
                        lichSoulBlastResolving = false;
                        resumeGameAfterSoulBlast();
                        return;
                    }
                    const currentPiece = board[context.row]?.[context.col];
                    if (!success) {
                        gameLog.push('Soul Blast fizzled before it could be unleashed.');
                        updateGameLog();
                        clearActiveControlButton(context.button);
                        lichSoulBlastResolving = false;
                        resumeGameAfterSoulBlast();
                        return;
                    }
                    if (!currentPiece || currentPiece.player !== currentPlayer || currentPiece.type !== 'Lich') {
                        clearActiveControlButton(context.button);
                        lichSoulBlastResolving = false;
                        resumeGameAfterSoulBlast();
                        return;
                    }
                    const availableTargets = getLichSoulBlastTargets(context.row, context.col, context.range);
                    if (!availableTargets.length) {
                        gameLog.push('No valid Soul Blast targets remained.');
                        updateGameLog();
                        clearActiveControlButton(context.button);
                        clearSoulBlastPreview();
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        lichSoulBlastResolving = false;
                        resumeGameAfterSoulBlast();
                        return;
                    }
                    // Mark piece as moved immediately after coin flip succeeds (like energy blast)
                    lastAction = { move: true };
                    movedPieces.add(`${context.row},${context.col}`);

                    const prepareSoulBlastTargeting = () => {
                        lichSoulBlastMode = { row: context.row, col: context.col, range: context.range, button: context.button };
                        setActiveControlButton(context.button);
                        selectedPiece = { row: context.row, col: context.col };
                        validMoves = availableTargets;
                        updateSoulBlastPreview(context.row, context.col, availableTargets);
                        gameLog.push('Soul Blast is ready - select a target square.');
                        updateGameLog();
                        renderBoard();
                    };
                    applyEnergyBlastGlow({ variant: 'soul-blast' });
                    // Wait for coin flip popup to close before showing soul blast popup (800ms display + 300ms fade = 1100ms)
                    setTimeout(() => {
                        showEnergyBlastPopup(prepareSoulBlastTargeting, { title: 'SOUL BLAST', subtitle: 'Spell Unleashed', keepPaused: true });
                    }, 1100);
                },
                false,
                false
            );
        }

        function fireLichSoulBlastTarget(row, col) {
            if (!lichSoulBlastMode) return;
            const { row: originRow, col: originCol, button } = lichSoulBlastMode;
            const piece = board[originRow]?.[originCol];
            if (!piece || piece.type !== 'Lich') {
                lichSoulBlastMode = null;
            }
            if (!piece || piece.player !== currentPlayer) {
                clearActiveControlButton(button);
                cancelSpecialModes({ resetSelection: true });
                return;
            }
            const originKey = `${originRow},${originCol}`;
            movedPieces.add(originKey);
            const targetPiece = board[row]?.[col];
            if (!targetPiece || targetPiece.player === piece.player) {
                lichSoulBlastMode = null;
                clearActiveControlButton(button);
                selectedPiece = null;
                validMoves = [];
                clearSoulBlastPreview();
                showPieceInfo(null);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                gameLog.push('Soul Blast target was no longer valid.');
                updateGameLog();
                lichSoulBlastPendingCompletion = false;
                lichSoulBlastTargetInfo = null;
                lichSoulBlastResolving = false;
                resumeGameAfterSoulBlast();
                return;
            }
            lichSoulBlastMode = null;
            const playerLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
            const logMessage = `${playerLabel}'s Lich unleashed Soul Blast on ${targetPiece.type} at ${formatBoardCoordinates(row,col)}.`;
            const targets = [{
                row,
                col,
                defender: targetPiece.player,
                logMessage,
                attackerType: 'Lich'
            }];
            const pathSquares = getSoulBlastPath(originRow, originCol, row, col);
            const animationPath = pathSquares.length ? pathSquares : [{ row, col }];
            lichSoulBlastPendingCompletion = true;
            lichSoulBlastTargetInfo = { row, col, type: targetPiece.type };
            lockSoulBlastPreviewToPath(animationPath);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            pauseGameForSoulBlast();
            applyEnergyBlastGlow({ variant: 'soul-blast' });
            applySoulBlastSlowMo();
            // lichSoulBlastResolving already set to true at start of activateLichSoulBlast
            // Match energy blast's finishEnergyBlast structure
            const finishSoulBlast = () => {
                selectedPiece = null;
                validMoves = [];
                showPieceInfo(null);
                renderBoard();
                updateScoreDisplay();
                updateCapturedPiecesDisplay();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                removeSoulBlastSlowMo(true); // Remove slow-mo immediately for faster resume
                removeEnergyBlastGlow();
                clearSoulBlastPreview();
                clearActiveControlButton(button);
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            };
            const finalizeSoulBlast = () => {
                finishSoulBlast();
                resumeGameAfterSoulBlast();
                restoreSoulBlastInteractionState();
                lichSoulBlastResolving = false;
            };
            const resolveTargets = () => {
                resolveSpellTargetsSequentially(targets, piece.player, 'Soul Blast', (capturesHit) => {
                    if (capturesHit > 0) {
                        applySoulBlastSlowMo();
                        const details = lichSoulBlastTargetInfo;
                        if (details) {
                            gameLog.push(`Soul Blast completed: the Lich captured ${details.type} at ${formatBoardCoordinates(details.row,details.col)}.`);
                        } else {
                            gameLog.push('Soul Blast completed: the Lich captured its target.');
                        }
                    } else if (lichSoulBlastPendingCompletion) {
                        gameLog.push('Soul Blast dissipated before claiming its target.');
                    }
                    if (animationPath.length) {
                        addEnergyBlastResidualSquares(animationPath);
                    }
                    lichSoulBlastPendingCompletion = false;
                    lichSoulBlastTargetInfo = null;
                    finalizeSoulBlast();
                });
            };
            animateEnergyBlastPath(
                animationPath,
                () => {
                    resolveTargets();
                },
                { stepDuration: 420, finalDelay: 700 }
            );
        }

        function getValidTeleportSwapMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const opponent = player === 'W' ? 'B' : 'W';
            const color = (row + col) % 2;
            let moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player === opponent && (r + c) % 2 === color) {
                        moves.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                    }
                }
            }
            return moves;
        }

        function getValidChargeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                let r = row, c = col;
                while (true) {
                    r += d[0];
                    c += d[1];
                    if (!isValid(r, c)) break;
                    if (board[r][c]) {
                        if (board[r][c].player !== player) {
                            moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                        }
                        break;
                    }
                    moves.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                }
            }
            return moves;
        }

        function getElephantryChargeMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            const player = piece.player;
            const facing = piece.facing;
            let moves = [];

            if (elephantryChargeUsed.has(piece)) return moves;

            // Determine forward directions based on facing
            let directions = [];
            if (facing === 'U') {
                directions = [[-1,0], [-1,-1], [-1,1]]; // Up, Up-Left, Up-Right
            } else if (facing === 'D') {
                directions = [[1,0], [1,-1], [1,1]]; // Down, Down-Left, Down-Right
            } else if (facing === 'L') {
                directions = [[0,-1], [-1,-1], [1,-1]]; // Left, Up-Left, Down-Left
            } else if (facing === 'R') {
                directions = [[0,1], [-1,1], [1,1]]; // Right, Up-Right, Down-Right
            }

            for (let d of directions) {
                let capturesInPath = [];
                let canCharge = true;
                let finalPos = null;

                // Check all 3 squares in this direction
                for (let dist = 1; dist <= 3; dist++) {
                    let r = row + d[0] * dist;
                    let c = col + d[1] * dist;

                    if (!isValid(r, c)) {
                        canCharge = false;
                        break;
                    }

                    const target = board[r][c];
                    if (target) {
                        // Cannot charge through Spectre or Zombies
                        if (target.type === 'Spectre') {
                            canCharge = false;
                            break;
                        }

                        // Can capture enemy pieces
                        if (target.player !== player) {
                            capturesInPath.push([r, c, target.type]);
                            // Stop on Elephantry, Ogre, Troll, or Dragon (but still capture them)
                            if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                finalPos = [r, c];
                                break;
                            }
                        } else {
                            // Cannot charge through own pieces
                            canCharge = false;
                            break;
                        }
                    }

                    // If we've gone 3 squares without stopping, this is the final position
                    if (dist === 3) {
                        finalPos = [r, c];
                    }
                }

                if (canCharge && finalPos) {
                    moves.push({
                        type: 'move',
                        pos: finalPos,
                        cost: 2,
                        special: 'elephantryCharge',
                        captures: capturesInPath
                    });
                }
            }

            return moves;
        }

        function getElephantryExtendedRangeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            const pieceKey = `${row},${col},${player}`;
            let moves = [];

            // Initialize if not set
            if (!(pieceKey in elephantryExtendedRangeShotsRemaining)) {
                elephantryExtendedRangeShotsRemaining[pieceKey] = 3;
            }

            if (elephantryExtendedRangeShotsRemaining[pieceKey] <= 0) return moves;

            // Only forward-facing lines (head-on + forward-left/right diagonals) should be considered
            const directions = getElephantryTripleShotDirections(piece.facing);
            const shotsRemaining = elephantryExtendedRangeShotsRemaining[pieceKey];
            for (let d of directions) {
                for (let dist = 1; dist <= 2; dist++) {
                    let nr = row + d[0] * dist;
                    let nc = col + d[1] * dist;
                    if (!isValid(nr, nc)) break;
                    const target = board[nr][nc];
                    if (!target) continue;
                    if (target.player !== player && target.type !== 'Spectre') {
                        moves.push({
                            type: 'shoot',
                            pos: [nr, nc],
                            cost: 0, // No additional cost per shot - already paid 2 points on activation
                            special: 'elephantryExtendedRange',
                            shotsRemaining
                        });
                    }
                    break;
                }
            }

            return filterShootMovesForPlayer(moves, player);
        }

        function handleClick(row, col) {
            const huntsmanSelectionActive = !!(huntsmanBurstMode && selectedPiece && selectedPiece.row === huntsmanBurstMode.row && selectedPiece.col === huntsmanBurstMode.col);
            if (gameOver || currentPlayer !== 'W' || reinforcementPending || zombieAutoAdvanceInProgress) return;
            if (gamePaused && !huntsmanSelectionActive && !lichSoulBlastMode) return;
            const piece = board[row][col];

            if (isAnySpecialModeActive() && !huntsmanSelectionActive) {
                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    cancelSpecialModes({ resetSelection: false });
                    return;
                }
                if (!selectedPiece) {
                    cancelSpecialModes();
                    return;
                }
                // Don't auto-cancel when clicking different squares - let mode handlers decide
                // if (selectedPiece && (selectedPiece.row !== row || selectedPiece.col !== col)) {
                //     cancelSpecialModes();
                // }
            }

            if (lichSoulBlastMode && selectedPiece) {
                const move = validMoves.find(
                    m => m.pos[0] === row && m.pos[1] === col && m.special === 'lichSoulBlast'
                );
                if (move) {
                    fireLichSoulBlastTarget(move.pos[0], move.pos[1]);
                }
                // Keep Soul Blast mode active until a valid target is clicked
                return;
            }

            // Handle Inferno Mode
            if (infernoMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'inferno');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const toRow = move.pos[0];
                    const toCol = move.pos[1];

                    // 1. Perform the initial 1-square move (handles landing capture)
                    movePiece(fromRow, fromCol, toRow, toCol, null);
                    
                    // 2. Perform the adjacent Inferno captures
                    performInfernoCapture(toRow, toCol, currentPlayer);

                    // 3. Update state
                    dragonInfernoUsed[currentPlayer] = true;
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${toRow},${toCol}`);
                    
                    selectedPiece = null;
                    validMoves = [];
                    infernoMode = false;
                    
                    // 4. Re-render and check game state
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            
            // Handle Archer Turn+Shoot mode (after confirming turn)
            if (turnAndShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndShootMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Move + Diagonal (1) Shoot special
            if (archerMoveDiagMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= 1) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    // Perform the 1-point move first
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    movesLeft -= 1;
                    // Prepare diagonal 1-square shoot options from new position
                    selectedPiece = { row, col };
                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                    let options = [];
                    for (let d of dirs) {
                        const nr = row + d[0], nc = col + d[1];
                        if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                            options.push({ type: 'shoot', pos: [nr, nc], cost: 1, special: 'archerDiag1' });
                        }
                    }
                    options = filterShootMovesForPlayer(options, currentPlayer);
                    if (!options.length) {
                        archerMoveDiagMode = false;
                        archerDiagShootSelectMode = false;
                        selectedPiece = null;
                        validMoves = [];
                        clearActiveControlButton();
                        showPieceInfo(null);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        gameLog.push('No valid targets for Archer diagonal shot.');
                        updateGameLog();
                        return;
                    }
                    validMoves = options;
                    // Switch to the second phase: select diagonal shot
                    archerMoveDiagMode = false;
                    archerDiagShootSelectMode = true;
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle second phase of Archer Move + Diagonal (1) Shoot
            if (archerDiagShootSelectMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const currentRow = selectedPiece.row;
                    const currentCol = selectedPiece.col;
                    shootPiece(currentRow, currentCol, row, col, 'Skirmish');
                    movesLeft -= move.cost; // spend second point
                    lastAction = { move: true };
                    // Mark both original and current squares as moved if we have the original
                    if (archerMoveDiagStart) {
                        movedPieces.add(`${archerMoveDiagStart.row},${archerMoveDiagStart.col}`);
                    }
                    movedPieces.add(`${currentRow},${currentCol}`);
                    archerMoveDiagShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiagShootSelectMode = false;
                    archerMoveDiagStart = null;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Archer Diagonal 2-square Shot special
            if (archerDiag2ShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'shoot');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    shootPiece(fromRow, fromCol, row, col, 'Longshot');
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    archerDiag2ShootUsed[currentPlayer]++;
                    selectedPiece = null;
                    validMoves = [];
                    archerDiag2ShootMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Strafe special move
            if (summonSpectreMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonSpectre');
                if (move && movesLeft >= move.cost) {
                    const wizardRow = selectedPiece.row;
                    const wizardCol = selectedPiece.col;
                    const wizardPiece = board[wizardRow][wizardCol];

                    // Store placement info for callback
                    const summonRow = row;
                    const summonCol = col;

                    // Deduct points immediately
                    movesLeft -= move.cost; // cost 2

                    // Trigger coin toss
                    performCoinToss(
                        'Summon Spectre',
                        'Attempting to summon a Spectre...',
                        (success) => {
                            if (success) {
                                // Place Spectre at selected location
                                board[summonRow][summonCol] = { type: 'Spectre', player: currentPlayer };
                                spectresSummoned[currentPlayer]++;
                                wizardSummonedThisTurn[currentPlayer] = true;

                                // Mark wizard as unable to move next turn
                                wizardCannotMoveNextTurn[currentPlayer].add(`${wizardRow},${wizardCol}`);

                                // Award 3 bonus points for successful summoning
                                scores[currentPlayer] += 3;
                                registerScoreGain(currentPlayer, 3);
                                updateScoreDisplay();

                                gameStats.summonCount[currentPlayer]++; // Track summon for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} summoned a Spectre! (+3 bonus points)`);
                            } else {
                                // Failed summoning
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to summon a Spectre.`);
                            }

                            selectedPiece = null;
                            validMoves = [];
                            summonSpectreMode = false;
                            clearActiveControlButton();
                            showPieceInfo(null);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
                        },
                        false, // automated
                        false  // showOverlay
                    );
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (darkVoidMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'summonDarkVoid');
                if (move && movesLeft >= move.cost) {
                    const targetRow = row;
                    const targetCol = col;
                    const occupant = board[targetRow][targetCol];
                    if (occupant) {
                        capturePieceForZombie(currentPlayer, targetRow, targetCol, occupant);
                        updateCapturedPiecesDisplay();
                        updateScoreDisplay();
                    }
                    board[targetRow][targetCol] = { type: 'DarkVoid' };
                    darkVoidSquares.add(darkVoidKey(targetRow, targetCol));
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    darkVoidUses[currentPlayer] = (darkVoidUses[currentPlayer] || 0) + 1;
                    movesLeft -= move.cost;
                    lastAction = { special: 'darkVoid' };
                    selectedPiece = null;
                    validMoves = [];
                    darkVoidMode = null;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    showDarkVoidPopup();
                    const coordLabel = formatBoardCoordinates(targetRow, targetCol);
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} unleashed Dark Void at ${coordLabel}.`);
                    updateGameLog();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (strafeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'strafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const piece = board[fromRow][fromCol];

                    // Perform the move
                    movePiece(fromRow, fromCol, row, col);
                    movesLeft -= move.cost; // cost 2
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`); // Mark destination as moved so piece can't move again

                    // Increment usage counter based on piece type
                    if (piece.type === 'Wizard') {
                        wizardStrafeUsed[currentPlayer]++;
                    } else if (piece.type === 'Dragon') {
                        dragonStrafeUsed[currentPlayer]++;
                    }

                    selectedPiece = null;
                    validMoves = [];
                    strafeMode = false;
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Fusilier Strafe special move
            if (fusilierStrafeActive && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'fusilierStrafe');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Perform the move (no capture)
                    board[row][col] = board[fromRow][fromCol];
                    board[fromRow][fromCol] = null;

                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier strafed to ${formatBoardCoordinates(row,col)}`);

                    selectedPiece = null;
                    validMoves = [];
                    fusilierStrafeActive = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            if (turnAndMoveMode && selectedPiece && board[selectedPiece.row][selectedPiece.col]?.type === 'Infantry') {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && move.type === 'move' && movesLeft >= 1) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    movesLeft -= 1;
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    turnAndMoveMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (guardOfHonourMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'swap');
                if (move && movesLeft >= move.cost) {
                    const guardRow = move.pos[0];
                    const guardCol = move.pos[1];
                    const guard = board[guardRow][guardCol];
                    board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                    board[selectedPiece.row][selectedPiece.col] = guard;
                    kingSpecialUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} and ${formatBoardCoordinates(guardRow,guardCol)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${guardRow},${guardCol}`);
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    selectedPiece = null;
                    validMoves = [];
                    guardOfHonourMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    checkSupremacy(currentPlayer);
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleport');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;
                    const teleportPiece = board[fromRow][fromCol];
                    board[move.pos[0]][move.pos[1]] = teleportPiece;
                    board[fromRow][fromCol] = null;
                    if (teleportPiece.type === 'Wizard') {
                        wizardTeleportUsed[currentPlayer]++;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    } else if (teleportPiece.type === 'Necromancer') {
                        incrementNecromancerTeleportCount(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    } else if (teleportPiece.type === 'UndeadChampion') {
                        undeadChampionTeleportUsed.add(teleportPiece);
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Undead Champion from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                    }
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (teleportSwapMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'teleportSwap');
                if (move && movesLeft >= move.cost) {
                    const opponentWizardRow = move.pos[0];
                    const opponentWizardCol = move.pos[1];
                    const playerWizard = board[selectedPiece.row][selectedPiece.col];
                    const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                    board[opponentWizardRow][opponentWizardCol] = playerWizard;
                    board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                    wizardTeleportSwapUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} with opponent's Wizard at ${formatBoardCoordinates(opponentWizardRow,opponentWizardCol)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    selectedPiece = null;
                    validMoves = [];
                    teleportSwapMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }
            if (chargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.type === 'move');
                if (move && movesLeft >= move.cost) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col, move.jump);
                    cavalryChargeUsed[currentPlayer] = true;
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Charge to move Cavalry from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(row,col)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    chargeMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Charge
            if (elephantryChargeMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryCharge');
                if (move && movesLeft >= move.cost) {
                    const fromRow = selectedPiece.row;
                    const fromCol = selectedPiece.col;

                    // Process all captures along the path
                    if (move.captures && move.captures.length > 0) {
                        for (let [captureRow, captureCol, captureType] of move.captures) {
                            const capturedPiece = board[captureRow][captureCol];
                            if (capturedPiece) {
                                capturedSquares.push([captureRow, captureCol]);
                                recordGraveyardCapture(currentPlayer, capturedPiece);
                                const captureValue = pieceValues[capturedPiece.type];
                                scores[currentPlayer] += captureValue;
                                registerScoreGain(currentPlayer, captureValue, true);
                                registerPieceLoss(capturedPiece.player, capturedPiece.type);
                                trackCapture(currentPlayer); // Track capture for statistics
                                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry charged and captured ${capturedPiece.type} (+${captureValue} points) at ${formatBoardCoordinates(captureRow,captureCol)}`);

                                if (capturedPiece.type === 'Champion') {
                                    championCaptured[capturedPiece.player] = true;
                                }
                                if (capturedPiece.type === 'King') {
                                    endGame(currentPlayer);
                                    return;
                                }
                                board[captureRow][captureCol] = null;
                            }
                        }
                    }

                    // Move the Elephantry to final position
                    movePiece(fromRow, fromCol, row, col, null);
                    const chargedPiece = board[row][col];
                    if (chargedPiece) {
                        elephantryChargeUsed.add(chargedPiece);
                    }
                    gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Elephantry Charge from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(row,col)}`);
                    movesLeft -= move.cost;
                    lastAction = { move: true };
                    movedPieces.add(`${fromRow},${fromCol}`);
                    movedPieces.add(`${row},${col}`);
                    selectedPiece = null;
                    validMoves = [];
                    elephantryChargeMode = false;
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    updateCapturedPiecesDisplay();
                    updateScoreDisplay();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Pistolier move+shoot final shot selection
            if (pistolierMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'pistolierMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col, 'Move and Shot');

                    // Clean up
                    pistolierMoveShootMode = false;
                    pistolierMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry move+shoot final shot selection
            if (elephantryMoveShootMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryMoveShootFinal');
                if (move) {
                    // Execute the shoot
                    shootPiece(selectedPiece.row, selectedPiece.col, row, col, 'Move and Shot');

                    // Clean up
                    elephantryMoveShootMode = false;
                    elephantryMoveShootPosition = null;
                    selectedPiece = null;
                    validMoves = [];
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Elephantry Triple Shot
            if (elephantryExtendedRangeActive && selectedPiece) {
                if (!elephantryTripleShotAwaitingTargets) {
                    return;
                }
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'elephantryExtendedRange');
                if (move) {
                    const targetRow = row;
                    const targetCol = col;
                    const elephantryRow = selectedPiece.row;
                    const elephantryCol = selectedPiece.col;
                    const shotIndex = elephantryTripleShotNextShot;

                    // Only successful flips are in the array, so check bounds
                    if (shotIndex >= elephantryTripleShotFlipResults.length) {
                        return;
                    }

                    const shotsRemainingAfter = Math.max(0, elephantryTripleShotFlipResults.length - (shotIndex + 1));
                    if (elephantryTripleShotPieceKey) {
                        elephantryExtendedRangeShotsRemaining[elephantryTripleShotPieceKey] = shotsRemainingAfter;
                    }
                    elephantryTripleShotNextShot++;

                    // All flips in array are successful, so process as hit
                    const targetPiece = board[targetRow][targetCol];
                    if (targetPiece && targetPiece.type === 'Spectre') {
                        gameLog.push('Elephantry triple shot cannot target Spectres.');
                    } else if (targetPiece && targetPiece.player !== currentPlayer && (isUndeadType(targetPiece) || isUndeadChampionType(targetPiece))) {
                        // Handle undead pieces - deduct 1 life per hit
                        const actorLabel = currentPlayer === 'W' ? 'Player' : 'AI';
                        const undeadName = isUndeadChampionType(targetPiece) ? 'Undead Champion' : 'Undead';
                        const currentLives = typeof targetPiece.lives === 'number' ? targetPiece.lives : (targetPiece.maxLives || 1);
                        targetPiece.lives = currentLives - 1;

                        if (targetPiece.lives <= 0) {
                            // Undead destroyed
                        capturedSquares.push([targetRow, targetCol]);
                        recordGraveyardCapture(currentPlayer, targetPiece);
                            const captureValue = pieceValues[targetPiece.type];
                            scores[currentPlayer] += captureValue;
                            registerScoreGain(currentPlayer, captureValue, true);
                            registerPieceLoss(targetPiece.player, targetPiece.type);
                            trackCapture(currentPlayer);
                            gameLog.push(`${actorLabel} Elephantry triple shot shattered the ${undeadName}! (+${captureValue} points)`);
                            cleanupNecromancerTracking(targetPiece);
                            board[targetRow][targetCol] = null;
                            updateCapturedPiecesDisplay();
                            updateScoreDisplay();
                            checkSupremacy(currentPlayer);
                        } else {
                            // Undead damaged but alive
                            const livesText = targetPiece.lives === 1 ? '1 life' : `${targetPiece.lives} lives`;
                            gameLog.push(`${actorLabel} Elephantry triple shot hit the ${undeadName}! (${livesText} remaining)`);
                        }
                    } else if (targetPiece && targetPiece.player !== currentPlayer) {
                        capturedSquares.push([targetRow, targetCol]);
                        recordGraveyardCapture(currentPlayer, targetPiece);
                        const captureValue = pieceValues[targetPiece.type];
                        scores[currentPlayer] += captureValue;
                        registerScoreGain(currentPlayer, captureValue, true);
                        registerPieceLoss(targetPiece.player, targetPiece.type);
                        trackCapture(currentPlayer); // Track capture for statistics
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot hit! Captured ${targetPiece.type} (+${captureValue} points)`);

                        if (targetPiece.type === 'Champion') {
                            championCaptured[targetPiece.player] = true;
                        }
                        if (targetPiece.type === 'King') {
                            endGame(currentPlayer);
                            return;
                        }
                        board[targetRow][targetCol] = null;
                        updateCapturedPiecesDisplay();
                        updateScoreDisplay();
                        checkSupremacy(currentPlayer);
                    } else {
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry triple shot missed at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                    }

                    updateGameLog();
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();

                    if (shotsRemainingAfter > 0) {
                        const nextMoves = getElephantryExtendedRangeMoves(elephantryRow, elephantryCol);
                        if (!nextMoves.length) {
                            gameLog.push('No remaining targets for Elephantry Triple Shot.');
                            finishElephantryTripleShot();
                            return;
                        }
                        validMoves = nextMoves;
                        renderBoard();
                    } else {
                        finishElephantryTripleShot();
                        return;
                    }

                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes({ resetSelection: false });
                }
                return;
            }

            // Handle Huntsman burst destination selection
            if (huntsmanBurstMode && selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'huntsmanBurst');
                if (move) {
                    const context = huntsmanBurstMode;
                    const fromRow = context.row;
                    const fromCol = context.col;
                    movePiece(fromRow, fromCol, row, col, move.jump);
                    lastAction = { move: true };
                    movedPieces.add(`${row},${col}`);
                    huntsmanBurstMode = null;
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    clearActiveControlButton(context?.controlButton || document.getElementById('huntsman-burst-button'));
                    resumeGameAfterHuntsmanBurst();
                    if (context && typeof context.onComplete === 'function') {
                        context.onComplete();
                    }
                    updateGameLog();
                    checkGameOver();
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                }
                return;
            }

        // Handle Champion summon targeting
        if (championSummonMode && selectedPiece) {
            const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'championSummon');
            if (move) {
                const summonType = move.summonType;
                const source = championSummonMode.source || selectedPiece;
                const expectedOwner = championSummonMode.player || null;
                const fromRow = source.row;
                const fromCol = source.col;
                const champion = board[fromRow]?.[fromCol];
                championSummonMode = null;
                if (!champion || champion.type !== 'Champion') {
                    validMoves = [];
                    selectedPiece = null;
                    renderBoard();
                    return;
                }
                const championOwner = champion.player;
                if ((expectedOwner && championOwner !== expectedOwner) || championOwner !== currentPlayer) {
                    validMoves = [];
                    selectedPiece = null;
                    renderBoard();
                    return;
                }
                movesLeft = Math.max(0, movesLeft - move.cost);
                updateStatus();
                updateEndTurnButton();
                const targetRow = move.pos[0];
                    const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    const playerLabel = championOwner === 'W' ? 'Player' : getOpponentDisplayName();
                    const attemptLabel = summonType === 'Huntsman' ? 'Summon Huntsman' : 'Summon Necromancer';
                    const attemptMessage = `${playerLabel} attempts to summon a ${summonType}...`;
                    performCoinToss(
                        attemptLabel,
                        attemptMessage,
                        (success) => {
                            if (success) {
                                if (!board[targetRow][targetCol]) {
                                    if (summonType === 'Huntsman') {
                                        board[targetRow][targetCol] = { type: 'Huntsman', player: championOwner };
                                        recordHuntsmanSpawn(championOwner);
                                    } else {
                                        const necromancerPiece = { type: 'Necromancer', player: championOwner, facing: null };
                                        board[targetRow][targetCol] = necromancerPiece;
                                        necromancersSummoned[championOwner] = (necromancersSummoned[championOwner] || 0) + 1;
                                        necromancerTeleportCounts.set(necromancerPiece, 0);
                                        setNecromancerShotCooldown(necromancerPiece, 0);
                                    }
                                    gameStats.summonCount[championOwner]++;
                                    gameLog.push(`${playerLabel} summoned a ${summonType} at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                                } else {
                                    gameLog.push(`${playerLabel}'s ${summonType} summon succeeded but the chosen square was occupied.`);
                                }
                            } else {
                                gameLog.push(`${playerLabel} failed to summon a ${summonType}.`);
                            }
                            lastAction = { move: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            if (movesLeft === 0 && !reinforcementPending) {
                                triggerAiTurn();
                            }
            },
            false,
            false
        );
                }
                return;
            }

        // Handle Necromancer summon targeting
        if (necromancerSummonMode && selectedPiece) {
            let move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'necromancerSummon');
            if (!move && necromancerSummonMode && (necromancerSummonMode.type === 'undead' || necromancerSummonMode.type === 'undeadchampion') && board[row]?.[col]?.type === 'DarkVoid') {
                move = createDarkVoidUndeadMove(row, col, necromancerSummonMode.type);
            }
            if (move) {
                processNecromancerSummonMove(move, necromancerSummonMode);
            }
            return;
        }

        // Handle King summon placement
        if (kingSummonMode) {
            if (row === kingSummonMode.backRow && kingSummonMode.emptySquares.includes(col)) {
                completeKingSummonPlacement(row, col);
            }
            return;
        }

            if (necromancerSummonMode && selectedPiece) {
                let move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col && m.special === 'necromancerSummon');
                if (!move && necromancerSummonMode && (necromancerSummonMode.type === 'undead' || necromancerSummonMode.type === 'undeadchampion') && board[row]?.[col]?.type === 'DarkVoid') {
                    move = createDarkVoidUndeadMove(row, col, necromancerSummonMode.type);
                }
                if (move) {
                    const summonType = move.summonType;
                    const summonContext = necromancerSummonMode;
                    const source = summonContext?.source || selectedPiece;
                    const expectedPlayer = summonContext?.player || null;
                    const fromRow = source.row;
                    const fromCol = source.col;
                    const necromancer = board[fromRow]?.[fromCol];
                    necromancerSummonMode = null;
                    const validNecro = necromancer && necromancer.type === 'Necromancer';
                    const validLich = necromancer && necromancer.type === 'Lich';
                    const requiresNecro = summonType !== 'undead' && summonType !== 'undeadchampion';
                    if (!necromancer || (requiresNecro && !validNecro) || (!requiresNecro && !(validNecro || validLich))) {
                        validMoves = [];
                        selectedPiece = null;
                        renderBoard();
                        return;
                    }
                const necromancerOwner = necromancer.player;
                if ((expectedPlayer && necromancerOwner !== expectedPlayer) || necromancerOwner !== currentPlayer) {
                    validMoves = [];
                    selectedPiece = null;
                    renderBoard();
                    return;
                }
                movesLeft = Math.max(0, movesLeft - move.cost);
                updateStatus();
                updateEndTurnButton();
                const targetRow = move.pos[0];
                const targetCol = move.pos[1];
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                const playerLabel = necromancerOwner === 'W' ? 'Player' : getOpponentDisplayName();
                    const label = summonType === 'spectre' ? 'Spectre' : (summonType === 'lich' ? 'Lich' : (summonType === 'undead' ? 'Undead' : (summonType === 'undeadchampion' ? 'Undead Champion' : 'Zombie')));
                    const isLichSummoningUndead = summonType === 'undead' && summonContext?.summonerType === 'Lich';
                    const isLichSummoningUndeadChampion = summonType === 'undeadchampion' && summonContext?.summonerType === 'Lich';

                    const completeSummon = (success) => {
                        if (success) {
                            if (!board[targetRow][targetCol]) {
                                if (summonType === 'spectre') {
                                    board[targetRow][targetCol] = { type: 'Spectre', player: necromancerOwner };
                                    spectresSummoned[necromancerOwner]++;
                                } else if (summonType === 'lich') {
                                    board[targetRow][targetCol] = { type: 'Lich', player: necromancerOwner };
                                    lichesSummoned[necromancerOwner]++;
                                } else if (summonType === 'undeadchampion') {
                                    const summonerType = summonContext?.summonerType || 'Lich';
                                    const undeadChampionPiece = createUndeadChampionPiece(necromancerOwner, summonerType);
                                    board[targetRow][targetCol] = undeadChampionPiece;
                                    undeadChampionsSummoned[necromancerOwner] = (undeadChampionsSummoned[necromancerOwner] || 0) + 1;
                                } else {
                                    if (summonType === 'undead') {
                                        const summonerType = summonContext?.summonerType || 'Necromancer';
                                        const undeadLives = UNDEAD_LIVES_BY_SUMMONER[summonerType] || UNDEAD_LIVES_BY_SUMMONER['Necromancer'];
                                        const undeadPiece = createUndeadPiece(necromancerOwner, undeadLives, summonerType);
                                        board[targetRow][targetCol] = undeadPiece;
                                        undeadSummoned[necromancerOwner] = (undeadSummoned[necromancerOwner] || 0) + 1;
                                    } else {
                                        const zombiePiece = createZombiePiece(necromancerOwner);
                                        board[targetRow][targetCol] = zombiePiece;
                                        zombiesSummoned[necromancerOwner] = (zombiesSummoned[necromancerOwner] || 0) + 1;
                                    }
                                }
                                gameStats.summonCount[necromancerOwner]++;
                                gameLog.push(`${playerLabel} summoned a ${label} at ${formatBoardCoordinates(targetRow,targetCol)} - Coin flip successful!`);
                            } else {
                                gameLog.push(`${playerLabel}'s ${label} summon succeeded but the chosen square was occupied.`);
                            }
                        } else {
                            gameLog.push(`${playerLabel} failed to summon a ${label} - Coin flip failed.`);
                        }
                        lastAction = { move: true };
                        movedPieces.add(`${fromRow},${fromCol}`);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        updateGameLog();
                        checkGameOver();
                        if (movesLeft === 0 && !reinforcementPending && currentPlayer === 'W') {
                            triggerAiTurn();
                        }
                    };

                    if (isLichSummoningUndead) {
                        // Lich summoning undead requires 1 successful coin flip out of 2 attempts
                        performCoinToss(
                            `Summon ${label} - Flip 1/2`,
                            `${playerLabel} attempts first coin flip to summon ${label}...`,
                            (firstSuccess) => {
                                if (firstSuccess) {
                                    // First flip succeeded - summon successful, no need for second flip
                                    completeSummon(true);
                                } else {
                                    // First flip failed - try second flip
                                    performCoinToss(
                                        `Summon ${label} - Flip 2/2`,
                                        `${playerLabel} attempts second coin flip to summon ${label}...`,
                                        (secondSuccess) => {
                                            completeSummon(secondSuccess);
                                        },
                                        false,
                                        false
                                    );
                                }
                            },
                            false,
                            false
                        );
                    } else if (isLichSummoningUndeadChampion) {
                        // Lich summoning undead champion requires 1 successful coin flip
                        performCoinToss(
                            `Summon ${label}`,
                            `${playerLabel} attempts to summon ${label}...`,
                            (success) => {
                                completeSummon(success);
                            },
                            false,
                            false
                        );
                    } else {
                        performCoinToss(
                            `Summon ${label}`,
                            `${playerLabel} attempts to summon a ${label}...`,
                            (success) => {
                                completeSummon(success);
                            },
                            false,
                            false
                        );
                    }
                }
                return;
            }

            if (!selectedPiece && piece && piece.player === 'W' && !movedPieces.has(`${row},${col}`)) {
                // During mercenary bonus turn, only allow selecting the specific mercenary
                if (mercenaryBonusTurnActive &&
                    (row !== mercenaryBonusTurnPiece.row || col !== mercenaryBonusTurnPiece.col)) {
                    // Clicked on wrong piece during mercenary bonus turn
                    return;
                }
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                showPieceInfo(piece, piece.player);
                lastAction = null;
                renderBoard();
                updateEndTurnButton();
            } else if (selectedPiece) {
                const move = validMoves.find(m => m.pos[0] === row && m.pos[1] === col);
                if (move && movesLeft >= move.cost) {
                    if (move.type === 'move') {
                        // Handle Pistolier capturing by landing - requires coin flip
                        if (move.special === 'pistolierCapture') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss for capture
                            performCoinToss(
                                'Pistolier Capture',
                                `Attempting to capture at ${formatBoardCoordinates(toRow,toCol)}...`,
                                (success) => {
                                    if (success) {
                                        // Successfully captured
                                        movePiece(fromRow, fromCol, toRow, toCol, null);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier successfully captured by landing!`);
                                    } else {
                                        // Failed to capture - still move but don't capture
                                        const targetPiece = board[toRow][toCol];
                                        board[toRow][toCol] = board[fromRow][fromCol];
                                        board[fromRow][fromCol] = null;
                                        // Piece stays in place, no capture
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier failed to capture - move blocked.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    movedPieces.add(`${toRow},${toCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        }

                        // Handle Pistolier move+shoot combination - enter shoot selection mode
                        if (move.special === 'pistolierMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            pistolierMoveShootMode = true;
                            pistolierMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position (1 square diagonal only)
                            validMoves = [];
                            for (let d of [[1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'pistolierMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                            pistolierMoveShootMode = false;
                            pistolierMoveShootPosition = null;
                            selectedPiece = null;
                            clearActiveControlButton();
                            showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid pistolier targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Pistolier moved to ${formatBoardCoordinates(row,col)}, select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Handle Elephantry move+shoot combination - enter shoot selection mode
                        if (move.special === 'elephantryMoveShoot') {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            // Move to the position first
                            movePiece(fromRow, fromCol, row, col, null);
                            movesLeft -= move.cost;
                            movedPieces.add(`${fromRow},${fromCol}`);
                            movedPieces.add(`${row},${col}`);
                            lastAction = { move: true };

                            // Enter shoot selection mode
                            elephantryMoveShootMode = true;
                            elephantryMoveShootPosition = { row, col };
                            selectedPiece = { row, col };

                            // Generate shoot targets from new position
                            validMoves = [];
                            for (let d of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                                let shootR = row + d[0], shootC = col + d[1];
                                if (isValid(shootR, shootC) && board[shootR][shootC] && board[shootR][shootC].player !== currentPlayer) {
                                    validMoves.push({ type: 'shoot', pos: [shootR, shootC], cost: 0, special: 'elephantryMoveShootFinal' });
                                }
                            }
                            validMoves = filterShootMovesForPlayer(validMoves, currentPlayer);
                            if (!validMoves.length) {
                            elephantryMoveShootMode = false;
                            elephantryMoveShootPosition = null;
                            selectedPiece = null;
                            clearActiveControlButton();
                            showPieceInfo(null);
                                renderBoard();
                                updateStatus();
                                updateEndTurnButton();
                                gameLog.push('No valid elephantry targets after moving.');
                                updateGameLog();
                                return;
                            }

                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Elephantry moved to ${formatBoardCoordinates(row,col)}, select shoot target...`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            return;
                        }

                        // Check if capturing a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';

                        if (isCapturingSpectre && !captureExempt) {
                            // Store move info for callback
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const toRow = row;
                            const toCol = col;
                            const jump = move.jump;
                            const special = move.special;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            // Trigger coin toss
                            performCoinToss(
                                'Capture Spectre',
                                'Attempting to capture the Spectre...',
                                (success) => {
                                    let moveResult = null;
                                    if (success) {
                                        // Successfully captured Spectre
                                        moveResult = movePiece(fromRow, fromCol, toRow, toCol, jump);
                                        if (special === 'charge') {
                                            cavalryChargeUsed[currentPlayer] = true;
                                        }
                                        if (special === 'ballistaDoubleTime') {
                                            ballistaDoubleTimeUsed[currentPlayer]++;
                                        }
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} successfully captured the Spectre!`);
                                    } else {
                                        // Failed to capture Spectre - move not executed
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} failed to capture the Spectre.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);

                                    // Check if mercenary coin flip is needed
                                    if (success && moveResult?.mercenaryFlipNeeded) {
                                        const mercPiece = moveResult.mercenaryPiece;
                                        const mercPos = moveResult.mercenaryPos;

                                        handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                            selectedPiece = null;
                                            validMoves = [];
                                            showPieceInfo(null);
                                            renderBoard();
                                            updateStatus();
                                            updateEndTurnButton();
                                            updateGameLog();
                                            checkGameOver();

                                            if (bonusTurnGranted) {
                                                return; // Player continues their turn
                                            }

                                            if (mercenaryBonusTurnActive) {
                                                deactivateMercenaryBonusTurn();
                                            }
                                            if (movesLeft === 0 && !reinforcementPending) {
                                                triggerAiTurn();
                                            }
                                        });
                                        return;
                                    }

                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();

                                    // If we were in mercenary bonus turn mode and didn't get another bonus turn, clear the state
                                    if (mercenaryBonusTurnActive) {
                                        deactivateMercenaryBonusTurn();
                                    }
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else {
                            if (move.special === 'infantryStrafe') {
                                const targetPiece = board[row][col];
                                if (targetPiece && targetPiece.player !== currentPlayer) {
                                    const actorLabel = currentPlayer === 'W' ? 'Player' : getOpponentDisplayName();
                                    if (!mercenaryBonusTurnActive) {
                                        movesLeft -= move.cost;
                                    }
                                    performCoinToss(
                                        'Infantry Strafe Capture',
                                        `Attempting to strafe capture ${targetPiece.type} at ${formatBoardCoordinates(row,col)}...`,
                                        (success) => {
                                            if (!success) {
                                                gameLog.push(`${actorLabel} failed to strafe capture ${targetPiece.type} at ${formatBoardCoordinates(row,col)}.`);
                                                updateGameLog();
                                                finalizePostMoveState();
                                                if (movesLeft === 0 && !reinforcementPending) {
                                                    triggerAiTurn();
                                                }
                                                return;
                                            }
                                            gameLog.push(`${actorLabel} successfully strafed ${targetPiece.type} at ${formatBoardCoordinates(row,col)}.`);
                                            updateGameLog();
                                            executeStandardMove(move, row, col, { costAlreadyDeducted: true });
                                        }
                                    );
                                    return;
                                }
                            }

                            executeStandardMove(move, row, col);
                            return;
                        }
                    } else if (move.type === 'shoot') {
                        // Check if shooting a Spectre - requires coin toss (except for Wizards/Spectres)
                        const targetPiece = board[row][col];
                        const attackingPiece = board[selectedPiece.row][selectedPiece.col];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = move.special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && move.special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            gameLog.push('Spectres are immune to standard shooting attacks.');
                            updateGameLog();
                            return;
                        } else if (autoCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            const pieceKey = `${fromRow},${fromCol},${currentPlayer}`;

                            movesLeft -= move.cost;

                            if (!(pieceKey in fusilierCrackShotCount)) {
                                fusilierCrackShotCount[pieceKey] = 3;
                            }
                            if (fusilierCrackShotCount[pieceKey] > 0) {
                                fusilierCrackShotCount[pieceKey]--;
                            }

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else if (usingCrackShot) {
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;

                            // Deduct points immediately
                            movesLeft -= move.cost;

                            performCoinToss(
                                'Crack Shot',
                                'Attempting Crack Shot...',
                                (success) => {
                                    // Mark the shot attempt for cooldown regardless of outcome
                                    fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                    fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                    fusilierCrackShotActive = null;

                                    if (success) {
                                        shootPiece(fromRow, fromCol, row, col);
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot hit!`);
                                    } else {
                                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Fusilier Crack Shot missed.`);
                                    }

                                    lastAction = { move: true };
                                    movedPieces.add(`${fromRow},${fromCol}`);
                                    selectedPiece = null;
                                    validMoves = [];
                                    showPieceInfo(null);
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    if (movesLeft === 0 && !reinforcementPending) {
                                        triggerAiTurn();
                                    }
                                },
                                false, // automated
                                false  // showOverlay
                            );
                            return;
                        } else if (move.special === 'voidBlast') {
                            // Void Blast - ranged attack for Undead Champion
                            const fromRow = selectedPiece.row;
                            const fromCol = selectedPiece.col;
                            shootPiece(fromRow, fromCol, row, col);
                            setUndeadChampionRangedCooldown(attackingPiece, 1);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} Undead Champion used Void Blast!`);
                            voidBlastMode = false;
                        } else {
                            // Normal shoot
                            shootPiece(selectedPiece.row, selectedPiece.col, row, col);
                            if (move.special === 'archerDiag2') {
                                archerDiag2ShootUsed[currentPlayer]++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        }
                    } else if (move.type === 'swap') {
                        const guardRow = move.pos[0];
                        const guardCol = move.pos[1];
                        const guard = board[guardRow][guardCol];
                        board[guardRow][guardCol] = board[selectedPiece.row][selectedPiece.col];
                        board[selectedPiece.row][selectedPiece.col] = guard;
                        kingSpecialUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Guard of Honour to swap King and Guard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} and ${formatBoardCoordinates(guardRow,guardCol)}`);
                        checkSupremacy(currentPlayer);
                        movedPieces.add(`${guardRow},${guardCol}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    } else if (move.type === 'teleport') {
                        const teleportPiece = board[selectedPiece.row][selectedPiece.col];
                        const abilityLabel = `${teleportPiece.type} Teleport`;
                        const result = teleportOntoSquare(selectedPiece.row, selectedPiece.col, move.pos[0], move.pos[1], currentPlayer, abilityLabel);
                        if (!result.success) {
                            cancelSpecialModes({ resetSelection: false });
                            return;
                        }
                        if (teleportPiece.type === 'Wizard') {
                            wizardTeleportUsed[currentPlayer]++;
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Wizard from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                        } else if (teleportPiece.type === 'Necromancer') {
                            incrementNecromancerTeleportCount(teleportPiece);
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported Necromancer from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                        } else {
                            gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} teleported ${teleportPiece.type} from ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} to ${formatBoardCoordinates(move.pos[0],move.pos[1])}`);
                        }
                        movedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                    } else if (move.type === 'teleportSwap') {
                        const opponentWizardRow = row;
                        const opponentWizardCol = col;
                        const playerWizard = board[selectedPiece.row][selectedPiece.col];
                        const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                        board[opponentWizardRow][opponentWizardCol] = playerWizard;
                        board[selectedPiece.row][selectedPiece.col] = opponentWizard;
                        wizardTeleportSwapUsed[currentPlayer] = true;
                        gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} used Teleport Swap to swap Wizard at ${formatBoardCoordinates(selectedPiece.row,selectedPiece.col)} with opponent's Wizard at ${formatBoardCoordinates(opponentWizardRow,opponentWizardCol)}`);
                        movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                        movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                    }
                    // Only deduct move cost if not in mercenary bonus turn mode
                    if (!mercenaryBonusTurnActive) {
                        movesLeft -= move.cost;
                    }
                    lastAction = { move: true };
                    movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
                    if (move.type === 'move' || move.type === 'teleport') {
                        movedPieces.add(`${row},${col}`);
                    }
                    selectedPiece = null;
                    validMoves = [];
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    checkGameOver();
                    // Clear mercenary bonus turn state after move completes
                    if (mercenaryBonusTurnActive) {
                        deactivateMercenaryBonusTurn();
                    }
                    if (movesLeft === 0 && !reinforcementPending) {
                        triggerAiTurn();
                    }
                } else {
                    cancelSpecialModes();
                }
            }
        }

        function openTurnModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-modal').style.display = 'block';
            }
        }

        function activateBallistaRange() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaRangeBoostUsedThisTurn[currentPlayer]) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                ballistaRangeBoostActive[currentPlayer] = true;
                ballistaRangeBoostUsedThisTurn[currentPlayer] = true;
                movesLeft -= 2;
                gameLog.push(`${currentPlayer === 'W' ? 'Player' : 'AI'} activated Ballista Extend Range (+1 range this round)`);
                // Keep the piece selected and recalculate valid moves with extended range
                validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                checkGameOver();
                if (movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            }
        }

        function getBallistaDoubleTimeMoves(row, col) {
            const piece = board[row][col];
            const player = piece.player;
            let moves = [];
            for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                const r1 = row + d[0], c1 = col + d[1];
                const r2 = row + d[0]*2, c2 = col + d[1]*2;
                if (!isValid(r1, c1) || board[r1][c1]) continue; // path blocked on first
                if (isValid(r2, c2) && !board[r2][c2]) {
                    // Ballista can only move to empty squares - cannot capture by landing
                    moves.push({ type: 'move', pos: [r2, c2], cost: 2, special: 'ballistaDoubleTime' });
                }
            }
            return moves;
        }

        function activateBallistaDoubleTime() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2 || ballistaDoubleTimeUsed[currentPlayer] >= 2) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Ballista') {
                const options = getBallistaDoubleTimeMoves(selectedPiece.row, selectedPiece.col);
                validMoves = options;
                renderBoard();
            }
        }
        function activateArcherMoveDiagShoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerMoveDiagMode || archerDiagShootSelectMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerMoveDiagShootUsed[currentPlayer] < 2) {
                archerMoveDiagMode = true;
                archerMoveDiagStart = { row: selectedPiece.row, col: selectedPiece.col };
                // Only allow the Archer's basic 1-square orthogonal moves for the first step
                const moves = pieceTypes['Archer'].move(selectedPiece.row, selectedPiece.col, board, currentPlayer, null, piece.facing) || [];
                validMoves = moves.filter(m => m.type === 'move' && m.cost === 1);
                renderBoard();
            }
        }

        function activateArcherDiag2Shoot() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (archerDiag2ShootMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && archerDiag2ShootUsed[currentPlayer] < 2) {
                archerDiag2ShootMode = true;
                // Compute diagonal 2-square shoot targets
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== currentPlayer) {
                        options.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
                options = filterShootMovesForPlayer(options, currentPlayer);
                if (!options.length) {
                    archerDiag2ShootMode = false;
                    selectedPiece = null;
                    validMoves = [];
                    clearActiveControlButton();
                    showPieceInfo(null);
                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    gameLog.push('No valid targets for Archer diagonal double shot.');
                    updateGameLog();
                    return;
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateStrafe() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (strafeMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const usedCount = piece.type === 'Wizard' ? wizardStrafeUsed[currentPlayer] : dragonStrafeUsed[currentPlayer];

            if ((piece.type === 'Wizard' || piece.type === 'Dragon') && usedCount < 2) {
                strafeMode = true;
                // Compute orthogonal 1-square moves to empty squares only
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'strafe' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateSummonSpectre() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (summonSpectreMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            const totalCaptured = getTotalCapturedCount();

            if (piece.type === 'Wizard' && spectresSummoned[currentPlayer] < 2 && !wizardSummonedThisTurn[currentPlayer] && totalCaptured >= 5) {
                summonSpectreMode = true;
                // Compute adjacent squares (8 directions) for Spectre placement
                const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                const row = selectedPiece.row, col = selectedPiece.col;
                let options = [];
                for (let d of dirs) {
                    const nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        options.push({ type: 'summon', pos: [nr, nc], cost: 2, special: 'summonSpectre' });
                    }
                }
                validMoves = options;
                renderBoard();
            }
        }

        function activateChampionSummon(type) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move || movesLeft < 2) return;
            if (championSummonMode) {
                cancelSpecialModes({ resetSelection: false });
                return;
            }
            if (isAnySpecialModeActive()) {
                cancelSpecialModes({ resetSelection: false });
            }
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (!piece || piece.type !== 'Champion' || (gameVariant !== '36s-elite' && gameVariant !== '36s-supreme')) return;
            const owner = piece.player;
            if (type === 'Necromancer') {
                if (!canChampionSummonNecromancer(owner)) {
                    gameLog.push('No Necromancer summons remaining.');
                    updateGameLog();
                    return;
                }
            } else if (type === 'Huntsman') {
                if (!canChampionSummonHuntsman(owner)) {
                    gameLog.push('No Huntsman summons remaining.');
                    updateGameLog();
                    return;
                }
            } else {
                return;
            }
            if (!hasBackRowSpawnSlot(owner)) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            const backRow = getBackRow(owner);
            const options = [];
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    options.push({ type: 'summon', pos: [backRow, c], cost: 2, special: 'championSummon', summonType: type });
                }
            }
            if (!options.length) {
                gameLog.push('No open squares on the back row to summon a unit.');
                updateGameLog();
                return;
            }
            championSummonMode = { type, player: owner, source: { row: selectedPiece.row, col: selectedPiece.col } };
            validMoves = options;
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            gameLog.push(`Select a back row square to summon a ${type}.`);
            updateGameLog();
        }

        function confirmTurn() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-modal').style.display = 'none';
            movesLeft -= turnCosts[piece.type];
            movedPieces.add(`${selectedPiece.row},${selectedPiece.col}`);
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
            checkGameOver();
            if (movesLeft === 0 && !reinforcementPending) {
                triggerAiTurn();
            }
        }

        function openTurnAndMoveModal() {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Infantry' && movesLeft >= 2) {
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-move-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-move-modal').style.display = 'block';
            }
        }

        function confirmTurnAndMove() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-move-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-move-modal').style.display = 'none';
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndMoveMode = true;
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function closeTurnModal() {
            const modal = document.getElementById('turn-modal');
            if (modal) modal.style.display = 'none';
        }

        /* Legacy necromancer summon modal functions removed in favor of highlight-based placement */

        function closeTurnMoveModal() {
            const modal = document.getElementById('turn-move-modal');
            if (modal) modal.style.display = 'none';
            clearActiveControlButton(document.getElementById('turn-move-button'));
            cancelSpecialModes({ resetSelection: false });
        }

        function closeTurnShootModal() {
            const modal = document.getElementById('turn-shoot-modal');
            if (modal) modal.style.display = 'none';
            clearActiveControlButton(document.getElementById('turn-shoot-button'));
            cancelSpecialModes({ resetSelection: false });
        }

        function openTurnAndShootModal(button = null) {
            if (!selectedPiece || currentPlayer !== 'W' || reinforcementPending || lastAction?.move) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            if (piece.type === 'Archer' && movesLeft >= 2) {
                setActiveControlButton(button || document.getElementById('turn-shoot-button'));
                const validDirections = getValidTurnDirections(piece.facing);
                const select = document.getElementById('turn-shoot-select');
                select.innerHTML = validDirections.map(dir => `<option value="${dir}">${dir} (${facingIcons[dir]})</option>`).join('');
                document.getElementById('turn-shoot-modal').style.display = 'block';
            }
        }

        function confirmTurnAndShoot() {
            if (!selectedPiece) return;
            const piece = board[selectedPiece.row][selectedPiece.col];
            const newFacing = document.getElementById('turn-shoot-select').value;
            turnPiece(selectedPiece.row, selectedPiece.col, newFacing);
            document.getElementById('turn-shoot-modal').style.display = 'none';
            // Spend 1 for the turn now; the shot will spend the 2nd point
            movesLeft -= 1;
            lastAction = { turn: true };
            turnAndShootMode = true;
            // Limit valid moves to only shooting options after the turn
            validMoves = getValidMoves(selectedPiece.row, selectedPiece.col).filter(m => m.type === 'shoot');
            renderBoard();
            updateStatus();
            updateEndTurnButton();
            updateGameLog();
        }

        function buildOgreRagePattern(row, col, dir, player) {
            const path = [];
            for (let step = 1; step <= 2; step++) {
                const nr = row + dir[0] * step;
                const nc = col + dir[1] * step;
                if (!isValid(nr, nc)) {
                    return null;
                }
                path.push([nr, nc]);
            }
            const dest = path[1];
            const destPiece = board[dest[0]][dest[1]];
            if (destPiece && destPiece.player === player) {
                return null;
            }
            const perp = dir[0] === 0 ? [[1, 0], [-1, 0]] : [[0, 1], [0, -1]];
            const seen = new Set();
            const area = [];
            const addPosition = (r, c) => {
                if (!isValid(r, c)) return true;
                if (r === row && c === col) return true;
                const key = `${r},${c}`;
                if (seen.has(key)) return true;
                const occupant = board[r][c];
                if (occupant && occupant.player === player) {
                    return false;
                }
                seen.add(key);
                area.push([r, c]);
                return true;
            };
            for (const square of path) {
                if (!addPosition(square[0], square[1])) {
                    return null;
                }
                for (const offset of perp) {
                    if (!addPosition(square[0] + offset[0], square[1] + offset[1])) {
                        return null;
                    }
                }
            }
            return { dest, area };
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece || movedPieces.has(`${row},${col}`)) return [];

            // Check if wizard is restricted from moving this turn
            if (piece.type === 'Wizard' && wizardCannotMoveNextTurn[piece.player].has(`${row},${col}`)) {
                return [];
            }

            const type = piece.type;
            const player = piece.player;
            let valid = [];
            
            // Handle Inferno Mode
            if (type === 'Dragon' && infernoMode && !dragonInfernoUsed[player] && movesLeft >= 2) {
                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (let d of directions) {
                    let nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                        valid.push({ type: 'move', pos: [nr, nc], cost: 2, special: 'inferno' });
                    }
                }
                return valid; // Return *only* inferno moves
            }

            // Standard Moves
            const isFirstMove = firstMoves.has(`${row},${col},${player}`);
            let moves = pieceTypes[type].move(row, col, board, player, isFirstMove, piece.facing, movesLeft);

            for (let move of moves) {
                const [targetRow, targetCol] = move.pos || [];
                if (targetRow !== undefined && targetCol !== undefined && isDarkVoidSquare(targetRow, targetCol)) {
                    continue;
                }
                if (move.type === 'move') {
                    const [r, c] = move.pos;
                    if (!board[r][c] || board[r][c].player !== player) {
                        if (type !== 'King' || !isCheckAfterMove(row, col, r, c, player)) {
                            if (movesLeft >= move.cost) {
                                valid.push(move);
                            }
                        }
                    }
                } else if (move.type === 'shoot') {
                    const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                    if (targetPiece && targetPiece.player !== player && targetPiece.type === 'Spectre') {
                        continue;
                    }
                    if (movesLeft >= move.cost) {
                        valid.push(move);
                    }
                }
            }

            // Special Moves
            if (type === 'King' && !kingSpecialUsed[player] && movesLeft >= 2) {
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let nr = row + d[0], nc = col + d[1];
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].type === 'Guard' && board[nr][nc].player === player) {
                        valid.push({ type: 'swap', pos: [nr, nc], cost: 2 });
                    }
                }
            }
            if (type === 'Wizard' && wizardTeleportUsed[player] < 2 && movesLeft >= 2) {
                const currentColor = (row + col) % 2;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if ((r + c) % 2 === currentColor && (r !== row || c !== col)) {
                            const occupant = board[r][c];
                            if (occupant && (occupant.player === player || occupant.type !== 'Spectre')) continue;
                            valid.push({ type: 'teleport', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2) {
                const pieceObj = piece;
                if (getNecromancerTeleportCount(pieceObj) < 2) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (r === row && c === col) continue;
                            const occupant = board[r][c];
                            if (occupant && (occupant.player === player || occupant.type !== 'Spectre')) continue;
                            valid.push({ type: 'teleport', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            // UndeadChampion teleport is now handled by button activation only
            if (type === 'Wizard' && !wizardTeleportSwapUsed[player] && movesLeft >= 2 && opponentHasWizards(player)) {
                const color = (row + col) % 2;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c] && board[r][c].type === 'Wizard' && board[r][c].player !== player && (r + c) % 2 === color) {
                            valid.push({ type: 'teleportSwap', pos: [r, c], cost: 2 });
                        }
                    }
                }
            }
            if (type === 'Cavalry' && !cavalryChargeUsed[player] && movesLeft >= 2) {
                for (let d of [[0,1], [0,-1], [1,0], [-1,0]]) {
                    let r = row, c = col;
                    while (true) {
                        r += d[0];
                        c += d[1];
                        if (!isValid(r, c)) break;
                        if (board[r][c]) {
                            if (board[r][c].player !== player) {
                                valid.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                            }
                            break;
                        }
                        valid.push({ type: 'move', pos: [r, c], cost: 2, special: 'charge' });
                    }
                }
            }
            if (type === 'Ogre' && !ogreRageUsed[player] && movesLeft >= 2) {
                const directions = [[0,1], [0,-1], [1,0], [-1,0]];
                for (let dir of directions) {
                    const pattern = buildOgreRagePattern(row, col, dir, player);
                    if (!pattern) continue;
                    valid.push({
                        type: 'move',
                        pos: pattern.dest,
                        cost: 2,
                        special: 'rage',
                        captureArea: pattern.area
                    });
                }
            }
            if (type === 'Archer' && movesLeft >= 2 && archerDiag2ShootUsed[player] < 2) {
                // Add diagonal 2-square shot (no movement)
                const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                for (let d of dirs) {
                    const nr = row + d[0]*2, nc = col + d[1]*2;
                    if (isValid(nr, nc) && board[nr][nc] && board[nr][nc].player !== player) {
                        valid.push({ type: 'shoot', pos: [nr, nc], cost: 2, special: 'archerDiag2' });
                    }
                }
            }
            if (type === 'Ballista') {
                if (!ballistaRangeBoostUsedThisTurn[player] && movesLeft >= 2) {
                    valid.push({ type: 'activate', pos: [row, col], cost: 2, special: 'ballistaRange' });
                }
                if (ballistaDoubleTimeUsed[player] < 2 && movesLeft >= 2) {
                    valid.push(...getBallistaDoubleTimeMoves(row, col));
                }
            }
            // Note: Dragon Inferno is *not* added here because it's activated by a button, not as a passive option.
            // The logic above handles showing Inferno moves *only when infernoMode is true*.
            
            return valid;
        }

        // New function to execute the Inferno AOE capture
        function performInfernoCapture(row, col, player) {
            const opponent = player === 'W' ? 'B' : 'W';
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
            let capturedSomething = false;
            let totalCaptureValue = 0; // Track total capture value for emoji reactions

            for (let d of directions) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc)) {
                    const targetPiece = board[nr][nc];
                    // Dragons cannot capture other Dragons with Inferno
                        if (targetPiece && targetPiece.player === opponent && targetPiece.type !== 'Dragon') {
                        // Undead and Undead Champion are immune to Inferno
                        if (isUndeadType(targetPiece) || isUndeadChampionType(targetPiece)) {
                            const undeadName = isUndeadChampionType(targetPiece) ? 'Undead Champion' : 'Undead';
                            gameLog.push(`Dragon's Inferno could not harm the ${undeadName} at ${formatBoardCoordinates(nr,nc)}.`);
                            continue;
                        }
                        if (targetPiece.type === 'Lich') {
                            gameLog.push(`Dragon's Inferno could not harm the Lich at ${formatBoardCoordinates(nr,nc)}.`);
                            continue;
                        }
                        capturedSomething = true;
                        capturedSquares.push([nr, nc]);
                        recordGraveyardCapture(player, targetPiece);
                        const captureValue = pieceValues[targetPiece.type];
                        totalCaptureValue += captureValue; // Add to total
                        scores[player] += captureValue;
                        registerScoreGain(player, captureValue, true);
                        registerPieceLoss(opponent, targetPiece.type);
                        trackCapture(player); // Track capture for statistics
                        gameLog.push(`${player === 'W' ? 'Player' : 'AI'} captured ${targetPiece.type} (+${captureValue} points) with Dragon's Inferno at ${formatBoardCoordinates(nr,nc)}`);

                        if (targetPiece.type === 'Champion') {
                            championCaptured[targetPiece.player] = true;
                        }
                        if (targetPiece.type === 'King') {
                            endGame(player);
                            return;
                        }
                        cleanupNecromancerTracking(targetPiece);
                        board[nr][nc] = null;
                    }
                }
            }

            if (capturedSomething) {
                checkSupremacy(player);
                updateGameLog();
                updateCapturedPiecesDisplay();
                updateScoreDisplay();

                // Trigger emoji reactions based on who used the special move
                if (player === 'W') {
                    // Player used special move - show AI reaction
                    const scoreDifference = scores['B'] - scores['W']; // AI score - Player score
                    displayAiReactionEmoji(totalCaptureValue, true, scoreDifference);
                } else if (player === 'B') {
                    // AI used special move - show Player reaction and AI celebration
                    displayPlayerReactionEmoji(totalCaptureValue);
                    const scoreDifference = scores['B'] - scores['W']; // AI score - Player score
                    displayAiReactionEmoji(totalCaptureValue, false, scoreDifference);
                }
            }
        }

        function performOgreRageCapture(area, player) {
            if (!area || !area.length) return 0;
            const opponent = player === 'W' ? 'B' : 'W';
            let capturedSomething = false;
            let totalCaptureValue = 0;
            for (const [r, c] of area) {
                if (!isValid(r, c)) continue;
                const targetPiece = board[r][c];
                if (!targetPiece || targetPiece.player === player) continue;
                if (targetPiece.type === 'Lich') {
                    const allowed = resolveLichCaptureAttempt({
                        attackerType: 'Ogre',
                        attackerPlayer: player,
                        targetRow: r,
                        targetCol: c,
                        actionLabel: 'rage'
                    });
                    if (!allowed) continue;
                }
                capturedSomething = true;
                const captureValue = pieceValues[targetPiece.type] || 0;
                totalCaptureValue += captureValue;
                capturedSquares.push([r, c]);
                recordGraveyardCapture(player, targetPiece);
                scores[player] += captureValue;
                registerScoreGain(player, captureValue, true);
                registerPieceLoss(targetPiece.player, targetPiece.type);
                trackCapture(player);
                if (targetPiece.type === 'Champion') {
                    championCaptured[targetPiece.player] = true;
                }
                gameLog.push(`${player === 'W' ? 'Player' : 'AI'} Ogre's Rage captured ${targetPiece.type} at ${formatBoardCoordinates(r,c)}`);
                cleanupNecromancerTracking(targetPiece);
                if (targetPiece.type === 'King') {
                    board[r][c] = null;
                    endGame(player);
                    return totalCaptureValue;
                }
                board[r][c] = null;
            }
            if (capturedSomething) {
                checkSupremacy(player);
                updateGameLog();
                updateCapturedPiecesDisplay();
                updateScoreDisplay();
                if (player === 'W') {
                    const scoreDifference = scores['B'] - scores['W'];
                    displayAiReactionEmoji(totalCaptureValue, true, scoreDifference);
                } else {
                    displayPlayerReactionEmoji(totalCaptureValue);
                    const scoreDifference = scores['B'] - scores['W'];
                    displayAiReactionEmoji(totalCaptureValue, false, scoreDifference);
                }
            }
            return totalCaptureValue;
        }


        function finalizeCaptureEffects(piece, toRow, toCol, captureValue, captured) {
            if (!captured) return null;
            checkSupremacy(piece.player);

            let mercenaryBonusTurn = false;
            let mercenaryFlipNeeded = false;
            if (piece.type === 'Mercenary' && piece.player === currentPlayer &&
                !mercenaryBonusTurnUsed[piece.player].has(piece) &&
                mercenaryBonusTurnCount[piece.player] < 3) {
                mercenaryFlipNeeded = true;
            } else if (piece.type === 'Mercenary' && piece.player === currentPlayer &&
                       mercenaryBonusTurnCount[piece.player] >= 3) {
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} Mercenary has no bonus turns remaining (3/3 used).`);
            }

            updateGameLog();
            updateCapturedPiecesDisplay();

            if (piece.player === 'W') {
                const scoreDifference = scores['B'] - scores['W'];
                displayAiReactionEmoji(captureValue, true, scoreDifference);
            } else if (piece.player === 'B') {
                displayPlayerReactionEmoji(captureValue);
                const scoreDifference = scores['B'] - scores['W'];
                displayAiReactionEmoji(captureValue, false, scoreDifference);
            }

            return { mercenaryBonusTurn, mercenaryFlipNeeded, mercenaryPiece: piece, mercenaryPos: { row: toRow, col: toCol } };
        }

        function attemptUndeadCapture(attackerPiece, targetPiece, fromRow, fromCol, toRow, toCol, success) {
            if (!attackerPiece || !(isUndeadType(attackerPiece) || isUndeadChampionType(attackerPiece)) || !targetPiece || targetPiece.player === attackerPiece.player) {
                return null;
            }
            if (!success) {
                const actorLabel = attackerPiece.player === 'W' ? 'Player' : getOpponentDisplayName();
                const pieceName = isUndeadChampionType(attackerPiece) ? 'Undead Champion' : 'Undead';
                gameLog.push(`${actorLabel} ${pieceName} failed to capture ${targetPiece.type} at ${formatBoardCoordinates(toRow,toCol)} and stayed in place.`);
                updateGameLog();
                return { captureFailed: true };
            }
            return null;
        }

        function handleUndeadDefense(attackerPiece, undeadPiece, fromRow, fromCol, targetRow, targetCol, success) {
            if (!attackerPiece || !undeadPiece || !(isUndeadType(undeadPiece) || isUndeadChampionType(undeadPiece))) return null;
            const actorLabel = attackerPiece.player === 'W' ? 'Player' : getOpponentDisplayName();
            const undeadName = isUndeadChampionType(undeadPiece) ? 'Undead Champion' : 'Undead';
            if (!success) {
                const captureValue = pieceValues[attackerPiece.type] || 0;
                recordUndeadCapture(attackerPiece, undeadPiece.player, fromRow, fromCol, captureValue);
                cleanupNecromancerTracking(attackerPiece);
                board[fromRow][fromCol] = null;
                gameLog.push(`${actorLabel}'s ${attackerPiece.type} failed to slay the ${undeadName} and was destroyed (+${captureValue} points).`);
                updateGameLog();
                if (attackerPiece.type === 'King') {
                    gameOver = true;
                    const endGameDelay = 3000 + Math.random() * 2000;
                    setTimeout(() => {
                        endGame(undeadPiece.player);
                    }, endGameDelay);
                }
                return { attackerRemoved: true };
            }
            // Successful attack deducts 1 life from undead
            const currentLives = typeof undeadPiece.lives === 'number' ? undeadPiece.lives : (undeadPiece.maxLives || 1);
            undeadPiece.lives = currentLives - 1;

            if (undeadPiece.lives <= 0) {
                // Undead destroyed - all lives lost
                gameLog.push(`${actorLabel} shattered the ${undeadName}!`);
                updateGameLog();
                return { undeadDestroyed: true };
            } else {
                // Undead damaged but still has lives remaining
                const livesText = undeadPiece.lives === 1 ? '1 life' : `${undeadPiece.lives} lives`;
                gameLog.push(`${actorLabel} hit the ${undeadName}! (${livesText} remaining)`);
                updateGameLog();
                return { undeadDamaged: true };
            }
        }

        function recordUndeadCapture(attackerPiece, owner, row, col, captureValue) {
            if (!attackerPiece) return;
            capturedSquares.push([row, col]);
            recordGraveyardCapture(owner, attackerPiece);
            scores[owner] += captureValue;
            registerScoreGain(owner, captureValue, true);
            registerPieceLoss(attackerPiece.player, attackerPiece.type);
            trackCapture(owner);
            checkSupremacy(owner);
            updateCapturedPiecesDisplay();
            updateScoreDisplay();
        }

        function movePiece(fromRow, fromCol, toRow, toCol, jump) {
            const piece = board[fromRow][fromCol];
            const opponent = getOpponent(piece.player);
            let captured = false;
            let captureValue = 0; // Track capture value for emoji reactions
            const opponentBackRow = piece.player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            const ownBackRow = piece.player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;

            if (piece.type === 'Champion' && fromRow === opponentBackRow) {
                championsOnBackRow[piece.player] = championsOnBackRow[piece.player].filter(pos => pos[0] !== fromRow || pos[1] !== fromCol);
            }

            if (jump && board[jump[0]][jump[1]] && board[jump[0]][jump[1]].player !== piece.player) {
                const capturedPiece = board[jump[0]][jump[1]];
                if (capturedPiece.type === 'Zombie') {
                    const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, jump[0], jump[1], { jumpCapture: true });
                    if (!result.success) {
                        return;
                    }
                    captured = true;
                } else {
                    if (capturedPiece.type === 'Lich') {
                        const allowed = resolveLichCaptureAttempt({
                            attackerType: piece.type,
                            attackerPlayer: piece.player,
                            targetRow: jump[0],
                            targetCol: jump[1],
                            actionLabel: 'capture'
                        });
                        if (!allowed) {
                            return null;
                        }
                    }
                    capturedSquares.push([jump[0], jump[1]]);
                    recordGraveyardCapture(piece.player, capturedPiece);
                    captureValue = pieceValues[capturedPiece.type];
                    scores[piece.player] += captureValue;
                    registerScoreGain(piece.player, captureValue, true);
                    registerPieceLoss(opponent, capturedPiece.type);
                    trackCapture(piece.player); // Track capture for statistics
                    gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} captured ${capturedPiece.type} (+${captureValue} points) with ${piece.type} at ${formatBoardCoordinates(jump[0],jump[1])}`);
                    cleanupNecromancerTracking(capturedPiece);
                    board[jump[0]][jump[1]] = null;
                    if (capturedPiece.type === 'King') {
                        // Complete the move first
                        board[toRow][toCol] = piece;
                        board[fromRow][fromCol] = null;
                        firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);
                        renderBoard();
                        updateScoreDisplay();
                        updateCapturedPiecesDisplay();
                        updateGameLog();
                        // Immediately set gameOver flag to prevent any further actions
                        gameOver = true;
                        // Add 3-5 second delay before showing end game popup to allow final move animation to complete
                        const endGameDelay = 3000 + Math.random() * 2000; // Random delay between 3000-5000ms
                        setTimeout(() => {
                            endGame(piece.player);
                        }, endGameDelay);
                        return;
                    }
                    captured = true;
                }
            }

            if (board[toRow][toCol]) {
                // Archers and Ballistas cannot capture by landing - they can only shoot
                if (piece.type === 'Archer' || piece.type === 'Ballista') {
                    gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} ${piece.type} cannot capture by landing - must shoot instead`);
                    // Don't allow the move - this shouldn't happen but just in case
                } else {
                    const capturedPiece = board[toRow][toCol];
                    if (capturedPiece.type === 'Zombie') {
                        const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, toRow, toCol);
                        if (!result.success) {
                            return;
                        }
                        captured = true;
                    } else {
                        if (capturedPiece.type === 'Lich') {
                            const allowed = resolveLichCaptureAttempt({
                                attackerType: piece.type,
                                attackerPlayer: piece.player,
                                targetRow: toRow,
                                targetCol: toCol,
                                actionLabel: 'capture'
                            });
                            if (!allowed) {
                                return null;
                            }
                        }
                    capturedSquares.push([toRow, toCol]);
                    recordGraveyardCapture(piece.player, capturedPiece);
                        captureValue = pieceValues[capturedPiece.type];
                        scores[piece.player] += captureValue;
                        registerScoreGain(piece.player, captureValue, true);
                        registerPieceLoss(opponent, capturedPiece.type);
                        trackCapture(piece.player); // Track capture for statistics
                        gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} captured ${capturedPiece.type} (+${captureValue} points) with ${piece.type} at ${formatBoardCoordinates(toRow,toCol)}`);
                        if (capturedPiece.type === 'Champion') {
                            championCaptured[capturedPiece.player] = true;
                        }
                        cleanupNecromancerTracking(capturedPiece);
                        if (capturedPiece.type === 'King') {
                            // Complete the move first
                            board[toRow][toCol] = piece;
                            board[fromRow][fromCol] = null;
                            firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);
                            renderBoard();
                            updateScoreDisplay();
                            updateCapturedPiecesDisplay();
                            updateGameLog();
                            // Immediately set gameOver flag to prevent any further actions
                            gameOver = true;
                            // Add 3-5 second delay before showing end game popup to allow final move animation to complete
                            const endGameDelay = 3000 + Math.random() * 2000; // Random delay between 3000-5000ms
                            setTimeout(() => {
                                endGame(piece.player);
                            }, endGameDelay);
                            return;
                        }
                        captured = true;
                    }
                }
            } else {
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} moved ${piece.type} from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(toRow,toCol)}`);
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            firstMoves.delete(`${fromRow},${fromCol},${piece.player}`);

            // Play move sound effect
            const moveSound = document.getElementById('move-sound');
            if (moveSound) {
                moveSound.currentTime = 0; // Reset to start
                moveSound.play().catch(e => console.log('Sound play failed:', e));
            }

            // If a Ballista moved and had an active range boost, it persists for the turn (no change needed)

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[piece.player].push([toRow, toCol]);
            }

            if ((piece.type === 'Infantry' || piece.type === 'Champion' || piece.type === 'King') && toRow === opponentBackRow && !captured) {
                reinforce(piece.player, toRow, toCol);
            }

            checkSupremacy(piece.player);
            return finalizeCaptureEffects(piece, toRow, toCol, captureValue, captured);
        }

        function handleMercenaryCoinFlip(player, piece, row, col, callback) {
            const playerLabel = player === 'W' ? 'Player' : 'AI';
            const automated = player === 'B'; // Automated for AI

            performCoinToss(
                'Mercenary Bonus Turn',
                `${playerLabel} mercenary attempts bonus turn`,
                (success) => {
                    if (success) {
                        // Grant bonus turn
                        mercenaryBonusTurnUsed[player].add(piece);
                        mercenaryBonusTurnCount[player]++;
                        // Remove the mercenary from movedPieces so it can move again
                        movedPieces.delete(`${row},${col}`);
                        // Set bonus turn state to restrict selection to this mercenary only
                        mercenaryBonusTurnActive = true;
                        mercenaryBonusTurnPiece = { row, col };
                        setMercenaryHighlight({ row, col });
                        const remaining = 3 - mercenaryBonusTurnCount[player];
                        gameLog.push(`${playerLabel} Mercenary won the coin flip! Bonus turn granted - the mercenary can move again without cost. (${remaining} bonus turns remaining)`);

                        updateGameLog();
                        callback(true); // Bonus turn granted
                    } else {
                        gameLog.push(`${playerLabel} Mercenary lost the coin flip. No bonus turn.`);
                        updateGameLog();
                        callback(false); // No bonus turn
                    }
                },
                automated,
                false  // showOverlay
            );
        }

        function shootPiece(fromRow, fromCol, toRow, toCol, abilityName = null) {
            const piece = board[fromRow][fromCol];
            if (!piece) return;
            let captureValue = 0; // Track capture value for emoji reactions
            const abilityText = abilityName ? ` using ${abilityName}` : '';
            if (piece.type === 'Fusilier') {
                fusilierShotThisTurn[piece.player].add(piece);
                fusilierShotLastTurn[piece.player].delete(piece);
                if (fusilierCrackShotActive === piece) {
                    fusilierCrackShotActive = null;
                }
            }
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.type === 'Spectre') {
                const actorLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
                gameLog.push(`${actorLabel} cannot shoot Spectres. The attack fizzled.`);
                updateGameLog();
                return;
            }
            // Handle shooting undead pieces - requires coin flip
            if (targetPiece && (isUndeadType(targetPiece) || isUndeadChampionType(targetPiece))) {
                const actorLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
                const undeadName = isUndeadChampionType(targetPiece) ? 'Undead Champion' : 'Undead';
                const success = randomCoinFlip();

                if (!success) {
                    // Failed to hit undead - shooter is destroyed
                    const captureValue = pieceValues[piece.type] || 0;
                    recordUndeadCapture(piece, targetPiece.player, fromRow, fromCol, captureValue);
                    cleanupNecromancerTracking(piece);
                    board[fromRow][fromCol] = null;
                    gameLog.push(`${actorLabel}'s ${piece.type} failed to hit the ${undeadName}${abilityText} and was destroyed (+${captureValue} points).`);
                    updateGameLog();
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();

                    if (piece.type === 'King') {
                        gameOver = true;
                        const endGameDelay = 3000 + Math.random() * 2000;
                        setTimeout(() => {
                            endGame(targetPiece.player);
                        }, endGameDelay);
                    }
                    return;
                }

                // Successful hit - deduct 1 life from undead
                const currentLives = typeof targetPiece.lives === 'number' ? targetPiece.lives : (targetPiece.maxLives || 1);
                targetPiece.lives = currentLives - 1;

                if (targetPiece.lives <= 0) {
                    // Undead destroyed
            capturedSquares.push([toRow, toCol]);
            recordGraveyardCapture(piece.player, targetPiece);
                    const captureValue = pieceValues[targetPiece.type];
                    scores[piece.player] += captureValue;
                    registerScoreGain(piece.player, captureValue, true);
                    registerPieceLoss(getOpponent(piece.player), targetPiece.type);
                    trackCapture(piece.player);
                    gameLog.push(`${actorLabel} shattered the ${undeadName}${abilityText}! (+${captureValue} points)`);
                    cleanupNecromancerTracking(targetPiece);
                    board[toRow][toCol] = null;
                    checkSupremacy(piece.player);
                } else {
                    // Undead damaged but alive
                    const livesText = targetPiece.lives === 1 ? '1 life' : `${targetPiece.lives} lives`;
                    gameLog.push(`${actorLabel} hit the ${undeadName}${abilityText}! (${livesText} remaining)`);
                }

                updateGameLog();
                updateCapturedPiecesDisplay();
                renderBoard();
                return;
            }
            if (targetPiece && targetPiece.type === 'Zombie') {
                const result = handleZombieCaptureAttempt(piece, fromRow, fromCol, toRow, toCol, { ranged: true });
                if (result.handled) {
                    if (result.success) {
                        renderBoard();
                        updateScoreDisplay();
                        updateCapturedPiecesDisplay();
                        updateGameLog();
                    }
                    return;
                }
            }
            if (targetPiece && targetPiece.type === 'Huntsman') {
                const attackerLabel = piece.player === 'W' ? 'Player' : getOpponentDisplayName();
                const success = randomCoinFlip();
                if (!success) {
                    gameLog.push(`${attackerLabel} failed to shoot the Huntsman at ${formatBoardCoordinates(toRow,toCol)}.`);
                    updateGameLog();
                    return;
                }
                gameLog.push(`${attackerLabel} won the Huntsman defense coin flip at ${formatBoardCoordinates(toRow,toCol)}.`);
                updateGameLog();
            }
            if (targetPiece && targetPiece.type === 'Lich') {
                const allowed = resolveLichCaptureAttempt({
                    attackerType: piece.type,
                    attackerPlayer: piece.player,
                    targetRow: toRow,
                    targetCol: toCol,
                    actionLabel: 'shoot'
                });
                if (!allowed) {
                    return;
                }
            }
            if (targetPiece) {
                capturedSquares.push([toRow, toCol]);
                recordGraveyardCapture(piece.player, targetPiece);
                captureValue = pieceValues[targetPiece.type];
                scores[piece.player] += captureValue;
                registerScoreGain(piece.player, captureValue);
                registerPieceLoss(getOpponent(piece.player), targetPiece.type);
                trackCapture(piece.player); // Track capture for statistics
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} shot ${targetPiece.type} (+${captureValue} points) with ${piece.type}${abilityText} at ${formatBoardCoordinates(toRow,toCol)}`);
                if (targetPiece.type === 'Champion') {
                    championCaptured[targetPiece.player] = true;
                }
                cleanupNecromancerTracking(targetPiece);
                if (targetPiece.type === 'King') {
                    // Immediately set gameOver flag to prevent any further actions
                    gameOver = true;
                    board[toRow][toCol] = null;
                    renderBoard();
                    updateScoreDisplay();
                    updateCapturedPiecesDisplay();
                    updateGameLog();
                    // Add 3-5 second delay before showing end game popup to allow final move animation to complete
                    const endGameDelay = 3000 + Math.random() * 2000; // Random delay between 3000-5000ms
                    setTimeout(() => {
                        endGame(piece.player);
                    }, endGameDelay);
                    return;
                }
                board[toRow][toCol] = null;
                checkSupremacy(piece.player);
            }
            updateGameLog();
            updateCapturedPiecesDisplay();

            // Trigger emoji reactions based on who made the shot
            if (piece.player === 'W') {
                // Player made a shot - show AI reaction
                const scoreDifference = scores['B'] - scores['W']; // AI score - Player score
                displayAiReactionEmoji(captureValue, true, scoreDifference);
            } else if (piece.player === 'B') {
                // AI made a shot - show Player reaction and AI celebration
                displayPlayerReactionEmoji(captureValue);
                const scoreDifference = scores['B'] - scores['W']; // AI score - Player score
                displayAiReactionEmoji(captureValue, false, scoreDifference);
            }
        }

        function applySpellCapture(attackerPlayer, targetRow, targetCol, options = {}) {
            const targetPiece = board[targetRow]?.[targetCol];
            if (!targetPiece) return false;
            const attackerType = options.attackerType || null;
            const ability = options.ability || null;
            if (targetPiece.type === 'Lich') {
                if (ability === 'Energy Blast' || ability === 'Sacrifice') {
                    gameLog.push(`Liches are immune to ${ability}.`);
                    updateGameLog();
                    return false;
                }
                const allowed = resolveLichCaptureAttempt({
                    attackerType,
                    attackerPlayer,
                    targetRow,
                    targetCol,
                    actionLabel: ability || 'capture'
                });
                if (!allowed) {
                    return false;
                }
            }

        capturedSquares.push([targetRow, targetCol]);
        recordGraveyardCapture(attackerPlayer, targetPiece);
            const captureValue = pieceValues[targetPiece.type] || 0;
            scores[attackerPlayer] += captureValue;
            registerScoreGain(attackerPlayer, captureValue, true);
            registerPieceLoss(targetPiece.player, targetPiece.type);
            trackCapture(attackerPlayer);
            if (options.logMessage) {
                gameLog.push(options.logMessage);
            }
            if (targetPiece.type === 'Champion') {
                championCaptured[targetPiece.player] = true;
                championsOnBackRow[targetPiece.player] = championsOnBackRow[targetPiece.player].filter(([r, c]) => !(r === targetRow && c === targetCol));
            }
            cleanupNecromancerTracking(targetPiece);
            board[targetRow][targetCol] = null;
            if (targetPiece.type === 'King') {
                const victoryReason = options.victoryReason || options.ability || null;
                endGame(attackerPlayer, victoryReason);
            }
            return true;
        }

        function applyBarrageTargets(piece, targets) {
            if (!targets.length) return false;
            const attackerPlayer = piece.player;
            const playerLabel = attackerPlayer === 'W' ? 'Player' : getOpponentDisplayName();
            const targetSummary = targets.map(t => formatBoardCoordinates(t.row, t.col)).join(', ');
            gameLog.push(`${playerLabel} unleashed Barrage on ${targetSummary}.`);
            let captureOccurred = false;
            for (const target of targets) {
                const coordLabel = formatBoardCoordinates(target.row, target.col);
                const occupant = board[target.row]?.[target.col];
                if (!occupant) {
                    gameLog.push(`${playerLabel}'s Barrage missed at ${coordLabel}.`);
                    continue;
                }
                if (occupant.player === attackerPlayer) {
                    const survived = randomCoinFlip();
                    if (survived) {
                        gameLog.push(`${playerLabel}'s Barrage spared ${occupant.type} at ${coordLabel}.`);
                    } else {
                        capturedSquares.push([target.row, target.col]);
                        board[target.row][target.col] = null;
                        cleanupNecromancerTracking(occupant);
                        if (occupant.type === 'Champion') {
                            championCaptured[occupant.player] = true;
                            championsOnBackRow[occupant.player] = championsOnBackRow[occupant.player].filter(([r, c]) => !(r === target.row && c === target.col));
                        }
                        gameLog.push(`${playerLabel}'s Barrage destroyed friendly ${occupant.type} at ${coordLabel}.`);
                        captureOccurred = true;
                        if (occupant.type === 'King') {
                            endGame(getOpponent(attackerPlayer), 'Barrage Friendly Fire');
                            return true;
                        }
                    }
                    continue;
                }
                const captureMessage = `${playerLabel} Barrage struck ${occupant.type} at ${coordLabel}.`;
                const captured = applySpellCapture(attackerPlayer, target.row, target.col, {
                    ability: 'Barrage',
                    logMessage: captureMessage
                });
                if (captured) {
                    captureOccurred = true;
                } else {
                    gameLog.push(`${playerLabel}'s Barrage failed to capture ${occupant.type} at ${coordLabel}.`);
                }
            }
            return captureOccurred;
        }

        function turnPiece(row, col, newFacing) {
            const piece = board[row][col];
            if (piece && turnablePieces.includes(piece.type)) {
                piece.facing = newFacing;
                gameLog.push(`${piece.player === 'W' ? 'Player' : 'AI'} turned ${piece.type} at ${formatBoardCoordinates(row,col)} to face ${newFacing} (${facingIcons[newFacing]})`);
            }
        }

        function reinforce(player, row, col) {
            reinforcementPending = { player, row, col };
            let availablePieces = capturedPieces[player].map(p => p.type);
            const piece = board[row][col];
            // King and Champion can bring extra reinforcements in advanced+ variants (36s and above)
            if (piece.type === 'Champion' || piece.type === 'King') {
                if (gameVariant === '36s' || gameVariant === '36s-expert' || gameVariant === '36s-elite' || gameVariant === '36s-supreme') {
                    availablePieces.push(...Array(2).fill('Ballista'), ...Array(2).fill('Elephantry'), ...Array(2).fill('Mercenary'));
                }
            }
            if (availablePieces.length === 0) {
                reinforcementPending = null;
                return;
            }
            if (player === 'W') {
                const modal = document.getElementById('reinforce-modal');
                const select = document.getElementById('reinforce-select');
                select.innerHTML = availablePieces.map(p => `<option value="${p}">${p}</option>`).join('');
                modal.style.display = 'block';
            } else {
                // AI prioritizes high-value pieces for reinforcement
                const sortedPieces = availablePieces.sort((a, b) => {
                    return (aiPieceValues[b] || basePieceValues[b] || 0) - (aiPieceValues[a] || basePieceValues[a] || 0);
                });
                // Take the highest value piece (or occasionally second-highest for variety)
                const pieceType = Math.random() < 0.8 ? sortedPieces[0] : (sortedPieces[1] || sortedPieces[0]);
                confirmReinforcement(pieceType);
            }
        }

        function confirmReinforcement(pieceType) {
            if (!reinforcementPending) return;
            const { player, row, col } = reinforcementPending;
            const backRow = player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;
            let relentlessTriggered = false;
            for (let c = 0; c < COLS; c++) {
                if (!board[backRow][c]) {
                    const type = pieceType || document.getElementById('reinforce-select').value;
                    board[backRow][c] = {
                        type,
                        player,
                        facing: turnablePieces.includes(type) ? (player === 'W' ? 'U' : 'D') : null
                    };
                    gameLog.push(`${player === 'W' ? 'Player' : 'AI'} reinforced ${type} at ${formatBoardCoordinates(backRow,c)}`);
                    decrementGraveyardCount();
                    relentlessTriggered = registerReinforcement(player, type);
                    break;
                }
            }
            document.getElementById('reinforce-modal').style.display = 'none';
            reinforcementPending = null;
            if (relentlessTriggered) {
                return;
            }
            renderBoard();
            updateStatus();
            updateGameLog();
            checkGameOver();
            // After reinforcement, explicitly check if turn should end
            if (currentPlayer === 'W') {
                if (movesLeft <= 0) {
                    triggerAiTurn();
                } else {
                    ensureAITurnIfNeeded();
                }
            }
        }

        function cloneBoard(board) {
            return board.map(row => row.map(cell => cell ? { ...cell } : null));
        }

        /**
         * New aggressive evaluation function.
         */
        function evaluateBoard(board, player) {
            let score = 0;
            const opponent = player === 'W' ? 'B' : 'W';
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            const playerBackRow = player === 'W' ? (gameVariant === 'ccb' ? 7 : 9) : 0;
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            const BACKROW_SUMMON_BONUSES = {
                Necromancer: 9, // Increased from 6 to encourage summoning
                Zombie: 7, // Increased from 5
                Fusilier: 7, // Increased from 5
                Pistolier: 7, // Increased from 5
                Lich: 11 // Increased from 8
            };

            // Use AI profile weights (if AI is playing, adjust weights based on profile)
            const profile = (player === 'B' && currentAiProfile) ? currentAiProfile : null;
            const MOBILITY_WEIGHT = profile ? (0.45 * profile.mobilityWeight) : 0.45;
            const CENTER_WEIGHT = profile ? (0.25 * profile.centerWeight) : 0.25;
            const THREAT_MULTIPLIER = profile ? profile.threatWeight : 1.0;
            
            let playerPieceValue = 0;
            let opponentPieceValue = 0;
            let playerThreats = 0;
            let opponentThreats = 0;
            let playerMobility = 0;
            let opponentMobility = 0;
            let playerCenterControl = 0;
            let opponentCenterControl = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece) continue;

                    const value = aiPieceValues[piece.type];
                    const distToCenter = Math.hypot(r - centerRow, c - centerCol);

                    if (piece.player === player) {
                        playerPieceValue += value;
                        playerCenterControl -= distToCenter;
                        if ((piece.type === 'Infantry' || piece.type === 'Champion') && r === opponentBackRow) {
                            playerPieceValue += 5; // Promotion/reinforcement bonus
                        }

                        // Add advancement bonus for pieces that can trigger reinforcements
                        if (piece.type === 'Infantry' || piece.type === 'Champion' || piece.type === 'King') {
                            const distanceToBackRow = Math.abs(r - opponentBackRow);
                            const maxDistance = player === 'W' ? ROWS - 1 : (gameVariant === 'ccb' ? 7 : 9);
                            // Significantly increased bonus to encourage AI to reach back row for reinforcements
                            const advancementBonus = (1 - distanceToBackRow / maxDistance) * 8; // Increased from 3 to 8
                            playerPieceValue += advancementBonus;
                            // Extra bonus when at back row (reinforcement opportunity)
                            if (r === opponentBackRow) {
                                playerPieceValue += 10; // Strong incentive for triggering reinforcements
                            }
                        }

                        if (r === playerBackRow && BACKROW_SUMMON_BONUSES[piece.type]) {
                            playerPieceValue += BACKROW_SUMMON_BONUSES[piece.type];
                        }

                        const moves = pieceTypes[piece.type].move(r, c, board, player, false, piece.facing, 3) || [];
                        playerMobility += moves.length;
                        for (const move of moves) {
                            if (move.type === 'move' || move.type === 'shoot') {
                                const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                                if (targetPiece && targetPiece.player === opponent) {
                                    // KING TARGETING: Massively increase threat value when threatening the King
                                    if (targetPiece.type === 'King') {
                                        playerThreats += aiPieceValues[targetPiece.type] * 50.0 * THREAT_MULTIPLIER; // Huge bonus for threatening King
                                    } else {
                                        playerThreats += aiPieceValues[targetPiece.type] * 0.85 * THREAT_MULTIPLIER;
                                    }
                                }
                            }
                        }
                    } else {
                        opponentPieceValue += value;
                        opponentCenterControl -= distToCenter;
                        if (r === opponentBackRow && BACKROW_SUMMON_BONUSES[piece.type]) {
                            opponentPieceValue += BACKROW_SUMMON_BONUSES[piece.type];
                        }

                        const moves = pieceTypes[piece.type].move(r, c, board, opponent, false, piece.facing, 3) || [];
                        opponentMobility += moves.length;
                        for (const move of moves) {
                            if (move.type === 'move' || move.type === 'shoot') {
                                const targetPiece = board[move.pos[0]]?.[move.pos[1]];
                                if (targetPiece && targetPiece.player === player) {
                                    // KING TARGETING: Massively penalize if opponent is threatening our King
                                    if (targetPiece.type === 'King') {
                                        opponentThreats += aiPieceValues[targetPiece.type] * 50.0 * THREAT_MULTIPLIER; // Huge penalty for opponent threatening our King
                                    } else {
                                        opponentThreats += aiPieceValues[targetPiece.type] * 0.85 * THREAT_MULTIPLIER;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            score = (playerPieceValue - opponentPieceValue)
                  + (playerThreats - opponentThreats)
                  + MOBILITY_WEIGHT * (playerMobility - opponentMobility)
                  + CENTER_WEIGHT * (playerCenterControl - opponentCenterControl);
            
            return score;
        }

        function simulateMove(board, fromRow, fromCol, toRow, toCol, jump, player, capturedPieces, scores, championsOnBackRow) {
            const newBoard = cloneBoard(board);
            const piece = newBoard[fromRow][fromCol];
            let captured = false;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);

            if (piece.type === 'Champion' && fromRow === opponentBackRow) {
                championsOnBackRow[player] = championsOnBackRow[player].filter(pos => pos[0] !== fromRow || pos[1] !== fromCol);
            }

            if (jump && newBoard[jump[0]][jump[1]] && newBoard[jump[0]][jump[1]].player !== player) {
                capturedPieces[player].push(newBoard[jump[0]][jump[1]]);
                scores[player] += aiPieceValues[newBoard[jump[0]][jump[1]].type];
                newBoard[jump[0]][jump[1]] = null;
                captured = true;
            }
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                captured = true;
            }
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[player].push([toRow, toCol]);
            }

            return { board: newBoard, captured };
        }

        function simulateShoot(board, fromRow, fromCol, toRow, toCol, player, capturedPieces, scores) {
            const newBoard = cloneBoard(board);
            if (newBoard[toRow][toCol]) {
                if (newBoard[toRow][toCol].type === 'Spectre') {
                    return newBoard;
                }
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                newBoard[toRow][toCol] = null;
            }
            return newBoard;
        }

        function simulateTurn(board, row, col, newFacing) {
            const newBoard = cloneBoard(board);
            newBoard[row][col].facing = newFacing;
            return newBoard;
        }

        /**
         * Find moves for low-value pieces (Infantry, Archer, etc.) to use final move point
         */
        function findLowValuePieceMove(player, movedPieces) {
            const LOW_VALUE_PIECES = ['Infantry', 'Archer', 'Zombie', 'Pistolier', 'Cavalry'];
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            let best = null;
            let bestScore = -Infinity;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || movedPieces.has(`${r},${c}`)) continue;

                    // Prioritize low-value pieces
                    if (!LOW_VALUE_PIECES.includes(piece.type)) continue;

                    const moves = pieceTypes[piece.type].move(r, c, board, player, false, piece.facing, 1);
                    if (!moves) continue;

                    for (const move of moves) {
                        if (move.cost > 1) continue; // Only 1-cost moves
                        const [mr, mc] = move.pos;
                        const targetPiece = board[mr]?.[mc];

                        let score = 0;

                        // Prioritize captures even for low-value pieces
                        if (targetPiece && targetPiece.player !== player) {
                            score += aiPieceValues[targetPiece.type] * 10;

                            // Extra bonus for adjacent captures
                            const distance = Math.abs(mr - r) + Math.abs(mc - c);
                            if (distance === 1) {
                                score += 50; // High priority for using last move on adjacent capture
                            }
                        } else {
                            // For non-captures, prefer moving towards center or forward
                            const distToCenter = Math.hypot(mr - centerRow, mc - centerCol);
                            score -= distToCenter * 0.1;

                            // Encourage forward movement (towards opponent's side)
                            if (player === 'B' && mr > r) score += 2; // AI moves down
                            if (player === 'W' && mr < r) score += 2; // Player moves up
                        }

                        // Slightly prefer Infantry to use last point
                        if (piece.type === 'Infantry') score += 1;

                        if (score > bestScore) {
                            bestScore = score;
                            best = { ...move, from: [r, c], pieceType: piece.type };
                        }
                    }
                }
            }
            return best;
        }

        function findSimpleAIAction(player, movesLeft, movedPieces) {
            let best = null;
            let bestScore = -Infinity;
            const centerRow = (ROWS - 1) / 2;
            const centerCol = (COLS - 1) / 2;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.player !== player || movedPieces.has(`${r},${c}`)) continue;
                    const moves = getValidMoves(r, c) || [];
                    for (let move of moves) {
                        if (move.cost > movesLeft) continue;
                        const [mr, mc] = move.pos;
                        const targetPiece = board[mr]?.[mc];
                        const moveCost = typeof move.cost === 'number' ? move.cost : 1;
                        let score = moveCost * 0.45; // encourage spending available points
                        if (targetPiece && targetPiece.player !== player) {
                            const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                            score += aiPieceValues[targetPiece.type] * 2.4 * captureBonus; // heavily favour captures (adjusted by AI profile)
                            // Add proximity bonus for close attacks
                            const distance = Math.abs(mr - r) + Math.abs(mc - c);
                            if (distance === 1) {
                                // CRITICAL PRIORITY: Adjacent pieces are immediate threats - heavily prioritize capturing them
                                const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                                score += aiPieceValues[targetPiece.type] * 7.56 * captureBonus; // 756% bonus for adjacent captures (increased by 80% from original 4.2, adjusted by AI profile)
                                // Extra flat bonus for ANY adjacent capture to encourage eliminating all immediate threats
                                score += 15; // Flat bonus to encourage capturing even low-value adjacent pieces
                            } else if (distance <= 2) {
                                score += aiPieceValues[targetPiece.type] * 0.5; // 50% bonus for close attacks in simple AI
                            }
                        } else if (move.special) {
                            let specialBonus = 2.0; // Base special move bonus
                            if (aiDifficulty === 'Hard') specialBonus = 5.85; // +30% difficulty (4.5  5.85)
                            else if (aiDifficulty === 'Medium') specialBonus = 4.2; // +20% difficulty (3.5  4.2)
                            else if (aiDifficulty === 'Easy') specialBonus = 2.2; // Slightly higher for Easy (+10%)

                            // Encourage summoning and high-impact specials
                            if (move.type === 'summon') {
                                specialBonus += 1.5;
                            }
                            if (move.special === 'darkVoid') {
                                specialBonus += 1.1;
                            }

                            // Apply AI profile modifier to special ability usage
                            if (currentAiProfile) {
                                specialBonus *= currentAiProfile.specialAbilityBonus;
                            }
                            score += specialBonus;
                        } else {
                            score -= 0.5; // penalise idle repositioning
                        }
                        if (move.type === 'turn') score -= 5; // Heavily penalize standalone turns to keep AI moving
                        if (move.type === 'move' && !targetPiece && !move.special) {
                            score -= 0.2 * Math.max(0, movesLeft - moveCost); // don't leave points unused
                        }
                        const distToCenter = Math.hypot(mr - centerRow, mc - centerCol);
                        score -= distToCenter * 0.05;
                        if (score > bestScore) {
                            bestScore = score;
                            best = { ...move, from: [r, c], pieceType: piece.type };
                        }
                    }
                }
            }
            return best;
        }

        // New AI simulation function for Inferno AOE
        function simulateInfernoCapture(board, row, col, player, capturedPieces, scores) {
            const newBoard = cloneBoard(board);
            const opponent = player === 'W' ? 'B' : 'W';
            const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];

            for (let d of directions) {
                let nr = row + d[0], nc = col + d[1];
                if (isValid(nr, nc)) {
                    const targetPiece = newBoard[nr][nc];
                    if (targetPiece && targetPiece.player === opponent) {
                        capturedPieces[player].push(targetPiece);
                        scores[player] += aiPieceValues[targetPiece.type];
                        newBoard[nr][nc] = null;
                    }
                }
            }
            return newBoard;
        }

        function simulateOgreRageCapture(board, captureArea, player, capturedPieces, scores) {
            if (!captureArea || !captureArea.length) return board;
            const newBoard = cloneBoard(board);
            for (const [r, c] of captureArea) {
                if (!isValid(r, c)) continue;
                const targetPiece = newBoard[r][c];
                if (!targetPiece || targetPiece.player === player) continue;
                capturedPieces[player].push(targetPiece);
                scores[player] += aiPieceValues[targetPiece.type] || 0;
                newBoard[r][c] = null;
            }
            return newBoard;
        }


        function simulateTurnAndMove(board, row, col, newFacing, toRow, toCol, jump, player, capturedPieces, scores, championsOnBackRow) {
            let newBoard = cloneBoard(board);
            newBoard[row][col].facing = newFacing;
            const piece = newBoard[row][col];
            let captured = false;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);

            if (piece.type === 'Champion' && row === opponentBackRow) {
                championsOnBackRow[player] = championsOnBackRow[player].filter(pos => pos[0] !== row || pos[1] !== col);
            }

            if (jump && newBoard[jump[0]][jump[1]] && newBoard[jump[0]][jump[1]].player !== player) {
                capturedPieces[player].push(newBoard[jump[0]][jump[1]]);
                scores[player] += aiPieceValues[newBoard[jump[0]][jump[1]].type];
                newBoard[jump[0]][jump[1]] = null;
                captured = true;
            }
            if (newBoard[toRow][toCol]) {
                capturedPieces[player].push(newBoard[toRow][toCol]);
                scores[player] += aiPieceValues[newBoard[toRow][toCol].type];
                captured = true;
            }
            newBoard[toRow][toCol] = piece;
            newBoard[row][col] = null;

            if (piece.type === 'Champion' && toRow === opponentBackRow) {
                championsOnBackRow[player].push([toRow, toCol]);
            }

            return { board: newBoard, captured };
        }

        function minimax(board, depth, isMaximizing, player, movesLeft, movedPieces, capturedPieces, scores, alpha, beta, championsOnBackRow) {
            const leafScore = () => {
                const leftover = Math.max(0, movesLeft);
                return evaluateBoard(board, player) - AI_LEFTOVER_PENALTY * leftover;
            };

            if (aiTimeExpired()) {
                return { score: leafScore(), sequence: [], sequenceCost: 0 };
            }

            if (depth === 0 || movesLeft <= 0) {
                return { score: leafScore(), sequence: [], sequenceCost: 0 };
            }
            const opponent = player === 'W' ? 'B' : 'W';
            let bestAction = null;
            if (isMaximizing) {
                let maxEval = -Infinity;
                let allPossibleActions = [];
                let bestSequence = [];
                let bestSequenceCost = 0;

                // 1. Find all possible moves
                outerBuild:
                for (let r = 0; r < ROWS; r++) {
                    if (aiTimeExpired()) break outerBuild;
                    for (let c = 0; c < COLS; c++) {
                        if (aiTimeExpired()) break outerBuild;
                        if (board[r][c] && board[r][c].player === player && !movedPieces.has(`${r},${c}`)) {
                            const piece = board[r][c];
                            const moves = getValidMoves(r, c); // This is already filtered by movesLeft
                            for (let move of moves) {
                                if (aiTimeExpired()) break outerBuild;
                                let targetValue = 0;
                                if ((move.type === 'move' || move.type === 'shoot') && board[move.pos[0]][move.pos[1]]) {
                                    const targetPiece = board[move.pos[0]][move.pos[1]];
                                    const captureBonus = currentAiProfile ? currentAiProfile.captureBonus : 1.0;
                                    targetValue = aiPieceValues[targetPiece.type] * captureBonus;

                                    // KING TARGETING: Absolute priority for capturing the King - game-ending move
                                    if (targetPiece.type === 'King') {
                                        // Massive bonus for King capture - make it the highest priority target
                                        targetValue += aiPieceValues[targetPiece.type] * 50.0 * captureBonus; // 5000% bonus for King capture
                                        const distance = Math.abs(move.pos[0] - r) + Math.abs(move.pos[1] - c);
                                        if (distance === 1) {
                                            // Adjacent King - EXTREME PRIORITY
                                            targetValue += aiPieceValues[targetPiece.type] * 100.0 * captureBonus; // Additional 10000% bonus for adjacent King
                                        } else if (distance <= 2) {
                                            // Close to King - very high priority
                                            targetValue += aiPieceValues[targetPiece.type] * 25.0 * captureBonus; // Additional 2500% bonus for close King
                                        }
                                    } else {
                                        // If capturing a Spectre, account for 50% success rate (unless exempt)
                                        if (targetPiece.type === 'Spectre' && piece.type !== 'Wizard' && piece.type !== 'Spectre') {
                                            targetValue *= 0.5; // 50% chance of success
                                        }
                                        // Add proximity bonus: prioritize attacking adjacent/in-range pieces
                                        const distance = Math.abs(move.pos[0] - r) + Math.abs(move.pos[1] - c);
                                        if (distance === 1) {
                                            // CRITICAL PRIORITY: Adjacent pieces are immediate threats - heavily prioritize capturing them
                                            targetValue += aiPieceValues[targetPiece.type] * 4.32 * captureBonus; // 432% bonus for adjacent captures in minimax (increased by 80% from original 2.4, adjusted by AI profile)
                                            // Extra flat bonus for ANY adjacent capture to encourage eliminating all immediate threats
                                            targetValue += 10; // Flat bonus to encourage capturing even low-value adjacent pieces
                                        } else if (distance <= 2) {
                                            targetValue += aiPieceValues[targetPiece.type] * 0.3 * captureBonus; // 30% bonus for close attacks (adjusted by AI profile)
                                        }
                                    }
                                }
                                allPossibleActions.push({
                                    ...move,
                                    from: [r,c],
                                    pieceType: piece.type,
                                    targetValue: targetValue
                                });
                            }
                            
                            // Check for Dragon Inferno
                            if (piece.type === 'Dragon' && !dragonInfernoUsed[player] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                for (let d of directions) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== player)) {
                                        // Calculate total value of this Inferno move
                                        let infernoValue = 0;
                                        if (board[nr][nc] && board[nr][nc].player === opponent) {
                                            infernoValue += aiPieceValues[board[nr][nc].type];
                                        }
                                        // Check adjacent squares to the *landing spot*
                                        // Dragons cannot capture other Dragons with Inferno
                                        for (let d2 of directions) {
                                            let nnr = nr + d2[0], nnc = nc + d2[1];
                                            if (isValid(nnr, nnc) && board[nnr][nnc] && board[nnr][nnc].player === opponent && board[nnr][nnc].type !== 'Dragon') {
                                                infernoValue += aiPieceValues[board[nnr][nnc].type];
                                            }
                                        }
                                        // Add 40% bonus to encourage using Inferno special ability
                                        infernoValue *= 1.4;
                                        // Apply difficulty multiplier for special moves: Medium 1.2x, Hard 1.4x
                                        if (aiDifficulty === 'Hard') infernoValue *= 1.82; // +30% difficulty (1.4  1.82)
                                        else if (aiDifficulty === 'Medium') infernoValue *= 1.44; // +20% difficulty (1.2  1.44)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'inferno', pieceType: 'Dragon', targetValue: infernoValue });
                                    }
                                }
                            }

                            // Check for Wizard Strafe
                            if (piece.type === 'Wizard' && wizardStrafeUsed[player] < 2 && movesLeft >= 2) {
                                const strafeDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let d of strafeDirs) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && !board[nr][nc]) {
                                        // Strafe is a positional move, increased value for tactical positioning
                                        let strafeValue = 2.5;
                                        if (aiDifficulty === 'Hard') strafeValue *= 1.69; // +30% difficulty (1.3  1.69)
                                        else if (aiDifficulty === 'Medium') strafeValue *= 1.38; // +20% difficulty (1.15  1.38)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'strafe', pieceType: 'Wizard', targetValue: strafeValue });
                                    }
                                }
                            }

                            // Check for Dragon Strafe
                            if (piece.type === 'Dragon' && dragonStrafeUsed[player] < 2 && movesLeft >= 2) {
                                const strafeDirs = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let d of strafeDirs) {
                                    if (aiTimeExpired()) break outerBuild;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && !board[nr][nc]) {
                                        // Strafe is a positional move, increased value for tactical positioning
                                        let strafeValue = 2.5;
                                        if (aiDifficulty === 'Hard') strafeValue *= 1.69; // +30% difficulty (1.3  1.69)
                                        else if (aiDifficulty === 'Medium') strafeValue *= 1.38; // +20% difficulty (1.15  1.38)
                                        allPossibleActions.push({ type: 'move', pos: [nr, nc], from: [r,c], cost: 2, special: 'strafe', pieceType: 'Dragon', targetValue: strafeValue });
                                    }
                                }
                            }

                            // Check for Energy Blast (Wizard/Necromancer)
                            if (isSpellCasterPiece(piece) && isSpellVariant() && !movedPieces.has(`${r},${c}`)) {
                                const uses = energyBlastUsage.get(piece) || 0;
                                const totalUses = energyBlastUses[player] || 0;
                                if (uses < 2 && totalUses < 2) {
                                    const cost = uses === 0 ? 2 : 3;
                                    if (movesLeft >= cost) {
                                        const directions = getSpellDirectionOptions(player);
                                        for (const direction of directions) {
                                            if (aiTimeExpired()) break outerBuild;
                                            const expected = evaluateEnergyBlastDirection(r, c, direction, piece);
                                            if (expected > 0) {
                                                // Energy Blast is powerful - encourage its use with high multiplier
                                                // Base value is expected damage, add 50% bonus to encourage usage
                                                let blastValue = expected * 1.5;
                                                // Apply difficulty multiplier to make AI use it more on higher difficulties
                                                if (aiDifficulty === 'Hard') blastValue *= 1.8;
                                                else if (aiDifficulty === 'Medium') blastValue *= 1.5;
                                                allPossibleActions.push({
                                                    type: 'energyBlast',
                                                    from: [r, c],
                                                    direction: direction,
                                                    cost: cost,
                                                    special: 'energyBlast',
                                                    pieceType: piece.type,
                                                    targetValue: blastValue
                                                });
                                            }
                                        }
                                    }
                                }
                            }

                            // Check for Sacrifice (Wizard/Necromancer)
                            if (isSpellCasterPiece(piece) && isSpellVariant() && !movedPieces.has(`${r},${c}`)) {
                                if (!sacrificeAttemptedPieces.has(piece) && movesLeft >= 3) {
                                    const targets = listSacrificeTargets(r, c, player);
                                    if (targets.length > 0) {
                                        let captureValue = 0;
                                        let hasKing = false;
                                        for (const target of targets) {
                                            const value = aiPieceValues[target.piece.type] !== undefined
                                                ? aiPieceValues[target.piece.type]
                                                : (pieceValues[target.piece.type] || 0);
                                            captureValue += value;
                                            if (target.piece.type === 'King') {
                                                hasKing = true;
                                                captureValue += value * 80; // Massive bonus for King
                                            } else if (target.piece.type === 'Champion') {
                                                captureValue += 6;
                                            }
                                        }
                                        // Account for 50% success probability and losing the wizard
                                        const expectedCapture = captureValue * SACRIFICE_SUCCESS_PROBABILITY;
                                        const selfValue = (aiPieceValues[piece.type] || pieceValues[piece.type] || 0) * SACRIFICE_SUCCESS_PROBABILITY;
                                        // Sacrifice is strategic - encourage when capturing multiple high-value targets
                                        // Add 60% bonus to encourage usage (increased from base calculation)
                                        let sacrificeValue = (expectedCapture - selfValue) * 1.6;
                                        // Extra bonus for King capture via sacrifice
                                        if (hasKing) sacrificeValue *= 2.5;
                                        // Apply difficulty multiplier
                                        if (aiDifficulty === 'Hard') sacrificeValue *= 1.8;
                                        else if (aiDifficulty === 'Medium') sacrificeValue *= 1.5;
                                        allPossibleActions.push({
                                            type: 'sacrifice',
                                            from: [r, c],
                                            cost: 3,
                                            special: 'sacrifice',
                                            pieceType: piece.type,
                                            targetValue: sacrificeValue
                                        });
                                    }
                                }
                            }

                            // Check for Wizard Spectre Summoning
                            if (piece.type === 'Wizard' && spectresSummoned[player] < 2 && !wizardSummonedThisTurn[player] && movesLeft >= 2) {
                                const totalCaptured = getTotalCapturedCount();
                                if (totalCaptured >= 5) {
                                    const summonDirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                    for (let d of summonDirs) {
                                        if (aiTimeExpired()) break outerBuild;
                                        let nr = r + d[0], nc = c + d[1];
                                        if (isValid(nr, nc) && !board[nr][nc]) {
                                            // Summoning has 50% success rate, but Spectre is valuable (value 9)
                                            // Base value = 0.5 * 9 = 4.5, increased to 15.0 to heavily encourage summoning
                                            // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                            let summonValue = 15.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.95; // +30% difficulty (1.5  1.95)
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.56; // +20% difficulty (1.3  1.56)
                                            allPossibleActions.push({ type: 'summon', pos: [nr, nc], from: [r,c], cost: 2, special: 'summonSpectre', pieceType: 'Wizard', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Zombie Summoning (Elite/Supreme)
                            if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2) {
                                const maxZombies = getMaxZombies(player);
                                if (zombiesSummoned[player] < maxZombies) {
                                    const backRow = player === 'W' ? ROWS - 1 : 0;
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Zombie summoning has 50% success rate, Zombie value is 3
                                            // Expected value = 0.5 * 3 = 1.5, increased to 12.0 to encourage summoning
                                            // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                            let summonValue = 12.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.95; // +30% difficulty (1.5  1.95)
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.56; // +20% difficulty (1.3  1.56)
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'summonZombie', pieceType: 'Necromancer', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Lich Summoning (Elite/Supreme)
                            if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2) {
                                if ((lichesSummoned[player] || 0) < LICH_SUMMON_LIMIT) {
                                    const souls = (capturedPieces[player] || []).length;
                                    if (souls >= LICH_SUMMON_SOUL_THRESHOLD) {
                                        const backRow = player === 'W' ? ROWS - 1 : 0;
                                        for (let col = 0; col < COLS; col++) {
                                            if (aiTimeExpired()) break outerBuild;
                                            if (!board[backRow][col]) {
                                                let summonValue = 22;
                                                if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                                else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                                allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'summonNecromancerLich', pieceType: 'Necromancer', targetValue: summonValue });
                                            }
                                        }
                                    }
                                }
                            }

                            // Check for Necromancer Spectre Summoning (Elite/Supreme)
                            if (piece.type === 'Necromancer' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && spectresSummoned[player] < 2 && movesLeft >= 2) {
                                for (let dr = -1; dr <= 1; dr++) {
                                    if (aiTimeExpired()) break outerBuild;
                                    for (let dc = -1; dc <= 1; dc++) {
                                        if (dr === 0 && dc === 0) continue;
                                        const nr = r + dr;
                                        const nc = c + dc;
                                        if (!isValid(nr, nc)) continue;
                                        if (board[nr][nc]) continue;
                                        // Spectre summoning has 50% success rate, Spectre value is 9
                                        // Expected value = 0.5 * 9 = 4.5, increased to 16.0 to heavily encourage summoning
                                        // Apply difficulty multiplier: Easy 1.0x, Medium 1.3x, Hard 1.5x
                                        let summonValue = 16.0;
                                        if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                        else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                        allPossibleActions.push({ type: 'summon', pos: [nr, nc], from: [r,c], cost: 2, special: 'summonNecromancerSpectre', pieceType: 'Necromancer', targetValue: summonValue });
                                    }
                                }
                            }
                            if ((piece.type === 'Necromancer' || piece.type === 'Lich') && undeadSummoned[player] < UNDEAD_SUMMON_LIMIT && movesLeft >= UNDEAD_SUMMON_COST) {
                                const undeadTargets = getUndeadSummonTargets();
                                if (undeadTargets.length) {
                                    let summonValue = 14.0;
                                    if (aiDifficulty === 'Hard') summonValue *= 1.3;
                                    else if (aiDifficulty === 'Medium') summonValue *= 1.15;
                                    for (let [nr, nc] of undeadTargets) {
                                        if (aiTimeExpired()) break outerBuild;
                                        allPossibleActions.push({
                                            type: 'summon',
                                            pos: [nr, nc],
                                            from: [r,c],
                                            cost: UNDEAD_SUMMON_COST,
                                            special: 'summonNecromancerUndead',
                                            pieceType: piece.type,
                                            targetValue: summonValue
                                        });
                                    }
                                }
                            }

                            // Check for Champion Summoning (Necromancer, Huntsman)
                            if (piece.type === 'Champion' && (gameVariant === '36s-elite' || gameVariant === '36s-supreme') && movesLeft >= 2) {
                                const backRow = player === 'W' ? ROWS - 1 : 0;
                                const canSummonNecroAction = canChampionSummonNecromancer(player);
                                if (canSummonNecroAction) {
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Necromancer is extremely valuable for summoning capabilities
                                            let summonValue = 18.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'championSummon', summonType: 'Necromancer', pieceType: 'Champion', targetValue: summonValue });
                                        }
                                    }
                                }
                                // Check for Huntsman summoning (Supreme only)
                                if (gameVariant === '36s-supreme' && (huntsmenSummoned[player] || 0) < HUNTSMAN_SUMMON_LIMIT && (huntsmenOnBoard[player] || 0) < HUNTSMAN_MAX_ACTIVE) {
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Huntsman is valuable for mobility and capture mechanics
                                            let summonValue = 12.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'championSummon', summonType: 'Huntsman', pieceType: 'Champion', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                            // Check for King Summoning (Pistolier, Fusilier)
                            if (piece.type === 'King' && ['36s-expert', '36s-elite', '36s-supreme'].includes(gameVariant) && movesLeft >= 2) {
                                const backRow = player === 'W' ? ROWS - 1 : 0;
                                // Check for Pistolier summoning
                                if ((pistoliersSummoned[player] || 0) < 2) {
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Pistolier is valuable for diagonal shooting
                                            let summonValue = 10.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'kingSummon', summonType: 'Pistolier', pieceType: 'King', targetValue: summonValue });
                                        }
                                    }
                                }
                                // Check for Fusilier summoning
                                if ((fusiliersSummoned[player] || 0) < 2) {
                                    for (let col = 0; col < COLS; col++) {
                                        if (aiTimeExpired()) break outerBuild;
                                        if (!board[backRow][col]) {
                                            // Fusilier is valuable for forward shooting
                                            let summonValue = 10.0;
                                            if (aiDifficulty === 'Hard') summonValue *= 1.5;
                                            else if (aiDifficulty === 'Medium') summonValue *= 1.3;
                                            allPossibleActions.push({ type: 'summon', pos: [backRow, col], from: [r,c], cost: 2, special: 'kingSummon', summonType: 'Fusilier', pieceType: 'King', targetValue: summonValue });
                                        }
                                    }
                                }
                            }

                    if ((piece.type === 'Necromancer' || piece.type === 'Lich') && darkVoidUses[player] < DARK_VOID_USE_LIMIT && movesLeft >= DARK_VOID_COST) {
                        const darkVoidTargets = getDarkVoidTargets(r, c);
                        if (darkVoidTargets.length) {
                            for (let [nr, nc] of darkVoidTargets) {
                                let targetValue = 5.5; // Increased from 1.8 to encourage Dark Void usage
                                const occupant = board[nr][nc];
                                if (occupant) {
                                    const multiplier = occupant.player === player ? -0.35 : 1.5; // Increased from 1.1 to 1.5
                                    targetValue += (aiPieceValues[occupant.type] || 0) * multiplier;
                                }
                                if (aiDifficulty === 'Hard') targetValue *= 1.5; // Increased from 1.3
                                else if (aiDifficulty === 'Medium') targetValue *= 1.35; // Increased from 1.15
                                allPossibleActions.push({
                                    type: 'move',
                                    pos: [nr, nc],
                                    from: [r, c],
                                    cost: DARK_VOID_COST,
                                    special: 'darkVoid',
                                    pieceType: piece.type,
                                    targetValue
                                });
                            }
                        }
                    }

                    if ((piece.type === 'Champion' || piece.type === 'King') &&
                        gameVariant === '36s-supreme' && // Barrage only available in Supreme variant
                        !lastAction?.move &&
                        canUseBarrage(player) &&
                        moralBoostSuccesses[player] >= BARRAGE_REQUIRED_MORAL_BOOSTS &&
                        movesLeft >= BARRAGE_COST &&
                        !reinforcementPending &&
                        !movedPieces.has(`${r},${c}`)) {
                        let enemyCandidates = 0;
                        for (let rr = 0; rr < ROWS; rr++) {
                            for (let cc = 0; cc < COLS; cc++) {
                                const occupant = board[rr][cc];
                                if (occupant && occupant.player !== player) {
                                    enemyCandidates++;
                                }
                            }
                        }
                        if (enemyCandidates > 0) {
                            // Highly encourage barrage usage after achieving 3 moral boosts
                            let targetValue = Math.min(enemyCandidates, BARRAGE_TARGET_COUNT) * 6.0; // Increased from 3.2 to 6.0
                            if (aiDifficulty === 'Hard') targetValue *= 1.5; // Increased from 1.25 to 1.5
                            else if (aiDifficulty === 'Medium') targetValue *= 1.3; // Increased from 1.15 to 1.3
                            allPossibleActions.push({
                                type: 'barrage',
                                from: [r, c],
                                cost: BARRAGE_COST,
                                special: 'barrage',
                                targetValue
                            });
                        }
                    }

                            // Check for Elephantry Charge
                            if (piece.type === 'Elephantry' && movesLeft >= 2) {
                                if (!elephantryChargeUsed.has(piece)) {
                                    const facing = piece.facing;
                                    let directions = [];
                                    if (facing === 'U') directions = [[-1,0], [-1,-1], [-1,1]];
                                    else if (facing === 'D') directions = [[1,0], [1,-1], [1,1]];
                                    else if (facing === 'L') directions = [[0,-1], [-1,-1], [1,-1]];
                                    else if (facing === 'R') directions = [[0,1], [-1,1], [1,1]];

                                    for (let d of directions) {
                                        if (aiTimeExpired()) break outerBuild;
                                        let capturesInPath = [];
                                        let canCharge = true;
                                        let finalPos = null;

                                        for (let dist = 1; dist <= 3; dist++) {
                                            let nr = r + d[0] * dist;
                                            let nc = c + d[1] * dist;
                                            if (!isValid(nr, nc)) {
                                                canCharge = false;
                                                break;
                                            }

                                            const target = board[nr][nc];
                                            if (target) {
                                                if (target.type === 'Spectre') {
                                                    canCharge = false;
                                                    break;
                                                }
                                                if (target.player !== player) {
                                                    capturesInPath.push(aiPieceValues[target.type]);
                                                    if (target.type === 'Elephantry' || target.type === 'Ogre' || target.type === 'Troll' || target.type === 'Dragon') {
                                                        finalPos = [nr, nc];
                                                        break;
                                                    }
                                                } else {
                                                    canCharge = false;
                                                    break;
                                                }
                                            }
                                            if (dist === 3) finalPos = [nr, nc];
                                        }

                                        if (canCharge && finalPos) {
                                            let chargeValue = capturesInPath.reduce((sum, val) => sum + val, 0);
                                            // Encourage charge if it captures multiple pieces
                                            if (capturesInPath.length > 1) chargeValue *= 1.3;
                                            allPossibleActions.push({ type: 'move', pos: finalPos, from: [r,c], cost: 2, special: 'elephantryCharge', pieceType: 'Elephantry', targetValue: chargeValue });
                                        }
                                    }
                                }
                            }
                            if (piece.type === 'Ogre' && !ogreRageUsed[player] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0]];
                                for (let dir of directions) {
                                    if (aiTimeExpired()) break outerBuild;
                                    const pattern = buildOgreRagePattern(r, c, dir, player);
                                    if (!pattern) continue;
                                    let rageValue = 0;
                                    for (const [ar, ac] of pattern.area) {
                                        const occupant = board[ar][ac];
                                        if (occupant && occupant.player !== player) {
                                            rageValue += aiPieceValues[occupant.type] || 0;
                                        }
                                    }
                                    allPossibleActions.push({
                                        type: 'move',
                                        pos: pattern.dest,
                                        from: [r, c],
                                        cost: 2,
                                        pieceType: 'Ogre',
                                        special: 'rage',
                                        captureArea: pattern.area,
                                        targetValue: rageValue
                                    });
                                }
                            }

                            // Check for turn actions
                            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                                const validDirections = getValidTurnDirections(piece.facing);
                                for (let facing of validDirections) {
                                    if (aiTimeExpired()) break outerBuild;
                                    allPossibleActions.push({ type: 'turn', pos: [r,c], from: [r,c], facing, cost: turnCosts[piece.type], pieceType: piece.type, targetValue: 0 });
                                    
                                    // Check for turn and move
                                    if (piece.type === 'Infantry' && movesLeft >= turnCosts[piece.type] + 1) {
                                        // Simulate the turn to get new moves
                                        const tempBoard = cloneBoard(board);
                                        tempBoard[r][c].facing = facing;
                                        const turnMoves = pieceTypes[piece.type].move(r, c, tempBoard, player, false, facing, movesLeft - turnCosts[piece.type]);
                                        const forwardTurnMoves = filterInfantryForwardMoves(turnMoves, facing, r, c);
                                        for (let tm of forwardTurnMoves.filter(m => m.type === 'move' && m.cost <= (movesLeft - turnCosts[piece.type]))) {
                                            if (aiTimeExpired()) break outerBuild;
                                             allPossibleActions.push({ 
                                                type: 'turnAndMove', 
                                                pos: [r,c], 
                                                from: [r,c], 
                                                facing, 
                                                move: tm.pos, 
                                                cost: turnCosts[piece.type] + tm.cost, 
                                                jump: tm.jump,
                                                pieceType: piece.type,
                                                targetValue: board[tm.pos[0]][tm.pos[1]] ? aiPieceValues[board[tm.pos[0]][tm.pos[1]].type] : 0
                                            });
                                        }
                                    }

                                    // Archer Turn + Shoot (player-only)
                                    if (piece.type === 'Archer' && movesLeft >= turnCosts[piece.type] + 1) {
                                        const tempBoard2 = cloneBoard(board);
                                        tempBoard2[r][c].facing = facing;
                                        const turnMoves2 = pieceTypes['Archer'].move(r, c, tempBoard2, player, false, facing, movesLeft - turnCosts[piece.type]);
                                        for (let tm of turnMoves2.filter(m => m.type === 'shoot' && m.cost === 1)) {
                                            if (aiTimeExpired()) break outerBuild;
                                            allPossibleActions.push({
                                                type: 'turnAndShoot',
                                                pos: [r,c],
                                                from: [r,c],
                                                facing,
                                                shoot: tm.pos,
                                                cost: turnCosts[piece.type] + 1,
                                                pieceType: piece.type,
                                                targetValue: aiPieceValues[board[tm.pos[0]][tm.pos[1]]?.type] || 0
                                            });
                                        }
                                    }
                                }
                            }

                            // Archer Move + Diagonal Shoot (player-only)
                            if (piece.type === 'Archer' && movesLeft >= 2 && archerMoveDiagShootUsed[player] < 2) {
                                const basicMoves = pieceTypes['Archer'].move(r, c, board, player, null, piece.facing) || [];
                                for (let mv of basicMoves.filter(m => m.type === 'move' && m.cost === 1 && (!board[m.pos[0]][m.pos[1]] || board[m.pos[0]][m.pos[1]].player !== player))) {
                                    if (aiTimeExpired()) break outerBuild;
                                    const nr = mv.pos[0], nc = mv.pos[1];
                                    // Only consider if square is empty or capture allowed; allow both
                                    const dirs = [[-1,-1],[ -1,1 ],[ 1,-1 ],[ 1,1 ]];
                                    for (let d of dirs) {
                                        if (aiTimeExpired()) break outerBuild;
                                        const sr = nr + d[0], sc = nc + d[1];
                                        if (isValid(sr, sc) && board[sr][sc] && board[sr][sc].player !== player) {
                                            allPossibleActions.push({
                                                type: 'archerMoveDiagShoot',
                                                from: [r,c],
                                                move: [nr, nc],
                                                shoot: [sr, sc],
                                                cost: 2,
                                                pieceType: 'Archer',
                                                targetValue: aiPieceValues[board[sr][sc].type]
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 2. Sort actions: prioritize captures, then cost (prefer using more move points), then special abilities, then avoid unnecessary turns
                allPossibleActions.sort((a, b) => {
                    // Prioritize captures by target value
                    if (a.targetValue > b.targetValue) return -1;
                    if (a.targetValue < b.targetValue) return 1;

                    // Strongly prefer actions that use more move points (encourage AI to spend all points)
                    const aCost = typeof a.cost === 'number' ? a.cost : 1;
                    const bCost = typeof b.cost === 'number' ? b.cost : 1;
                    if (aCost !== bCost) return bCost - aCost; // Higher cost = better (spend more points)

                    // Prioritize special abilities
                    if (a.special && !b.special) return -1;
                    if (b.special && !a.special) return 1;

                    // Avoid unnecessary turns (don't penalize shooting pieces for turning)
                    if (a.type === 'turn' && !['Archer', 'Ballista'].includes(a.pieceType) && b.type !== 'turn') return 1;
                    if (b.type === 'turn' && !['Archer', 'Ballista'].includes(b.pieceType) && a.type !== 'turn') return -1;

                    return 0; // Keep stable order otherwise
                });

                const actionCap = isLargeBoardVariant() ? 80 : 220;
                if (allPossibleActions.length > actionCap) {
                    allPossibleActions = allPossibleActions.slice(0, actionCap);
                }
                
                // 3. Evaluate sorted actions
                for (let action of allPossibleActions) {
                    if (aiTimeExpired()) break;
                    const { from, pos, cost, jump, special, type, facing, move, captureArea, pieceType } = action;
                    const actionCost = typeof cost === 'number' ? cost : 0;
                    const r = from[0];
                    const c = from[1];

                    if (movesLeft < actionCost) continue; 

                    const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                    const newScores = { ...scores };
                    const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                    let newBoard;
                    let newMovedPieces = new Set(movedPieces);
                    newMovedPieces.add(`${r},${c}`);
                    
                    if (type === 'move') {
                        if (special === 'darkVoid') {
                            newBoard = cloneBoard(board);
                            const targetRow = pos[0];
                            const targetCol = pos[1];
                            const occupant = newBoard[targetRow][targetCol];
                            if (occupant && occupant.type !== 'DarkVoid') {
                                newCapturedPieces[player].push(occupant);
                                const captureValue = aiPieceValues[occupant.type] || 0;
                                newScores[player] += occupant.player === player ? -captureValue * 0.35 : captureValue;
                            }
                            newBoard[targetRow][targetCol] = { type: 'DarkVoid' };
                            newMovedPieces.add(`${r},${c}`);
                        } else {
                        const result = simulateMove(board, r, c, pos[0], pos[1], jump, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                        newBoard = result.board;
                        if (special === 'inferno') {
                            newBoard = simulateInfernoCapture(newBoard, pos[0], pos[1], player, newCapturedPieces, newScores);
                        }
                        if (special === 'rage') {
                            newBoard = simulateOgreRageCapture(newBoard, captureArea, player, newCapturedPieces, newScores);
                        }
                            newMovedPieces.add(`${pos[0]},${pos[1]}`);
                        }
                    } else if (type === 'shoot') {
                        newBoard = simulateShoot(board, r, c, pos[0], pos[1], player, newCapturedPieces, newScores);
                    } else if (type === 'activate' && special === 'ballistaRange') {
                        // No board change; treat as state-only in real play. Here, approximate as no-op.
                        newBoard = cloneBoard(board);
                    } else if (type === 'swap') {
                        newBoard = cloneBoard(board);
                        const guardPiece = newBoard[pos[0]][pos[1]];
                        newBoard[pos[0]][pos[1]] = newBoard[r][c];
                        newBoard[r][c] = guardPiece;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'teleport') {
                        newBoard = cloneBoard(board);
                        const destinationPiece = newBoard[pos[0]][pos[1]];
                        if (destinationPiece) {
                            if (destinationPiece.player === player || destinationPiece.type !== 'Spectre') {
                                continue;
                            }
                            newCapturedPieces[player].push(destinationPiece);
                            newScores[player] += aiPieceValues[destinationPiece.type];
                        }
                        newBoard[pos[0]][pos[1]] = newBoard[r][c];
                        newBoard[r][c] = null;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'teleportSwap') {
                        newBoard = cloneBoard(board);
                        const playerWizard = newBoard[r][c];
                        const opponentWizard = newBoard[pos[0]][pos[1]];
                        newBoard[pos[0]][pos[1]] = playerWizard;
                        newBoard[r][c] = opponentWizard;
                        newMovedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (type === 'turn') {
                        newBoard = simulateTurn(board, r, c, facing);
                    } else if (type === 'turnAndMove') {
                         const result = simulateTurnAndMove(board, r, c, facing, move[0], move[1], jump, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                         newBoard = result.board;
                         newMovedPieces.add(`${move[0]},${move[1]}`);
                    } else if (type === 'turnAndShoot') {
                        // Approximate: turn then apply shoot
                        const turned = simulateTurn(board, r, c, facing);
                        newBoard = simulateShoot(turned, r, c, action.shoot[0], action.shoot[1], player, newCapturedPieces, newScores);
                    } else if (type === 'archerMoveDiagShoot') {
                        const mv = simulateMove(board, r, c, action.move[0], action.move[1], null, player, newCapturedPieces, newScores, newChampionsOnBackRow);
                        newBoard = simulateShoot(mv.board, action.move[0], action.move[1], action.shoot[0], action.shoot[1], player, newCapturedPieces, newScores);
                        newMovedPieces.add(`${action.move[0]},${action.move[1]}`);
                    } else if (type === 'summon') {
                        // Simulate summoning (has 50% success rate, we evaluate expected value in targetValue)
                        newBoard = cloneBoard(board);
                        // Optimistically place the summoned piece for evaluation
                        if (special === 'summonSpectre') {
                            newBoard[pos[0]][pos[1]] = { type: 'Spectre', player };
                            // Note: In real execution, this has 50% success which is factored into targetValue
                        } else if (special === 'summonZombie') {
                            newBoard[pos[0]][pos[1]] = { type: 'Zombie', player, facing: player === 'W' ? 'U' : 'D' };
                        } else if (special === 'summonNecromancerSpectre') {
                            newBoard[pos[0]][pos[1]] = { type: 'Spectre', player };
                        } else if (special === 'summonNecromancerLich') {
                            newBoard[pos[0]][pos[1]] = { type: 'Lich', player };
                        } else if (special === 'summonNecromancerUndead') {
                            const summonerType = pieceType || 'Necromancer';
                            const undeadLives = UNDEAD_LIVES_BY_SUMMONER[summonerType] || UNDEAD_LIVES_BY_SUMMONER['Necromancer'];
                            newBoard[pos[0]][pos[1]] = createUndeadPiece(player, undeadLives, summonerType);
                        }
                    } else {
                        continue; // Should not happen
                    }
                    
                    const childResult = minimax(newBoard, depth - 1, false, player, movesLeft - actionCost, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow);
                    const eval = childResult.score;
                    const totalCost = actionCost + (childResult.sequenceCost || 0);
                    if (eval > maxEval + AI_TIE_EPSILON || (Math.abs(eval - maxEval) <= AI_TIE_EPSILON && totalCost > bestSequenceCost)) {
                        maxEval = eval;
                        bestAction = action;
                        bestSequence = [action, ...(childResult.sequence || [])];
                        bestSequenceCost = totalCost;
                    }
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                if (maxEval === -Infinity) {
                    maxEval = leafScore();
                }
                return { score: maxEval, action: bestAction, sequence: bestSequence, sequenceCost: bestSequenceCost };
            } else { // Minimizing player (opponent simulation)
                let minEval = Infinity;
                // Note: We don't need to sort for the minimizing player, just find their best (worst for us) response.
                for (let r = 0; r < ROWS; r++) {
                    if (aiTimeExpired()) break;
                    for (let c = 0; c < COLS; c++) {
                        if (aiTimeExpired()) break;
                        if (board[r][c] && board[r][c].player === opponent && !movedPieces.has(`${r},${c}`)) {
                            const piece = board[r][c];
                            const moves = getValidMoves(r, c); // Already filtered by movesLeft
                            for (let move of moves) {
                                if (aiTimeExpired()) break;
                                // ... (Simulation logic as above) ...
                                const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                const newScores = { ...scores };
                                const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                let newBoard;
                                let newMovedPieces = new Set(movedPieces);
                                newMovedPieces.add(`${r},${c}`);

                                if (move.type === 'move') {
                                    const result = simulateMove(board, r, c, move.pos[0], move.pos[1], move.jump, opponent, newCapturedPieces, newScores, newChampionsOnBackRow);
                                    newBoard = result.board;
                                    if (move.special === 'inferno') {
                                        newBoard = simulateInfernoCapture(newBoard, move.pos[0], move.pos[1], opponent, newCapturedPieces, newScores);
                                    }
                                    if (move.special === 'rage') {
                                        newBoard = simulateOgreRageCapture(newBoard, move.captureArea, opponent, newCapturedPieces, newScores);
                                    }
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'shoot') {
                                    newBoard = simulateShoot(board, r, c, move.pos[0], move.pos[1], opponent, newCapturedPieces, newScores);
                                } else if (move.type === 'swap') {
                                    newBoard = cloneBoard(board);
                                    const guardPiece = newBoard[move.pos[0]][move.pos[1]];
                                    newBoard[move.pos[0]][move.pos[1]] = newBoard[r][c];
                                    newBoard[r][c] = guardPiece;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'teleport') {
                                    newBoard = cloneBoard(board);
                                    newBoard[move.pos[0]][move.pos[1]] = newBoard[r][c];
                                    newBoard[r][c] = null;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else if (move.type === 'teleportSwap') {
                                    newBoard = cloneBoard(board);
                                    const playerWizard = newBoard[r][c];
                                    const opponentWizard = newBoard[move.pos[0]][move.pos[1]];
                                    newBoard[move.pos[0]][move.pos[1]] = playerWizard;
                                    newBoard[r][c] = opponentWizard;
                                    newMovedPieces.add(`${move.pos[0]},${move.pos[1]}`);
                                } else {
                                    continue;
                                }

                                const eval = minimax(newBoard, depth - 1, true, player, movesLeft - move.cost, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow).score;
                                minEval = Math.min(minEval, eval);
                                beta = Math.min(beta, eval);
                                if (beta <= alpha) break;
                            }
                            if (beta <= alpha) break;
                            
                            // Check for Dragon Inferno for opponent
                            if (piece.type === 'Dragon' && !dragonInfernoUsed[opponent] && movesLeft >= 2) {
                                const directions = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                                for (let d of directions) {
                                    if (aiTimeExpired()) break;
                                    let nr = r + d[0], nc = c + d[1];
                                    if (isValid(nr, nc) && (!board[nr][nc] || board[nr][nc].player !== opponent)) {
                                        const newCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                        const newScores = { ...scores };
                                        const newChampionsOnBackRow = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                        let newMovedPieces = new Set(movedPieces);
                                        newMovedPieces.add(`${r},${c}`);
                                        
                                        const result = simulateMove(board, r, c, nr, nc, null, opponent, newCapturedPieces, newScores, newChampionsOnBackRow);
                                        let newBoard = result.board;
                                        newBoard = simulateInfernoCapture(newBoard, nr, nc, opponent, newCapturedPieces, newScores);
                                        newMovedPieces.add(`${nr},${nc}`);
                                        
                                        const eval = minimax(newBoard, depth - 1, true, player, movesLeft - 2, newMovedPieces, newCapturedPieces, newScores, alpha, beta, newChampionsOnBackRow).score;
                                        minEval = Math.min(minEval, eval);
                                        beta = Math.min(beta, eval);
                                        if (beta <= alpha) break;
                                    }
                                }
                            }
                            if (beta <= alpha) break;

                            // Check opponent's turn actions
                            if (turnablePieces.includes(piece.type) && movesLeft >= turnCosts[piece.type]) {
                                const validDirections = getValidTurnDirections(piece.facing);
                                for (let facing of validDirections) {
                                    if (aiTimeExpired()) break;
                                    const newBoard = simulateTurn(board, r, c, facing);
                                    const newMovedPieces = new Set(movedPieces);
                                    newMovedPieces.add(`${r},${c}`);
                                    let newMovesLeft = movesLeft - turnCosts[piece.type];
                                    
                                    let eval;
                                    if (piece.type === 'Infantry' && newMovesLeft >= 1) {
                                        // Opponent turn-and-move
                                        const tempBoard = cloneBoard(newBoard);
                                        const turnMoves = pieceTypes[piece.type].move(r, c, tempBoard, opponent, false, facing, newMovesLeft);
                                        
                                        let bestTurnMoveEval = Infinity;
                                        for (let tm of turnMoves.filter(m => m.type === 'move' && m.cost <= newMovesLeft)) {
                                            if (aiTimeExpired()) break;
                                            const tmCapturedPieces = { W: [...capturedPieces.W], B: [...capturedPieces.B] };
                                            const tmScores = { ...scores };
                                            const tmChampions = { W: [...championsOnBackRow.W], B: [...championsOnBackRow.B] };
                                            const result = simulateTurnAndMove(board, r, c, facing, tm.pos[0], tm.pos[1], tm.jump, opponent, tmCapturedPieces, tmScores, tmChampions);
                                            const tmBoard = result.board;
                                            const tmMovedPieces = new Set(newMovedPieces);
                                            tmMovedPieces.add(`${tm.pos[0]},${tm.pos[1]}`);
                                            
                                            const tmEval = minimax(tmBoard, depth - 1, true, player, newMovesLeft - tm.cost, tmMovedPieces, tmCapturedPieces, tmScores, alpha, beta, tmChampions).score;
                                            bestTurnMoveEval = Math.min(bestTurnMoveEval, tmEval);
                                        }
                                        eval = bestTurnMoveEval;
                                        
                                    } else {
                                        // Simple turn
                                        eval = minimax(newBoard, depth - 1, true, player, newMovesLeft, newMovedPieces, capturedPieces, scores, alpha, beta, championsOnBackRow).score;
                                    }
                                    
                                    minEval = Math.min(minEval, eval);
                                    beta = Math.min(beta, eval);
                                    if (beta <= alpha) break;
                                }
                            }
                        }
                        if (beta <= alpha) break;
                    }
                }
                if (minEval === Infinity) {
                    minEval = leafScore();
                }
                return { score: minEval, sequence: [], sequenceCost: 0 };
            }
        }


        function evaluateTurn(row, col, newFacing, player) {
            const piece = board[row][col];
            const tempFacing = piece.facing;
            piece.facing = newFacing;
            const moves = getValidMoves(row, col);
            piece.facing = tempFacing;
            let score = (piece.type === 'Infantry' || piece.type === 'Mercenary') ? 1 : 0;
            const opponentBackRow = player === 'W' ? 0 : (gameVariant === 'ccb' ? 7 : 9);
            for (let move of moves) {
                if (move.type === 'shoot') {
                    const [r, c] = move.pos;
                    score += aiPieceValues[board[r][c]?.type] || 0;
                } else if (move.type === 'move' && (piece.type === 'Infantry' || piece.type === 'Mercenary') && move.pos[0] === opponentBackRow) {
                    score += 5;
                }
            }
            return score + Math.random();
        }

        function isValid(row, col) {
            return row >= 0 && row < ROWS && col >= 0 && col < COLS;
        }

        function isCheckAfterMove(fromRow, fromCol, toRow, toCol, player) {
            return false;
        }

        function highlightValidMoves() {
            if (!selectedPiece) return;
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                const move = validMoves.find(m => m.pos[0] === r && m.pos[1] === c);
                if (r === selectedPiece.row && c === selectedPiece.col) {
                    square.classList.add('selected');
                } else if (move) {
                    if (move.type === 'move' && !board[r][c]) {
                        square.classList.add('valid-move');
                    } else if (move.type === 'move' && board[r][c] && board[r][c].player !== board[selectedPiece.row][selectedPiece.col].player) {
                        square.classList.add('valid-capture');
                    } else if (move.type === 'shoot') {
                        square.classList.add('valid-shoot');
                    } else if (move.type === 'swap' || move.type === 'teleportSwap') {
                        square.classList.add('valid-swap');
                    } else if (move.type === 'teleport') {
                        square.classList.add('valid-move');
                    } else if (move.type === 'summon') {
                        square.classList.add('valid-move');
                    }
                    if (move.special === 'summonDarkVoid') {
                        square.classList.add('valid-dark-void-target');
                    }
                }
            });
        }

        function aiTurn() {
            currentPlayer = 'B';
            aiPending = false; // clear any scheduled AI flag
            aiRoundNumber++; // Increment AI round counter
            const baseMoves = calculateBaseMoves('B');
            // Reset Ballista per-round boost for AI
            ballistaRangeBoostActive['B'] = false;
            ballistaRangeBoostUsedThisTurn['B'] = false;
            // Reset wizard summoning flag for new round
            wizardSummonedThisTurn['B'] = false;
            // Clear wizard movement restrictions from previous round
            wizardCannotMoveNextTurn['B'].clear();
            isFirstPlayerTurn = false;
            aiSearchDeadline = 0;

            if (!applyStartTurnModifiers('B', baseMoves, { skipStopTimer: true })) {
                completeAiTurn();
                return;
            }

            movedPieces.clear();
            updateStatus();
            updateEndTurnButton();

            let plannedActions = [];

            // Add 3-7 second delay buffer before AI starts making moves
            const aiStartDelay = 3000 + Math.random() * 4000; // Random delay between 3000-7000ms

            function completeAiMove(action, moveResult = null) {
                const special = action?.special;
                if (special === 'charge') {
                    cavalryChargeUsed['B'] = true;
                }
                if (special === 'inferno') {
                    performInfernoCapture(action.pos[0], action.pos[1], 'B');
                    dragonInfernoUsed['B'] = true;
                }
                if (special === 'strafe') {
                    const piece = board[action.pos[0]][action.pos[1]];
                    if (piece && piece.type === 'Wizard') {
                        wizardStrafeUsed['B']++;
                    } else if (piece && piece.type === 'Dragon') {
                        dragonStrafeUsed['B']++;
                    }
                }
                if (special === 'ballistaDoubleTime') {
                    ballistaDoubleTimeUsed['B']++;
                }
                if (special === 'elephantryCharge') {
                    const chargedPiece = board[action.pos[0]][action.pos[1]];
                    if (chargedPiece) {
                        elephantryChargeUsed.add(chargedPiece);
                    }
                    gameLog.push(`AI used Elephantry Charge from ${formatBoardCoordinates(action.from[0],action.from[1])} to ${formatBoardCoordinates(action.pos[0],action.pos[1])}`);
                }
                if (special === 'rage') {
                    ogreRageUsed['B'] = true;
                    performOgreRageCapture(action.captureArea, 'B');
                }
                movedPieces.add(`${action.pos[0]},${action.pos[1]}`);
                renderBoard();
                updateStatus();
                updateEndTurnButton();
                updateGameLog();
                updateScoreDisplay();
                if (moveResult?.mercenaryFlipNeeded) {
                    const mercPiece = moveResult.mercenaryPiece;
                    const mercPos = moveResult.mercenaryPos;
                    handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, () => {
                        setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                    });
                    return;
                }
                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
            }

            function handleAiElephantryMoveShoot(action, moveResult, finalRow, finalCol) {
                const piece = board[finalRow]?.[finalCol];
                if (!piece || piece.player !== 'B' || piece.type !== 'Elephantry') {
                    completeAiMove(action, moveResult);
                    return;
                }
                const target = selectAiElephantryMoveShootTarget(finalRow, finalCol);
                if (target) {
                    shootPiece(finalRow, finalCol, target[0], target[1]);
                    const targetLabel = formatBoardCoordinates(target[0], target[1]);
                    gameLog.push(`${getOpponentDisplayName()} Elephantry shot at ${targetLabel}.`);
                } else {
                    gameLog.push(`${getOpponentDisplayName()} Elephantry had no clear targets after moving.`);
                }
                renderBoard();
                updateCapturedPiecesDisplay();
                updateScoreDisplay();
                updateGameLog();
                completeAiMove(action, moveResult);
            }

            function executeAiElephantryTripleShot(action) {
                const [startRow, startCol] = action.from || action.pos || [];
                const piece = board[startRow]?.[startCol];
                if (!piece || piece.player !== 'B' || piece.type !== 'Elephantry') {
                    setTimeout(() => makeNextMove(), 400);
                    return;
                }
                const pieceKey = `${startRow},${startCol},${piece.player}`;
                const remainingUses = typeof elephantryExtendedRangeShotsRemaining[pieceKey] === 'number'
                    ? elephantryExtendedRangeShotsRemaining[pieceKey]
                    : 3;
                if (remainingUses <= 0) {
                    setTimeout(() => makeNextMove(), 400);
                    return;
                }
                const actionCost = typeof action.cost === 'number' ? action.cost : 2;
                movesLeft = Math.max(0, movesLeft - actionCost);
                highlightSquares = [[startRow, startCol]];
                updateStatus();
                updateEndTurnButton();
                lastAction = { special: 'elephantryTripleShot' };

                const finishTripleShot = () => {
                    elephantryExtendedRangeShotsRemaining[pieceKey] = Math.max(0, remainingUses - 1);
                    elephantryTripleShotFlipResults = [];
                    highlightSquares = [];
                    renderBoard();
                    completeAiMove(action);
                };

                let shotsFired = 0;
                const fireNextShot = () => {
                    // Only fire as many shots as there are successful flips
                    if (shotsFired >= elephantryTripleShotFlipResults.length) {
                        finishTripleShot();
                        return;
                    }
                    const options = getElephantryExtendedRangeMoves(startRow, startCol);
                    if (!options.length) {
                        finishTripleShot();
                        return;
                    }
                    let bestMove = null;
                    let bestValue = -Infinity;
                    for (const move of options) {
                        const targetPiece = board[move.pos[0]][move.pos[1]];
                        if (!targetPiece) continue;
                        const value = aiPieceValues[targetPiece.type] !== undefined
                            ? aiPieceValues[targetPiece.type]
                            : (pieceValues[targetPiece.type] || 0);
                        if (value > bestValue) {
                            bestValue = value;
                            bestMove = move;
                        }
                    }
                    if (!bestMove) {
                        finishTripleShot();
                        return;
                    }
                    const targetRow = bestMove.pos[0];
                    const targetCol = bestMove.pos[1];
                    const targetPiece = board[targetRow]?.[targetCol];
                    // All flips in array are successful, so process as hit
                    if (targetPiece && targetPiece.player !== 'B') {
                        const logMessage = `AI Elephantry triple shot hit ${targetPiece.type} at ${formatBoardCoordinates(targetRow,targetCol)}.`;
                        applySpellCapture('B', targetRow, targetCol, {
                            ability: 'Elephantry Triple Shot',
                            logMessage
                        });
                    } else {
                        gameLog.push(`AI Elephantry triple shot missed at ${formatBoardCoordinates(targetRow,targetCol)}.`);
                    }
                    updateCapturedPiecesDisplay();
                    updateScoreDisplay();
                    updateGameLog();
                    renderBoard();
                    checkSupremacy('B');
                    if (gameOver) return;
                    shotsFired++;
                    setTimeout(() => fireNextShot(), 600);
                };

                // Roll coin flips first, then start firing shots
                elephantryTripleShotFlipResults = [];
                rollElephantryTripleShotFlips(() => {
                    fireNextShot();
                });
            }

            function makeNextMove() {
                try {
                    // If game is paused (e.g., warcry animation), reschedule and wait
                    if (gamePaused) {
                        setTimeout(() => makeNextMove(), 200);
                        return;
                    }
                    if (currentPlayer !== 'B') {
                        return;
                    }
                    if (aiTurnTimeoutForced) {
                        aiTurnTimeoutForced = false;
                        movesLeft = 0;
                    }
                    if (movesLeft <= 0 || reinforcementPending) {
                        highlightSquares = [];
                        plannedActions = [];
                        completeAiTurn();
                        return;
                    }
                    // Give priority to defensive and utility King abilities when available
                    const kingEvadePlan = getBestKingEvadePlan('B', movedPieces);
                    if (kingEvadePlan) {
                        plannedActions = [];
                        const [fromRow, fromCol] = kingEvadePlan.from;
                        const [toRow, toCol] = kingEvadePlan.to;
                        highlightSquares = [kingEvadePlan.from, kingEvadePlan.to];
                        movePiece(fromRow, fromCol, toRow, toCol);
                        kingEvadeUsed['B'] = true;
                        nextRoundModifier['B'] -= 2;
                        lastAction = { move: true };
                        movedPieces.add(`${toRow},${toCol}`);
                        const aiLabel = getOpponentDisplayName();
                        gameLog.push(`${aiLabel} used King Evade (-2 moves next round).`);
                        renderBoard();
                        updateStatus();
                        updateEndTurnButton();
                        updateGameLog();
                        checkGameOver();
                        setTimeout(() => {
                            highlightSquares = [];
                            renderBoard();
                            setTimeout(() => makeNextMove(), 1000);
                        }, 800);
                        return;
                    }

                    if (plannedActions.length === 0) {
                        const kingShotPlan = getBestKingShotPlan('B', movedPieces, movesLeft);
                        if (kingShotPlan) {
                            plannedActions = [];
                            const [fromRow, fromCol] = kingShotPlan.from;
                            const [targetRow, targetCol] = kingShotPlan.target;
                            const kingPiece = board[fromRow]?.[fromCol];
                            if (!kingPiece || kingPiece.type !== 'King') {
                                setTimeout(() => makeNextMove(), 200);
                                return;
                            }
                            highlightSquares = [kingShotPlan.from, kingShotPlan.target];
                            movesLeft = Math.max(0, movesLeft - 1);
                            markKingShotUsed(kingPiece);
                            shootPiece(fromRow, fromCol, targetRow, targetCol);
                            lastAction = { shoot: true };
                            movedPieces.add(`${fromRow},${fromCol}`);
                            const aiLabel = getOpponentDisplayName();
                            gameLog.push(`${aiLabel} executed King Shot.`);
                            renderBoard();
                            updateStatus();
                            updateEndTurnButton();
                            updateGameLog();
                            checkGameOver();
                            setTimeout(() => {
                                highlightSquares = [];
                                renderBoard();
                                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                            }, 1000);
                            return;
                        }

                        const moralBoostTarget = getAiMoralBoostTarget('B', movedPieces, movesLeft);
                        if (moralBoostTarget) {
                            plannedActions = [];
                            const [kingRow, kingCol] = moralBoostTarget;
                            moralBoostUses['B']++;
                            movesLeft = Math.max(0, movesLeft - 1);
                            highlightSquares = [[kingRow, kingCol]];
                            updateStatus();
                            updateEndTurnButton();
                            const aiLabel = getOpponentDisplayName();
                            performCoinToss(
                                'Moral Boost',
                                `${aiLabel} is attempting a Moral Boost...`,
                                (success) => {
                                    if (success) {
                                        nextRoundModifier['B'] += MORAL_BOOST_BONUS;
                                        moralBoostSuccesses['B']++;
                                        const justUnlockedBarrage = moralBoostSuccesses['B'] === BARRAGE_REQUIRED_MORAL_BOOSTS;
                                        gameLog.push(`${aiLabel} succeeded with Moral Boost! +2 moves next round.`);
                                        // If this was the 3rd moral boost, show BARRAGE READY popup
                                        if (justUnlockedBarrage) {
                                            setTimeout(() => {
                                                showWarcryAchievementPopup('B', { title: 'BARRAGE READY', subtitle: 'Artillery Unlocked' });
                                            }, 1800); // Show after coin flip popup closes
                                        }
                                    } else {
                                        gameLog.push(`${aiLabel} failed to inspire a Moral Boost.`);
                                    }
                                    lastAction = { special: 'moralBoost' };
                                    movedPieces.add(`${kingRow},${kingCol}`);
                                    highlightSquares = [];
                                    selectedPiece = null;
                                    validMoves = [];
                                    renderBoard();
                                    updateStatus();
                                    updateEndTurnButton();
                                    updateGameLog();
                                    checkGameOver();
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true,
                                false
                            );
                            return;
                        }
                    }

                const canExecuteAction = (candidate) => {
                    if (!candidate) return false;
                    const cost = typeof candidate.cost === 'number' ? candidate.cost : 1;
                    if (cost > movesLeft) return false;
                    if (candidate.from) {
                        const [fr, fc] = candidate.from;
                        const piece = board[fr] && board[fr][fc];
                        if (!piece || piece.player !== 'B') return false;
                    }
                    if (candidate.type === 'move' && candidate.pos) {
                        const targetRow = candidate.pos[0];
                        const targetCol = candidate.pos[1];
                        const targetPiece = board[targetRow] && board[targetRow][targetCol];
                        if (targetPiece && targetPiece.player === 'B') return false;
                    }
                    if ((candidate.type === 'turn' || candidate.type === 'turnAndMove' || candidate.type === 'turnAndShoot') && candidate.pos) {
                        const turnRow = candidate.pos[0];
                        const turnCol = candidate.pos[1];
                        const turnPiece = board[turnRow] && board[turnRow][turnCol];
                        if (!turnPiece || turnPiece.player !== 'B') return false;
                    }
                    return true;
                };

                let action = null;

                if (plannedActions.length > 0) {
                    action = plannedActions.shift();
                    if (!canExecuteAction(action)) {
                        action = null;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    aiSearchDeadline = Date.now() + getAiTimeBudget();
                    const result = minimax(board, aiMaxDepth, true, 'B', movesLeft, movedPieces, capturedPieces, scores, -Infinity, Infinity, championsOnBackRow);
                    if (result.sequence && result.sequence.length) {
                        action = result.sequence[0];
                        plannedActions = result.sequence.slice(1);
                        if (plannedActions.length > 3) {
                            plannedActions.length = 3;
                        }
                    } else {
                        action = result.action;
                        plannedActions = [];
                    }
                    if (!canExecuteAction(action)) {
                        action = null;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const energyBlastAction = findAiEnergyBlastOpportunity('B', movesLeft, movedPieces);
                    if (energyBlastAction) {
                        action = energyBlastAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const sacrificeAction = findAiSacrificeOpportunity('B', movesLeft, movedPieces);
                    if (sacrificeAction) {
                        action = sacrificeAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const championSummonAction = findAiChampionSummonOpportunity('B', movesLeft, movedPieces);
                    if (championSummonAction) {
                        action = championSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const kingSummonAction = findKingSummonOpportunity('B', movesLeft, movedPieces);
                    if (kingSummonAction) {
                        action = kingSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const zombieSummonAction = findAiZombieSummonOpportunity('B', movesLeft, movedPieces);
                    if (zombieSummonAction) {
                        action = zombieSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const undeadSummonAction = findAiUndeadSummonOpportunity('B', movesLeft, movedPieces);
                    if (undeadSummonAction) {
                        action = undeadSummonAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const huntsmanBurstAction = findAiHuntsmanBurstOpportunity('B', movesLeft, movedPieces);
                    if (huntsmanBurstAction) {
                        action = huntsmanBurstAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const barrageAction = findAiBarrageOpportunity('B', movesLeft, movedPieces);
                    if (barrageAction) {
                        action = barrageAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    const tripleShotAction = findAiElephantryTripleShotOpportunity('B', movesLeft, movedPieces);
                    if (tripleShotAction) {
                        action = tripleShotAction;
                        plannedActions = [];
                    }
                }

                if (!action) {
                    plannedActions = [];
                    action = findSimpleAIAction('B', movesLeft, movedPieces);
                }

                if (!canExecuteAction(action)) {
                    action = null;
                }

                    if (aiTurnTimeoutForced) {
                        aiTurnTimeoutForced = false;
                        movesLeft = 0;
                        plannedActions = [];
                        action = null;
                    }

                    if (!action) {
                        // Special case: if AI has exactly 1 move point left, try to use it on low-value pieces
                        if (movesLeft === 1) {
                            action = findLowValuePieceMove('B', movedPieces);
                        }

                        // If still no action, end turn
                        if (!action) {
                            highlightSquares = [];
                            plannedActions = [];
                            completeAiTurn();
                            return;
                        }
                    }
                    
                    highlightSquares = [];
                    if (action.type === 'move' || action.type === 'shoot' || action.type === 'swap' || action.type === 'teleport' || action.type === 'teleportSwap' || action.type === 'activate' || action.type === 'summon' || action.type === 'energyBlast' || action.type === 'huntsmanBurst') {
                        const { from, pos, cost, jump, special, direction } = action;
                        if (action.type === 'energyBlast') {
                            highlightSquares = from ? [from] : [];
                        } else {
                            const targets = [];
                            if (from) targets.push(from);
                            if (pos) targets.push(pos);
                            highlightSquares = targets;
                        }
                        if (action.type === 'summon' && special === 'summonSpectre') {
                            // AI attempts to summon Spectre
                            const wizardRow = from[0], wizardCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${wizardRow},${wizardCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Spectre',
                                'AI is attempting to summon a Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Spectre
                                        board[summonRow][summonCol] = { type: 'Spectre', player: 'B' };
                                        spectresSummoned['B']++;
                                        wizardSummonedThisTurn['B'] = true;
                                        wizardCannotMoveNextTurn['B'].add(`${wizardRow},${wizardCol}`);

                                        // Award 3 bonus points for successful summoning
                                        scores['B'] += 3;

                                        gameLog.push(`AI summoned a Spectre at ${formatBoardCoordinates(summonRow,summonCol)}! (+3 bonus points)`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Spectre.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true, // Automated mode
                                false // showOverlay
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonZombie') {
                            // AI attempts to summon Zombie (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Zombie',
                                'AI is attempting to summon a Zombie...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Zombie
                                        const zombiePiece = createZombiePiece('B');
                                        board[summonRow][summonCol] = zombiePiece;
                                        zombiesSummoned['B'] = (zombiesSummoned['B'] || 0) + 1;

                                        gameLog.push(`AI summoned a Zombie at ${formatBoardCoordinates(summonRow,summonCol)}!`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Zombie.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true, // Automated mode
                                false // showOverlay
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonNecromancerLich') {
                            // AI attempts to summon Lich (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            performCoinToss(
                                'Summon Lich',
                                'AI is attempting to summon a Lich...',
                                (success) => {
                                    if (success) {
                                        if (!board[summonRow][summonCol]) {
                                            board[summonRow][summonCol] = { type: 'Lich', player: 'B' };
                                            lichesSummoned['B'] = (lichesSummoned['B'] || 0) + 1;
                                            gameStats.summonCount['B']++;
                                            gameLog.push(`${getOpponentDisplayName()} summoned a Lich at ${formatBoardCoordinates(summonRow,summonCol)}.`);
                                        } else {
                                            gameLog.push(`${getOpponentDisplayName()}'s Lich summon succeeded but the square was occupied.`);
                                        }
                                    } else {
                                        gameLog.push(`${getOpponentDisplayName()} failed to summon a Lich.`);
                                    }

                                    renderBoard();
                                    updateScoreDisplay();
                                    updateGameLog();
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'summon' && special === 'summonNecromancerSpectre') {
                            // AI attempts to summon Spectre (Necromancer)
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            // Deduct cost before coin toss
                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            // Show automated coin toss popup for AI
                            performCoinToss(
                                'Summon Spectre',
                                'AI is attempting to summon a Spectre...',
                                (success) => {
                                    if (success) {
                                        // Successfully summoned Spectre
                                        const spectrePiece = createSpectrePiece('B');
                                        board[summonRow][summonCol] = spectrePiece;
                                       spectresSummoned['B'] = (spectresSummoned['B'] || 0) + 1;

                                        gameLog.push(`AI summoned a Spectre at ${formatBoardCoordinates(summonRow,summonCol)}!`);
                                    } else {
                                        // Failed summoning
                                        gameLog.push(`AI failed to summon a Spectre.`);
                                    }

                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();

                                    // Continue AI turn
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true, // Automated mode
                                false // showOverlay
                            );
                            return; // Exit to wait for coin toss callback
                        } else if (action.type === 'summon' && special === 'summonNecromancerUndead') {
                            const necromancerRow = from[0], necromancerCol = from[1];
                            const summonRow = pos[0], summonCol = pos[1];

                            movesLeft -= cost;
                            movedPieces.add(`${necromancerRow},${necromancerCol}`);

                            performCoinToss(
                                'Summon Undead',
                                'AI is attempting to summon an Undead...',
                                (success) => {
                                    if (success) {
                                        const summonerType = board[necromancerRow][necromancerCol]?.type || 'Necromancer';
                                        const undeadLives = UNDEAD_LIVES_BY_SUMMONER[summonerType] || UNDEAD_LIVES_BY_SUMMONER['Necromancer'];
                                        const undeadPiece = createUndeadPiece('B', undeadLives, summonerType);
                                        if (!board[summonRow][summonCol]) {
                                            board[summonRow][summonCol] = undeadPiece;
                                            undeadSummoned['B'] = (undeadSummoned['B'] || 0) + 1;
                                            gameStats.summonCount['B']++;
                                            gameLog.push(`${getOpponentDisplayName()} summoned an Undead at ${formatBoardCoordinates(summonRow,summonCol)}!`);
                                        } else {
                                            gameLog.push(`${getOpponentDisplayName()}'s Undead summon succeeded but the square was occupied.`);
                                        }
                                    } else {
                                        gameLog.push(`${getOpponentDisplayName()} failed to summon an Undead.`);
                                    }
                                    renderBoard();
                                    updateGameLog();
                                    updateScoreDisplay();
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (special === 'darkVoid') {
                            const casterRow = from[0], casterCol = from[1];
                            const targetRow = pos[0], targetCol = pos[1];
                            movesLeft -= cost;
                            movedPieces.add(`${casterRow},${casterCol}`);
                            const occupant = board[targetRow][targetCol];
                            if (occupant) {
                                capturePieceForZombie('B', targetRow, targetCol, occupant);
                            }
                            board[targetRow][targetCol] = { type: 'DarkVoid' };
                            darkVoidSquares.add(darkVoidKey(targetRow, targetCol));
                            darkVoidUses['B'] = (darkVoidUses['B'] || 0) + 1;
                            gameLog.push(`${getOpponentDisplayName()} unleashed a Dark Void at ${formatBoardCoordinates(targetRow, targetCol)}.`);
                            renderBoard();
                            updateGameLog();
                            updateScoreDisplay();
                            updateCapturedPiecesDisplay();
                            updateStatus();
                            updateEndTurnButton();
                            setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                            return;
                        } else if (action.type === 'energyBlast') {
                            const scheduleNextMove = () => setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                            if (!from || !direction) {
                                scheduleNextMove();
                                return;
                            }
                            const [casterRow, casterCol] = from;
                            const casterPiece = board[casterRow] && board[casterRow][casterCol];
                            if (!casterPiece || casterPiece.player !== 'B' || !isSpellVariant() || !isSpellCasterPiece(casterPiece)) {
                                scheduleNextMove();
                                return;
                            }
                            const uses = energyBlastUsage.get(casterPiece) || 0;
                            if (uses >= 2) {
                                scheduleNextMove();
                                return;
                            }
                            const spellCost = uses === 0 ? 2 : 3;
                            if (movesLeft < spellCost) {
                                scheduleNextMove();
                                return;
                            }
                            const prepaidCost = Math.min(2, spellCost);
                            movesLeft -= prepaidCost;
                            updateStatus();
                            updateEndTurnButton();
                            gameLog.push('AI is channeling Energy Blast (2 move points spent to attempt spellcasting).');
                            updateGameLog();
                            coinTossSpecialEffect = 'energy-blast';
                            performCoinToss(
                                'Energy Blast',
                                'AI is attempting to channel spell energy...',
                                (success) => {
                                    if (!success) {
                                        gameLog.push('AI failed to channel Energy Blast.');
                                        updateGameLog();
                                        scheduleNextMove();
                                        return;
                                    }
                                    const currentPiece = board[casterRow]?.[casterCol];
                                    if (!currentPiece || currentPiece.player !== 'B') {
                                        removeEnergyBlastGlow();
                                        scheduleNextMove();
                                        return;
                                    }
                                    activeEnergyBlastCost = { row: casterRow, col: casterCol, prepaid: prepaidCost, cost: spellCost };
                                    applyEnergyBlastGlow();
                                    gameLog.push('AI successfully channeled Energy Blast!');
                                    updateGameLog();
                                    pendingAiEnergyBlastResume = () => setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                    performEnergyBlast(casterRow, casterCol, direction);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'sacrifice') {
                            if (!from) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const [sRow, sCol] = from;
                            const caster = board[sRow]?.[sCol];
                            if (!caster || caster.player !== 'B' || !isSpellCasterPiece(caster) || movesLeft < cost) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (sacrificeAttemptedPieces.has(caster)) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            sacrificeAttemptedPieces.add(caster);
                            performCoinToss(
                                'Sacrifice',
                                'AI is attempting Sacrifice...',
                                (success) => {
                                    if (!success) {
                                        gameLog.push('AI failed the Sacrifice coin flip.');
                                        updateGameLog();
                                        setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                        return;
                                    }
                                    if (movesLeft < cost) {
                                        gameLog.push('AI lacked the move points to complete Sacrifice.');
                                        updateGameLog();
                                        setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                        return;
                                    }
                                    executeSacrifice(sRow, sCol, {
                                        onComplete: () => setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000)
                                    });
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'summon' && special === 'kingSummon') {
                            const kingRow = from[0], kingCol = from[1];
                            const kingPiece = board[kingRow]?.[kingCol];
                            if (!kingPiece || kingPiece.player !== 'B' || kingPiece.type !== 'King') {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const summonRow = pos[0], summonCol = pos[1];
                            const summonType = action.summonType || 'Pistolier';
                            movesLeft -= cost;
                            const attemptLabel = `Summon ${summonType}`;
                            performCoinToss(
                                attemptLabel,
                                `AI attempts to summon a ${summonType}...`,
                                (success) => {
                                    if (success) {
                                        if (!board[summonRow][summonCol]) {
                                            const needsFacing = turnablePieces.includes(summonType);
                                            const facing = needsFacing ? 'D' : null;
                                            board[summonRow][summonCol] = { type: summonType, player: 'B', facing };
                                            if (summonType === 'Pistolier') {
                                                pistoliersSummoned['B'] = (pistoliersSummoned['B'] || 0) + 1;
                                            } else if (summonType === 'Fusilier') {
                                                fusiliersSummoned['B'] = (fusiliersSummoned['B'] || 0) + 1;
                                            }
                                            gameStats.summonCount['B']++;
                                            gameLog.push(`${getOpponentDisplayName()} summoned a ${summonType} at ${formatBoardCoordinates(summonRow,summonCol)}.`);
                                        } else {
                                            gameLog.push(`${getOpponentDisplayName()}'s ${summonType} summon succeeded but the square was occupied.`);
                                        }
                                    } else {
                                        gameLog.push(`${getOpponentDisplayName()} failed to summon a ${summonType}.`);
                                    }
                                    updateGameLog();
                                    lastAction = { move: true };
                                    movedPieces.add(`${kingRow},${kingCol}`);
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'summon' && special === 'championSummon') {
                            if (!from || !pos) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const championRow = from[0];
                            const championCol = from[1];
                            const championPiece = board[championRow]?.[championCol];
                            if (!championPiece || championPiece.player !== 'B' || championPiece.type !== 'Champion') {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (movesLeft < cost) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const summonRow = pos[0];
                            const summonCol = pos[1];
                            const summonType = action.summonType || 'Necromancer';
                            if (summonType === 'Necromancer' && !canChampionSummonNecromancer(championPiece.player)) {
                                gameLog.push(`${getOpponentDisplayName()} cannot summon a Necromancer yet.`);
                                updateGameLog();
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            movesLeft -= cost;
                            performCoinToss(
                                'Champion Summon',
                                `AI attempts to summon a ${summonType}...`,
                                (success) => {
                                    if (success) {
                                        if (!board[summonRow][summonCol]) {
                                            if (summonType === 'Huntsman') {
                                                board[summonRow][summonCol] = { type: 'Huntsman', player: 'B' };
                                                recordHuntsmanSpawn('B');
                                                gameLog.push(`${getOpponentDisplayName()} summoned a Huntsman at ${formatBoardCoordinates(summonRow,summonCol)}.`);
                                            } else {
                                                const necromancerPiece = { type: 'Necromancer', player: 'B', facing: null };
                                                board[summonRow][summonCol] = necromancerPiece;
                                                necromancersSummoned['B'] = (necromancersSummoned['B'] || 0) + 1;
                                                necromancerTeleportCounts.set(necromancerPiece, 0);
                                                setNecromancerShotCooldown(necromancerPiece, 0);
                                                gameLog.push(`${getOpponentDisplayName()} summoned a Necromancer at ${formatBoardCoordinates(summonRow,summonCol)}.`);
                                            }
                                            gameStats.summonCount['B']++;
                                        } else {
                                            gameLog.push(`AI's ${summonType} summon succeeded but the chosen square was blocked.`);
                                        }
                                    } else {
                                        gameLog.push(`AI failed to summon a ${summonType}.`);
                                    }
                                    updateGameLog();
                                    lastAction = { move: true };
                                    movedPieces.add(`${championRow},${championCol}`);
                                    setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                },
                                true,
                                false
                            );
                            return;
                        } else if (action.type === 'huntsmanBurst') {
                            if (!from) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const [burstRow, burstCol] = from;
                            const huntsman = board[burstRow]?.[burstCol];
                            if (!huntsman || huntsman.player !== 'B' || huntsman.type !== 'Huntsman' || !isSpellVariant()) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (movesLeft < cost || pendingHuntsmanBurst) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            highlightSquares = [from];
                            movesLeft -= cost;
                            updateStatus();
                            updateEndTurnButton();
                            beginHuntsmanBurstSequence(burstRow, burstCol, 'B', {
                                automated: true,
                                onComplete: () => setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000)
                            });
                            return;
                        } else if (action.type === 'move') {
                            // Check if capturing a Spectre - requires coin toss
                            const targetPiece = board[pos[0]][pos[1]];
                            const attackingPiece = board[from[0]][from[1]];
                            const isCapturingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                            const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                            const isTargetUndead = targetPiece && (isUndeadType(targetPiece) || isUndeadChampionType(targetPiece)) && targetPiece.player !== attackingPiece.player;
                            const isAttackingUndead = attackingPiece && (isUndeadType(attackingPiece) || isUndeadChampionType(attackingPiece)) && targetPiece && targetPiece.player !== attackingPiece.player;
                            const actionCost = typeof action.cost === 'number' ? action.cost : 1;

                            if ((isTargetUndead || isAttackingUndead) && action.type === 'move') {
                                const fromRow = from[0];
                                const fromCol = from[1];
                                const toRow = pos[0];
                                const toCol = pos[1];
                                movesLeft -= actionCost;
                                const coinTitle = isTargetUndead ? 'Undead Defense' : 'Undead Capture';
                                const coinMessage = isTargetUndead
                                    ? 'AI is attempting to capture the Undead...'
                                    : 'AI Undead attempts to capture the enemy piece...';
                                performCoinToss(
                                    coinTitle,
                                    coinMessage,
                                    (success) => {
                                        if (isTargetUndead) {
                                            if (!success) {
                                                handleUndeadDefense(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, false);
                                                renderBoard();
                                                updateGameLog();
                                                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                                return;
                                            }
                                            const defenseResult = handleUndeadDefense(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, true);
                                            if (defenseResult?.attackerRemoved || defenseResult?.undeadDamaged) {
                                                renderBoard();
                                                updateGameLog();
                                                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                                return;
                                            }
                                        } else {
                                            if (!success) {
                                                attemptUndeadCapture(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, false);
                                                renderBoard();
                                                updateGameLog();
                                                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                                return;
                                            }
                                            attemptUndeadCapture(attackingPiece, targetPiece, fromRow, fromCol, toRow, toCol, true);
                                        }
                                        const moveResult = movePiece(fromRow, fromCol, toRow, toCol, jump);
                                        completeAiMove(action, moveResult);
                                    },
                                    true,
                                    false
                                );
                                return;
                            }

                            if (isCapturingSpectre && !captureExempt) {
                                // Deduct cost before coin toss
                                movesLeft -= actionCost;

                                // Show automated coin toss popup for AI
                                performCoinToss(
                                    'Capture Spectre',
                                    'AI is attempting to capture the Spectre...',
                                    (success) => {
                                        let moveResult = null;
                                        if (success) {
                                            moveResult = movePiece(from[0], from[1], pos[0], pos[1], jump);
                                            gameLog.push(`AI successfully captured the Spectre!`);
                                        } else {
                                            gameLog.push(`AI failed to capture the Spectre.`);
                                            renderBoard();
                                            updateGameLog();
                                            setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                            return;
                                        }

                                        completeAiMove(action, moveResult);
                                    },
                                    true, // Automated mode
                                    false // showOverlay
                                );
                                return; // Exit to wait for coin toss callback
                            } else {
                                movesLeft -= actionCost;
                                if (special === 'elephantryCharge' && Array.isArray(action.captures)) {
                                    for (const capture of action.captures) {
                                        const captureRow = capture[0];
                                        const captureCol = capture[1];
                                        if (captureRow === undefined || captureCol === undefined) continue;
                                        const occupant = board[captureRow]?.[captureCol];
                                        if (!occupant) continue;
                                        applySpellCapture('B', captureRow, captureCol, {
                                            ability: 'Elephantry Charge',
                                            logMessage: `AI Elephantry charge captured ${occupant.type} at ${formatBoardCoordinates(captureRow,captureCol)}.`
                                        });
                                    }
                                }
                                const moveResult = movePiece(from[0], from[1], pos[0], pos[1], jump);
                                if (special === 'elephantryMoveShoot') {
                                    handleAiElephantryMoveShoot(action, moveResult, pos[0], pos[1]);
                                    return;
                                }
                                completeAiMove(action, moveResult);
                                return;
                            }
                        } else if (action.type === 'shoot') {
                            // Check if shooting a Spectre - requires coin toss
                        const targetPiece = board[pos[0]][pos[1]];
                        const attackingPiece = board[from[0]][from[1]];
                        const isShootingSpectre = targetPiece && targetPiece.type === 'Spectre' && targetPiece.player !== attackingPiece.player;
                        const captureExempt = attackingPiece.type === 'Wizard' || attackingPiece.type === 'Spectre';
                        const autoCrackShot = special === 'fusilierCrackShotAuto';
                        const usingCrackShot = attackingPiece && attackingPiece.type === 'Fusilier' && fusilierCrackShotActive === attackingPiece;
                        const isNecromancerShot = attackingPiece && attackingPiece.type === 'Necromancer' && special === 'necromancerShoot';

                        if (isShootingSpectre && !captureExempt) {
                            gameLog.push('AI cannot shoot Spectres. Target ignored.');
                            updateGameLog();
                            setTimeout(() => makeNextMove(), 400);
                            return;
                        } else if (autoCrackShot) {
                                movesLeft -= cost;

                                const pieceKey = `${from[0]},${from[1]},B`;
                                if (!(pieceKey in fusilierCrackShotCount)) {
                                    fusilierCrackShotCount[pieceKey] = 3;
                                }
                                if (fusilierCrackShotCount[pieceKey] > 0) {
                                    fusilierCrackShotCount[pieceKey]--;
                                }

                                performCoinToss(
                                    'Crack Shot',
                                    'AI is attempting a Crack Shot...',
                                    (success) => {
                                        fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                        fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);

                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI Fusilier Crack Shot hit!`);
                                        } else {
                                            gameLog.push(`AI Fusilier Crack Shot missed.`);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                    },
                                    true, // Automated mode
                                    false // showOverlay
                                );
                                return;
                            } else if (usingCrackShot) {
                                movesLeft -= cost;

                                performCoinToss(
                                    'Crack Shot',
                                    'AI is attempting a Crack Shot...',
                                    (success) => {
                                        fusilierShotThisTurn[attackingPiece.player].add(attackingPiece);
                                        fusilierShotLastTurn[attackingPiece.player].delete(attackingPiece);
                                        fusilierCrackShotActive = null;

                                        if (success) {
                                            shootPiece(from[0], from[1], pos[0], pos[1]);
                                            gameLog.push(`AI Fusilier Crack Shot hit!`);
                                        } else {
                                            gameLog.push(`AI Fusilier Crack Shot missed.`);
                                        }

                                        renderBoard();
                                        updateGameLog();

                                        // Continue AI turn
                                        setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                                    },
                                    true, // Automated mode
                                    false // showOverlay
                                );
                                return;
                            } else {
                                // Normal shoot
                                shootPiece(from[0], from[1], pos[0], pos[1]);
                            }

                            if (special === 'kingShot') {
                                markKingShotUsed(attackingPiece);
                            }

                            if (special === 'archerDiag2') {
                                archerDiag2ShootUsed['B']++;
                            }
                            if (isNecromancerShot) {
                                setNecromancerShotCooldown(attackingPiece, 2);
                            }
                        } else if (action.type === 'activate' && special === 'ballistaRange') {
                            // Extend range for Ballista this turn
                            ballistaRangeBoostActive['B'] = true;
                            ballistaRangeBoostUsedThisTurn['B'] = true;
                            gameLog.push(`AI activated Ballista Extend Range (+1 range this round)`);
                        } else if (action.type === 'swap') {
                            const kingRow = from[0], kingCol = from[1];
                            const guardRow = pos[0], guardCol = pos[1];
                            const kingPiece = board[kingRow][kingCol];
                            const guardPiece = board[guardRow][guardCol];
                            board[guardRow][guardCol] = kingPiece;
                            board[kingRow][kingCol] = guardPiece;
                            kingSpecialUsed['B'] = true;
                            gameLog.push(`AI used Guard of Honour to swap King and Guard at ${formatBoardCoordinates(kingRow,kingCol)} and ${formatBoardCoordinates(guardRow,guardCol)}`);
                            checkSupremacy('B');
                            movedPieces.add(`${guardRow},${guardCol}`);
                        } else if (action.type === 'teleport') {
                            const wizardRow = from[0], wizardCol = from[1];
                            const newRow = pos[0], newCol = pos[1];
                            const teleportPiece = board[wizardRow][wizardCol];
                            const abilityLabel = `${teleportPiece.type} Teleport`;
                            const result = teleportOntoSquare(wizardRow, wizardCol, newRow, newCol, 'B', abilityLabel);
                            if (!result.success) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            if (teleportPiece.type === 'Wizard') {
                                wizardTeleportUsed['B']++;
                                gameLog.push(`AI teleported Wizard from ${formatBoardCoordinates(wizardRow,wizardCol)} to ${formatBoardCoordinates(newRow,newCol)}`);
                            } else if (teleportPiece.type === 'Necromancer') {
                                incrementNecromancerTeleportCount(teleportPiece);
                                gameLog.push(`AI teleported Necromancer from ${formatBoardCoordinates(wizardRow,wizardCol)} to ${formatBoardCoordinates(newRow,newCol)}`);
                            } else {
                                gameLog.push(`AI teleported ${teleportPiece.type} from ${formatBoardCoordinates(wizardRow,wizardCol)} to ${formatBoardCoordinates(newRow,newCol)}`);
                            }
                            movedPieces.add(`${newRow},${newCol}`);
                        } else if (action.type === 'teleportSwap') {
                            const playerWizardRow = from[0], playerWizardCol = from[1];
                            const opponentWizardRow = pos[0], opponentWizardCol = pos[1];
                            const playerWizard = board[playerWizardRow][playerWizardCol];
                            const opponentWizard = board[opponentWizardRow][opponentWizardCol];
                            board[opponentWizardRow][opponentWizardCol] = playerWizard;
                            board[playerWizardRow][playerWizardCol] = opponentWizard;
                            wizardTeleportSwapUsed['B'] = true;
                            gameLog.push(`AI used Teleport Swap to swap Wizard at ${formatBoardCoordinates(playerWizardRow,playerWizardCol)} with opponent's Wizard at ${formatBoardCoordinates(opponentWizardRow,opponentWizardCol)}`);
                            movedPieces.add(`${opponentWizardRow},${opponentWizardCol}`);
                        } else if (action.type === 'elephantryTripleShot') {
                            executeAiElephantryTripleShot(action);
                            return;
                        } else if (action.type === 'barrage') {
                            if (gameVariant !== '36s-supreme') {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            const barrageCost = typeof cost === 'number' ? cost : BARRAGE_COST;
                            const [casterRow, casterCol] = from || [];
                            const casterPiece = board[casterRow]?.[casterCol];
                            if (!casterPiece || (casterPiece.type !== 'Champion' && casterPiece.type !== 'King')) {
                                setTimeout(() => makeNextMove(), 400);
                                return;
                            }
                            highlightSquares = [[casterRow, casterCol]];
                            movesLeft = Math.max(0, movesLeft - barrageCost);
                            movedPieces.add(`${casterRow},${casterCol}`);
                            lastAction = { special: 'barrage' };
                            registerBarrageUse('B');
                            updateStatus();
                            updateEndTurnButton();
                            beginBlockingAction('barrage');
                            const targets = getRandomBarrageTargets(BARRAGE_TARGET_COUNT);
                            performBarrageShots(casterPiece, targets, null, 0, {
                                onComplete: () => {
                                    highlightSquares = [];
                                    if (!gameOver && movesLeft > 0) {
                                        setTimeout(() => makeNextMove(), 400);
                                    }
                                }
                            });
                            return;
                        }
                        movesLeft -= cost;
                        movedPieces.add(`${from[0]},${from[1]}`);
                    } else if (action.type === 'turn') {
                        const { pos, facing, cost } = action;
                        highlightSquares = [pos];
                        turnPiece(pos[0], pos[1], facing);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (action.type === 'turnAndMove') {
                        const { pos, facing, move, cost, jump } = action;
                        highlightSquares = [pos, move];
                        turnPiece(pos[0], pos[1], facing);
                        const moveResult = movePiece(pos[0], pos[1], move[0], move[1], jump);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                        movedPieces.add(`${move[0]},${move[1]}`);

                        // Check if mercenary coin flip is needed
                        if (moveResult?.mercenaryFlipNeeded) {
                            const mercPiece = moveResult.mercenaryPiece;
                            const mercPos = moveResult.mercenaryPos;

                            handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                // Continue AI turn after coin flip
                                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                            });
                            return; // Exit to wait for coin flip callback
                        }
                    } else if (action.type === 'turnAndShoot') {
                        const { pos, facing, shoot, cost } = action;
                        highlightSquares = [pos, shoot];
                        turnPiece(pos[0], pos[1], facing);
                        shootPiece(pos[0], pos[1], shoot[0], shoot[1]);
                        movesLeft -= cost;
                        movedPieces.add(`${pos[0]},${pos[1]}`);
                    } else if (action.type === 'archerMoveDiagShoot') {
                        const { from, move, shoot, cost } = action;
                        highlightSquares = [from, move, shoot];
                        const moveResult = movePiece(from[0], from[1], move[0], move[1]);
                        shootPiece(move[0], move[1], shoot[0], shoot[1]);
                        archerMoveDiagShootUsed['B']++;
                        movesLeft -= cost;
                        movedPieces.add(`${move[0]},${move[1]}`);

                        // Check if mercenary coin flip is needed
                        if (moveResult?.mercenaryFlipNeeded) {
                            const mercPiece = moveResult.mercenaryPiece;
                            const mercPos = moveResult.mercenaryPos;

                            handleMercenaryCoinFlip(mercPiece.player, mercPiece, mercPos.row, mercPos.col, (bonusTurnGranted) => {
                                // Continue AI turn after coin flip
                                setTimeout(() => makeNextMove(), 3000 + Math.random() * 4000);
                            });
                            return; // Exit to wait for coin flip callback
                        }
                    }

                    renderBoard();
                    updateStatus();
                    updateEndTurnButton();
                    updateGameLog();
                    checkGameOver();
                    
                    // Shorter delays for faster AI play
                    setTimeout(() => {
                        try {
                            highlightSquares = [];
                            renderBoard();
                            setTimeout(() => {
                                try {
                                    makeNextMove();
                                } catch (err) {
                                    console.error('AI move loop failed:', err);
                                    completeAiTurn({ reason: 'AI move error. Player resumes round.' });
                                }
                            }, 1000); // Make next move
                        } catch (err) {
                            console.error('AI post-move cleanup failed:', err);
                            completeAiTurn({ reason: 'AI move error. Player resumes round.' });
                        }
                    }, 1200); // Highlight duration
                } catch (err) {
                    console.error('AI move evaluation failed:', err);
                    completeAiTurn({ reason: 'AI move error. Player resumes round.' });
                }
            }
            // Use variable delay (1-2 seconds) before AI starts making moves
            setTimeout(() => makeNextMove(), aiStartDelay);
        }

        function resetGame() {
            // Initialize all game state variables first
            gameOver = false; // Reset game over flag
            currentPlayer = 'W'; // Will be set by coin toss
            roundCount = 1; // Reset round counter
            playerRoundNumber = 0; // Reset player round counter
            aiRoundNumber = 0; // Reset AI round counter
            gameRound = 1; // Reset game round counter
            firstPlayer = null; // Reset first player tracker
            closeDarkVoidPopup();
            selectedPiece = null;
            validMoves = [];
            movedPieces.clear();
            reinforcementPending = null;
            aiPending = false;
            stopGameTimer();
            stopTurnTimer();
            aiTurnTimeoutForced = false;
            movesLeft = 0;
            initialMovesLeft = 0;
            capturedPieces = { 'W': [], 'B': [] };
            championCaptured = { 'W': false, 'B': false };
            championsOnBackRow = { 'W': [], 'B': [] };
            scores = { 'W': 0, 'B': 0 };
            firstMoves.clear();
            gameLog = [];
            isFirstPlayerTurn = true;
            lastAction = null;
            turnAndShootMode = false;
            turnAndMoveMode = false;
            guardOfHonourMode = false;
            teleportMode = false;
            teleportSwapMode = false;
            chargeMode = false;
            infernoMode = false;
            strafeMode = false;
            summonSpectreMode = false;
            archerMoveDiagMode = false;
            archerDiagShootSelectMode = false;
            archerDiag2ShootMode = false;
            elephantryChargeMode = false;
            elephantryExtendedRangeActive = false;
            fusilierCrackShotActive = null;
            elephantryMoveShootMode = false;
            elephantryMoveShootPosition = null;
            pistolierMoveShootMode = false;
            pistolierMoveShootPosition = null;
            archerMoveDiagStart = null;
            highlightSquares = [];
            pendingSpellAction = null;
            energyBlastUsage = new Map();
            energyBlastUses = { 'W': 0, 'B': 0 };
            sacrificeAttemptedPieces = new Set();
            energyBlastFlipContext = null;
            pendingEnergyBlast = null;
            activeEnergyBlastCost = null;
            energyBlastGlowActive = false;
            energyBlastResidualSquares = new Map();
            energyBlastFlipPauseState = null;
            coinTossEnergyBlastMode = null;
            coinTossSpecialEffect = null;
            pendingAiEnergyBlastResume = null;
            pendingWarcryCelebrations = [];
            captureEffectActiveUntil = 0;
            if (warcryPopupTimeoutId) {
                clearTimeout(warcryPopupTimeoutId);
                warcryPopupTimeoutId = null;
            }
            protectionUsed = { 'W': false, 'B': false };
            pendingProtection = null;
            kingSpecialUsed = { 'W': false, 'B': false };
            wizardTeleportUsed = { 'W': 0, 'B': 0 };
            wizardTeleportSwapUsed = { 'W': false, 'B': false };
            cavalryChargeUsed = { 'W': false, 'B': false };
            dragonInfernoUsed = { 'W': false, 'B': false };
            ogreRageUsed = { 'W': false, 'B': false };
            wizardStrafeUsed = { 'W': 0, 'B': 0 };
            dragonStrafeUsed = { 'W': 0, 'B': 0 };
            pistoliersSummoned = { 'W': 0, 'B': 0 };
            fusiliersSummoned = { 'W': 0, 'B': 0 };
            lichesSummoned = { 'W': 0, 'B': 0 };
            fusilierShotLastTurn = { 'W': new Set(), 'B': new Set() };
            fusilierShotThisTurn = { 'W': new Set(), 'B': new Set() };
            mercenaryBonusTurnUsed = { 'W': new Set(), 'B': new Set() };
            mercenaryBonusTurnCount = { 'W': 0, 'B': 0 };
            deactivateMercenaryBonusTurn();
            spectresSummoned = { 'W': 0, 'B': 0 };
            wizardSummonedThisTurn = { 'W': false, 'B': false };
            wizardCannotMoveNextTurn = { 'W': new Set(), 'B': new Set() };
            wizardSacrificedByPlayer = { 'W': false, 'B': false };
            necromancersSummoned = { 'W': 0, 'B': 0 };
            huntsmenSummoned = { 'W': 0, 'B': 0 };
            huntsmenOnBoard = { 'W': 0, 'B': 0 };
            huntsmanBurstMode = null;
            pendingHuntsmanBurst = null;
            huntsmanBurstPauseState = null;
            kingShotMode = null;
            kingEvadeMode = null;
            moralBoostUses = { 'W': 0, 'B': 0 };
            moralBoostSuccesses = { 'W': 0, 'B': 0 };
            barrageUses = { 'W': 0, 'B': 0 };
            kingShotUsed = { 'W': false, 'B': false };
            kingEvadeUsed = { 'W': false, 'B': false };
            resetKingShotFlags();
            championSummonMode = null;
            necromancerSummonMode = null;
            necromancerTeleportCounts = new Map();
            necromancerShootCooldown = new Map();
            undeadChampionsSummoned = { 'W': 0, 'B': 0 };
            undeadChampionTeleportUsed = new WeakSet();
            undeadChampionRangedCooldown = new Map();
            darkVoidUses = { 'W': 0, 'B': 0 };
            darkVoidSquares.clear();
            zombiesSummoned = { 'W': 0, 'B': 0 };
            undeadSummoned = { 'W': 0, 'B': 0 };
            zombiePendingAdvanceQueue = [];
            zombieAutoAdvanceInProgress = false;
            clearZombieCoinAnimations();
            clearDiceRollAnimations();
            if (zombieAdvanceTimer) {
                clearTimeout(zombieAdvanceTimer);
                zombieAdvanceTimer = null;
            }
            zombieConversions = { 'W': 0, 'B': 0 };
            archerMoveDiagShootUsed = { 'W': 0, 'B': 0 };
            archerDiag2ShootUsed = { 'W': 0, 'B': 0 };
            ballistaRangeBoostActive = { 'W': false, 'B': false };
            ballistaRangeBoostUsedThisTurn = { 'W': false, 'B': false };
            ballistaDoubleTimeUsed = { 'W': 0, 'B': 0 };
            elephantryChargeUsed = new WeakSet();
            elephantryExtendedRangeShotsRemaining = {};
            capturedSquares = [];
            roundScoreGain = { 'W': 0, 'B': 0 };
            roundCaptureValue = { 'W': 0, 'B': 0 };
            roundLosses = { 'W': {}, 'B': {} };
            nextRoundModifier = { 'W': 0, 'B': 0 };
            reinforcementTotals = { 'W': 0, 'B': 0 };
            infantryReinforcements = { 'W': 0, 'B': 0 };
            truceAttempts = 0;
            truceDeclinedTurns = 0;
            truceEligible = true;
            trucePlayerVote = null;
            truceAIVote = null;
            gameTimeRemaining = GAME_TIME_OPTIONS[selectedGameTimerKey];
            playerTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            aiTurnTimeRemaining = TURN_TIME_OPTIONS[selectedTurnTimerKey];
            updateTimerDisplay();
            removeEnergyBlastGlow();

            initBoard();
            showPieceInfo(null);
            const reinforceModal = document.getElementById('reinforce-modal');
            if (reinforceModal) reinforceModal.style.display = 'none';
            const turnModal = document.getElementById('turn-modal');
            if (turnModal) turnModal.style.display = 'none';
            const turnMoveModal = document.getElementById('turn-move-modal');
            if (turnMoveModal) turnMoveModal.style.display = 'none';
            const turnShootModal = document.getElementById('turn-shoot-modal');
            if (turnShootModal) turnShootModal.style.display = 'none';

            // Perform coin toss to determine starting player
            performCoinToss(
                'First Round',
                'Determining who goes first...',
                (playerWins) => {
                    if (playerWins) {
                        // Player (white) goes first
                        currentPlayer = 'W';
                        firstPlayer = 'W'; // Track who went first for round counting
                        gameLog.push('Player won the coin toss and goes first!');

                        const baseMoves = calculateBaseMoves('W');
                        movesLeft = baseMoves;
                        initialMovesLeft = baseMoves;

                        // Render board and update UI after coin toss
                        renderBoard();
                        updateScoreDisplay();
                        updateStatus();
                        updateGameLog();
                        updateCapturedPiecesDisplay();
                        updateEndTurnButton();

                        // Start timer after everything is set up
                        startGameTimer();
                        const startReady = applyStartTurnModifiers('W', baseMoves);

                        if (!startReady) {
                            checkGameOver();
                            setTimeout(() => triggerAiTurn(), 0);
                        }
                    } else {
                        // AI (black) goes first
                        currentPlayer = 'B';
                        firstPlayer = 'B'; // Track who went first for round counting
                        gameLog.push(`${getOpponentDisplayName()} won the coin toss and goes first!`);

                        const baseMoves = calculateBaseMoves('B');
                        movesLeft = baseMoves;
                        initialMovesLeft = baseMoves;

                        // Render board and update UI after coin toss
                        renderBoard();
                        updateScoreDisplay();
                        updateStatus();
                        updateGameLog();
                        updateCapturedPiecesDisplay();
                        updateEndTurnButton();

                        // Start timer after everything is set up
                        startGameTimer();

                        // Trigger AI turn after a brief delay
                        setTimeout(() => {
                            aiTurn();
                        }, 1500);
                    }
                }
            );
        }

        function updateStatus() {
            document.getElementById('status').textContent = `${currentPlayer === 'W' ? "Player" : "AI"}'s turn: ${movesLeft} moves remaining`;

            // Remove warcry active background when bonus moves are spent
            if (movesLeft <= baseMovesThisTurn) {
                removeWarcryActiveBackground();
            }

            // Explicitly check if round should end after status update
            if (!gamePaused && currentPlayer === 'W' && movesLeft <= 0 && !reinforcementPending && !aiPending) {
                setTimeout(() => triggerAiTurn(), 0);
            }
        }

        function endGame(winner, reason = '') {
            // Immediately set game over flag to prevent any further actions
            gameOver = true;

            stopGameTimer();
            stopTurnTimer();
            playerTurnTimeRemaining = 0;
            aiTurnTimeRemaining = 0;
            updateTimerDisplay();

            // Calculate game duration
            if (gameStats.gameStartTime !== null) {
                gameStats.gameDuration = Math.floor((Date.now() - gameStats.gameStartTime) / 1000);
            }

            // Prepare winner message and title
            let winnerText, reasonText, modalTitle;
            if (winner === 'draw') {
                winnerText = 'Draw!';
                modalTitle = 'Game Complete';

                // Create simplified draw reason text
                if (reason === 'Match') {
                    reasonText = 'Match';
                } else if (reason === 'Truce') {
                    reasonText = 'Truce';
                } else if (reason === 'Game timer expired.') {
                    reasonText = 'Supremacy';
                } else {
                    reasonText = reason || 'Draw';
                }
            } else {
                const winnerLabel = winner === 'W' ? 'Player' : getOpponentDisplayName();
                const loserLabel = winner === 'W' ? getOpponentDisplayName() : 'Player';
                winnerText = `${winnerLabel} Wins!`;

                // Set modal title based on whether player won or lost
                if (winner === 'W') {
                    modalTitle = 'Victory Achieved';
                } else {
                    modalTitle = 'All is Lost';
                }

                // Create simplified victory method text
                let victoryMethod = '';
                if (reason === 'Relentless') {
                    victoryMethod = 'Relentless';
                } else if (reason === 'Match') {
                    victoryMethod = 'Match';
                } else if (reason === 'Truce') {
                    victoryMethod = 'Truce';
                } else if (reason === 'Game timer expired.') {
                    victoryMethod = 'Supremacy';
                } else if (reason) {
                    victoryMethod = reason;
                } else {
                    // Default: assume it was Regicide (King captured)
                    victoryMethod = 'Regicide';
                }

                reasonText = `${winnerLabel} was victorious by ${victoryMethod}`;
            }

            // Add to game log
            const scoreSummary = `Final Score - Player: ${scores['W']}, ${getOpponentDisplayName()}: ${scores['B']}`;
            const message = `${winnerText} ${reasonText} ${scoreSummary}`;
            gameLog.push(message);
            updateGameLog();

            // Populate stats modal
            document.getElementById('game-stats-title').textContent = modalTitle;
            document.getElementById('stats-reason').textContent = reasonText;

            // Set player names in columns
            document.getElementById('stats-player-name').textContent = playerDisplayName;
            document.getElementById('stats-ai-name').textContent = getOpponentDisplayName();

            // Populate player stats
            document.getElementById('stats-player-score').textContent = scores['W'];
            document.getElementById('stats-player-warcry').textContent = gameStats.warcryBonusCount['W'];
            document.getElementById('stats-player-despair').textContent = gameStats.despairPenaltyCount['W'];
            document.getElementById('stats-player-captures').textContent = gameStats.mostCapturesInRound['W'];
            document.getElementById('stats-player-high-score').textContent = gameStats.highestScoreInRound['W'];
            document.getElementById('stats-player-summons').textContent = gameStats.summonCount['W'];
            document.getElementById('stats-player-reinforcements').textContent = gameStats.reinforcementCount['W'];

            // Populate AI stats
            document.getElementById('stats-ai-score').textContent = scores['B'];
            document.getElementById('stats-ai-warcry').textContent = gameStats.warcryBonusCount['B'];
            document.getElementById('stats-ai-despair').textContent = gameStats.despairPenaltyCount['B'];
            document.getElementById('stats-ai-captures').textContent = gameStats.mostCapturesInRound['B'];
            document.getElementById('stats-ai-high-score').textContent = gameStats.highestScoreInRound['B'];
            document.getElementById('stats-ai-summons').textContent = gameStats.summonCount['B'];
            document.getElementById('stats-ai-reinforcements').textContent = gameStats.reinforcementCount['B'];
            addHighScoreEntry(playerDisplayName, scores['W']);

            // Format and display game info
            const minutes = Math.floor(gameStats.gameDuration / 60);
            const seconds = gameStats.gameDuration % 60;
            const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('stats-turn-count').textContent = `Total Rounds: ${roundCount}`;
            document.getElementById('stats-duration').textContent = `Game Duration: ${durationStr}`;

            // Show stats modal
            document.getElementById('game-stats-modal').style.display = 'block';
            const endgameOverlay = document.getElementById('endgame-overlay');
            if (endgameOverlay) {
                endgameOverlay.style.display = 'block';
            }

            // Reset game pause state
            gamePaused = false;

            // Reset mercenary bonus turn state
            deactivateMercenaryBonusTurn();

            // Clear AI pending and other active game states
            aiPending = false;
            reinforcementPending = null;
        }

        function checkGameOver() {
            // First check for Match (only kings remaining)
            if (checkForMatch()) return;

            let wKing = false, bKing = false;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] && board[r][c].type === 'King') {
                        if (board[r][c].player === 'W') wKing = true;
                        else bKing = true;
                    }
                }
            }
            if (!wKing) endGame('B');
            else if (!bKing) endGame('W');
        }

        function updateEndTurnButton() {
            const endTurnButton = document.getElementById('end-turn-button');
            if (!endTurnButton) return;
            const noMovesSpent = movesLeft >= initialMovesLeft;
            const selectionActive = !!selectedPiece;
            endTurnButton.disabled = currentPlayer !== 'W' || noMovesSpent || selectionActive;
            // Update hint button visibility
            updateHintButton();
            // Safety net
            ensureAITurnIfNeeded();
        }

        function updateHintButton() {
            const hintButton = document.getElementById('hint-button');
            if (hintButton) {
                // Show hint button only if hint mode is enabled and it's the player's turn
                if (hintModeEnabled && currentPlayer === 'W' && movesLeft > 0) {
                    hintButton.style.display = 'inline-block';
                } else {
                    hintButton.style.display = 'none';
                }
            }
        }

        function showHint() {
            if (!hintModeEnabled || currentPlayer !== 'W') return;

            // Use simplified AI logic to find a good move
            // Pass current movesLeft and movedPieces to the function
            const action = findSimpleAIAction('W', movesLeft, movedPieces);

            if (!action) {
                alert('No valid moves available.');
                return;
            }

            // Extract coordinates from action object
            const fromRow = action.from[0];
            const fromCol = action.from[1];
            const toRow = action.pos[0];
            const toCol = action.pos[1];

            // Clear any existing highlights
            document.querySelectorAll('.hint-highlight').forEach(cell => {
                cell.classList.remove('hint-highlight');
            });

            // Highlight the suggested move
            const piece = board[fromRow][fromCol];
            const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const toCell = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);

            if (fromCell) {
                fromCell.classList.add('hint-highlight');
            }
            if (toCell) {
                toCell.classList.add('hint-highlight');
            }

            // Create hint message
            let hintMessage = `Move ${piece.type} from ${formatBoardCoordinates(fromRow,fromCol)} to ${formatBoardCoordinates(toRow,toCol)}`;

            if (action.turnDirection) {
                hintMessage += ` and turn ${action.turnDirection}`;
            }
            if (action.shoot) {
                hintMessage += ` and shoot`;
            }
            if (action.special) {
                hintMessage += ` using ${action.special}`;
            }

            // Remove any existing hint popup
            const existingPopup = document.getElementById('hint-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create a popup near the hinted piece
            const popup = document.createElement('div');
            popup.id = 'hint-popup';
            popup.textContent = hintMessage;
            popup.style.position = 'absolute';
            popup.style.backgroundColor = '#ffffcc';
            popup.style.border = '2px solid #ffcc00';
            popup.style.padding = '15px 20px';
            popup.style.borderRadius = '8px';
            popup.style.zIndex = '10000';
            popup.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.3)';
            popup.style.fontSize = '14px';
            popup.style.fontWeight = 'bold';
            popup.style.maxWidth = '300px';
            popup.style.wordWrap = 'break-word';

            // Position popup above the game board, centered
            const boardAnchor = getBoardAnchorRect();
            if (boardAnchor) {
                popup.style.left = `${boardAnchor.centerX}px`;
                popup.style.top = `${boardAnchor.top - 60}px`;
                popup.style.transform = 'translate(-50%, -100%)';
            } else {
                // Fallback to center of screen
                popup.style.left = '50%';
                popup.style.top = '20px';
                popup.style.transform = 'translateX(-50%)';
            }

            document.body.appendChild(popup);

            // Reset after 5 seconds
            setTimeout(() => {
                popup.remove();
                document.querySelectorAll('.hint-highlight').forEach(cell => {
                    cell.classList.remove('hint-highlight');
                });
            }, 5000);
        }

        function endTurn() {
            if (gameOver || gamePaused) return;
            if (movesLeft < initialMovesLeft) {
                // Reset player's per-turn Ballista boost on end turn
                ballistaRangeBoostActive['W'] = false;
                ballistaRangeBoostUsedThisTurn['W'] = false;
                // Remove warcry active background when turn ends
                removeWarcryActiveBackground();
                // Force turn transition
                movesLeft = 0;
                triggerAiTurn();
            }
        }

        function updateCapturedPiecesDisplay() {
            const playerCapturedDiv = document.getElementById('player-captured');
            const aiCapturedDiv = document.getElementById('ai-captured');
            playerCapturedDiv.innerHTML = getCapturedPiecesHTML('W');
            aiCapturedDiv.innerHTML = getCapturedPiecesHTML('B');
            const capturedContainer = document.getElementById('captured-pieces');
            constrainElementToBoardBounds(capturedContainer, getBoardAnchorRect());
        }

        function getCapturedPiecesHTML(player) {
            const pieces = capturedPieces[player];
            const counts = {};
            pieces.forEach(p => {
                counts[p.type] = (counts[p.type] || 0) + 1;
            });
            if (Object.keys(counts).length === 0) {
                return '<div class="captured-entry empty">No souls claimed</div>';
            }
            return Object.entries(counts)
                .sort((a, b) => (pieceValues[b[0]] || 0) - (pieceValues[a[0]] || 0))
                .map(([type, count]) => {
                    const soulLabel = count === 1 ? 'soul' : 'souls';
                    return `
                        <div class="captured-entry grave-slot">
                            <div class="grave-meta">
                                <span class="grave-name">${type}</span>
                                <span class="grave-count">${count} ${soulLabel}</span>
                            </div>
                        </div>
                    `;
                }).join('');
        }

        // New function to add capture effects
        function addCaptureEffect(row, col) {
            const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            const body = document.body;
            if (square) {
                captureEffectActiveUntil = Math.max(captureEffectActiveUntil, Date.now() + CAPTURE_EFFECT_SETTLE_MS);
                if (pendingWarcryCelebrations.length) {
                    scheduleNextWarcryPopup();
                }
                // Add square background color change
                square.classList.add('capture-background');
                // Add square overlay
                const overlay = document.createElement('div');
                overlay.className = 'capture-overlay';
                square.appendChild(overlay);
                // Add game background color change only if not already applied
                if (!body.classList.contains('capture-game-background')) {
                    body.classList.add('capture-game-background');
                    // Remove game background after 2 seconds
                    setTimeout(() => {
                        body.classList.remove('capture-game-background');
                    }, 2000);
                }
                // Remove square effects after 2 seconds
                setTimeout(() => {
                    square.classList.remove('capture-background');
                    if (square.contains(overlay)) {
                        square.removeChild(overlay);
                    }
                }, 1780);
            }
        }

        function playBarrageHitAnimation(targets) {
            targets.forEach(target => {
                const square = document.querySelector(`.square[data-row="${target.row}"][data-col="${target.col}"]`);
                if (!square) return;
                square.classList.add('barrage-hit');
                const duration = target.captured ? 4000 : 3000;
                setTimeout(() => {
                    square.classList.remove('barrage-hit');
                }, duration);
            });
        }

        function getRandomBarrageTargets(count) {
            const targets = [];
            const seen = new Set();
            while (targets.length < count) {
                const row = Math.floor(Math.random() * ROWS);
                const col = Math.floor(Math.random() * COLS);
                const key = `${row},${col}`;
                if (seen.has(key)) continue;
                seen.add(key);
                targets.push({ row, col });
            }
            return targets;
        }

        function flashBoardGlow(duration = 600) {
            const board = document.getElementById('board');
            if (!board) return;
            board.classList.add('barrage-glow');
            document.body.classList.add('barrage-game-glow');
            setTimeout(() => {
                board.classList.remove('barrage-glow');
                document.body.classList.remove('barrage-game-glow');
            }, duration);
        }

        function finalizeBarrage(controlButton, options = {}) {
            selectedPiece = null;
            validMoves = [];
            showPieceInfo(null);
            renderBoard();
            updateStatus();
            updateScoreDisplay();
            updateCapturedPiecesDisplay();
            updateGameLog();
            clearActiveControlButton(controlButton);
            checkGameOver();
            const releaseBarrageLock = () => {
                endBlockingAction('barrage');
                if (typeof options.onComplete === 'function') {
                    options.onComplete();
                }
                if (!gameOver && movesLeft === 0 && !reinforcementPending) {
                    triggerAiTurn();
                }
            };
            setTimeout(releaseBarrageLock, 2000);
        }

        function performBarrageShots(piece, targets, controlButton, index = 0, options = {}) {
            if (index >= targets.length) {
                finalizeBarrage(controlButton, options);
                return;
            }
            flashBoardGlow(600);
            setTimeout(() => {
                const target = targets[index];
                const captured = applyBarrageTargets(piece, [target]);
                playBarrageHitAnimation([{ ...target, captured }]);
                setTimeout(() => performBarrageShots(piece, targets, controlButton, index + 1, options), 900);
            }, 600);
        }

        initializeHighScoreSystem();
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.variant-option')) {
                resetVariantSelections();
            }
            const howToModal = document.getElementById('how-to-play-modal');
            if (howToModal && howToModal.style.display === 'block') {
                const clickedInsideModal = event.target.closest('#how-to-play-modal');
                const clickedHowToButton = event.target.closest('.how-to-button');
                if (!clickedInsideModal && !clickedHowToButton) {
                    closeHowToPlay();
                }
            }
        });

        initializeBoardAnchoredModals();
        resetVariantSelections();
    </script>
</body>
</html>
